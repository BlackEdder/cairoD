<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>cairo.c.cairo - CairoD </title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="../js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="header">
		<a id="d-language" href="https://github.com/jpf91/cairoD">cairod api reference</a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
</div>
    
<div class="navblock">
    <h2><a href="" title="CairoD wrapper">cairo</a></h2>
    <ul><li><a href="cairo_cairo.html" title="">cairo.cairo</a></li>
	<li><a href="cairo_directfb.html" title="">cairo.directfb</a></li>
	<li><a href="cairo_pdf.html" title="">cairo.pdf</a></li>
	<li><a href="cairo_ps.html" title="">cairo.ps</a></li>
	<li><a href="cairo_svg.html" title="">cairo.svg</a></li>
    <li><a href="cairo_win32.html" title="">cairo.win32</a></li>
    <li><a href="cairo_xcb.html" title="">cairo.xcb</a></li>
    <li><a href="cairo_util.html" title="">cairo.util</a></li>
    </ul>
    <h2><a href="" title="cairo D bindings">cairo.c</a></h2>
    <ul><li><a href="cairo_c_cairo.html" title="">cairo.c.cairo</a></li>
	<li><a href="cairo_c_directfb.html" title="">cairo.c.directfb</a></li>
	<li><a href="cairo_c_pdf.html" title="">cairo.c.pdf</a></li>
	<li><a href="cairo_c_ps.html" title="">cairo.c.ps</a></li>
	<li><a href="cairo_c_svg.html" title="">cairo.c.svg</a></li>
    <li><a href="cairo_c_win32.html" title="">cairo.c.win32</a></li>
    <li><a href="cairo_c_xcb.html" title="">cairo.c.xcb</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>cairo.c.cairo</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from cairo/c/cairo.d -->
Cairo C API. Contains stuff from <a name="cairo"></a><span class="ddoc_psymbol">cairo</span>.h and <a name="cairo"></a><span class="ddoc_psymbol">cairo</span>-version.h
<p></p>
This module only contains basic documentation. For more information
 see <a href="http://cairographics.org/manual/">http://cairographics.org/manual/</a>

<p></p>
<b>License:</b><br><table cellspacing=0 cellpadding=5 class=book><caption></caption>   <tr><td valign=top>cairoD wrapper/bindings</td>
     <td valign=top><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a></td></tr>
   <tr><td valign=top><a href="http://cgit.freedesktop.org/cairo/tree/COPYING">cairo</a></td>
     <td valign=top><a href="http://cgit.freedesktop.org/cairo/tree/COPYING-LGPL-2.1">LGPL 2.1</a> /
     <a href="http://cgit.freedesktop.org/cairo/plain/COPYING-MPL-1.1">MPL 1.1</a></td></tr>
 </table>
<p></p>
<b>Authors:</b><br><table cellspacing=0 cellpadding=5 class=book><caption></caption>   <tr><td valign=top>Johannes Pfau</td> <td valign=top>cairoD</td></tr>
   <tr><td valign=top><a href="http://cairographics.org">cairo team</a></td> <td valign=top>cairo</td></tr>
 </table><p></p>

<dl><dt class="d_decl">int <a name="CAIRO_VERSION_MAJOR"></a><span class="ddoc_psymbol">CAIRO_VERSION_MAJOR</span>;
<br>int <a name="CAIRO_VERSION_MINOR"></a><span class="ddoc_psymbol">CAIRO_VERSION_MINOR</span>;
<br>int <a name="CAIRO_VERSION_MICRO"></a><span class="ddoc_psymbol">CAIRO_VERSION_MICRO</span>;
</dt>
<dd>Cairo binding version. Use the cairo_version() function to get
 version information about the cairo library.<p></p>

</dd>
<dt class="d_decl">ulong <a name="CAIRO_VERSION_ENCODE"></a><span class="ddoc_psymbol">CAIRO_VERSION_ENCODE</span>(uint <i>major</i>, uint <i>minor</i>, uint <i>micro</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">ulong <a name="CAIRO_VERSION"></a><span class="ddoc_psymbol">CAIRO_VERSION</span>;
</dt>
<dd>Encoded cairo binding version<p></p>

</dd>
<dt class="d_decl">string <a name="CAIRO_VERSION_STRINGIZE"></a><span class="ddoc_psymbol">CAIRO_VERSION_STRINGIZE</span>(uint <i>major</i>, uint <i>minor</i>, uint <i>micro</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">string <a name="CAIRO_VERSION_STRING"></a><span class="ddoc_psymbol">CAIRO_VERSION_STRING</span>;
</dt>
<dd>Cairo binding version string<p></p>

</dd>
<dt class="d_decl">int <a name="cairo_version"></a><span class="ddoc_psymbol">cairo_version</span>();
</dt>
<dd>Encoded library version<p></p>

</dd>
<dt class="d_decl">immutable(char)* <a name="cairo_version_string"></a><span class="ddoc_psymbol">cairo_version_string</span>();
</dt>
<dd>Library version string<p></p>

</dd>
<dt class="d_decl">alias <a name="cairo_bool_t"></a><span class="ddoc_psymbol">cairo_bool_t</span>;
</dt>
<dd><a name="cairo_bool_t"></a><span class="ddoc_psymbol">cairo_bool_t</span> is used for boolean values. Returns of type
 <a name="cairo_bool_t"></a><span class="ddoc_psymbol">cairo_bool_t</span> will always be either 0 or 1, but testing against
 these values explicitly is not encouraged; just use the
 value as a boolean condition.
<p></p>
<b>Examples:</b><br><pre class="d_code">  <span class="d_keyword">if</span> (cairo_in_stroke (cr, x, y)) {
      <span class="d_comment">//do something
</span>  }
</pre>
<p></p>

</dd>
<dt class="d_decl">struct <a name="cairo_t"></a><span class="ddoc_psymbol">cairo_t</span>;
</dt>
<dd>A <a name="cairo_t"></a><span class="ddoc_psymbol">cairo_t</span> contains the current state of the rendering device,
 including coordinates of yet to be drawn shapes.
<p></p>
Cairo contexts, as <a name="cairo_t"></a><span class="ddoc_psymbol">cairo_t</span> objects are named, are central to
 cairo and all drawing with cairo is always done to a <a name="cairo_t"></a><span class="ddoc_psymbol">cairo_t</span>
 object.
<p></p>

 Memory management of <a name="cairo_t"></a><span class="ddoc_psymbol">cairo_t</span> is done with
 cairo_reference() and cairo_destroy().<p></p>

</dd>
<dt class="d_decl">struct <a name="cairo_surface_t"></a><span class="ddoc_psymbol">cairo_surface_t</span>;
</dt>
<dd>A <a name="cairo_surface_t"></a><span class="ddoc_psymbol">cairo_surface_t</span> represents an image, either as the destination
 of a drawing operation or as source when drawing onto another
 surface.  To draw to a <a name="cairo_surface_t"></a><span class="ddoc_psymbol">cairo_surface_t</span>, create a cairo context
 with the surface as the target, using cairo_create().
<p></p>
There are different subtypes of <a name="cairo_surface_t"></a><span class="ddoc_psymbol">cairo_surface_t</span> for
 different drawing backends; for example, cairo_image_surface_create()
 creates a bitmap image in memory.
 The type of a surface can be queried with cairo_surface_get_type().
<p></p>

 The initial contents of a surface after creation depend upon the manner
 of its creation. If cairo creates the surface and backing storage for
 the user, it will be initially cleared; for example,
 cairo_image_surface_create() and cairo_surface_create_similar().
 Alternatively, if the user passes in a reference to some backing storage
 and asks cairo to wrap that in a <a name="cairo_surface_t"></a><span class="ddoc_psymbol">cairo_surface_t</span>, then the contents are
 not modified; for example, cairo_image_surface_create_for_data() and
 cairo_xlib_surface_create().
<p></p>

 Memory management of <a name="cairo_surface_t"></a><span class="ddoc_psymbol">cairo_surface_t</span> is done with
 cairo_surface_reference() and cairo_surface_destroy().<p></p>

</dd>
<dt class="d_decl">struct <a name="cairo_device_t"></a><span class="ddoc_psymbol">cairo_device_t</span>;
</dt>
<dd>A <a name="cairo_device_t"></a><span class="ddoc_psymbol">cairo_device_t</span> represents the driver interface for drawing
 operations to a cairo_surface_t.  There are different subtypes of
 <a name="cairo_device_t"></a><span class="ddoc_psymbol">cairo_device_t</span> for different drawing backends; for example,
 cairo_xcb_device_create() creates a device that wraps the connection
 to an X Windows System using the XCB library.
<p></p>
The type of a device can be queried with cairo_device_get_type().
<p></p>

 Memory management of <a name="cairo_device_t"></a><span class="ddoc_psymbol">cairo_device_t</span> is done with
 cairo_device_reference() and cairo_device_destroy().

<p></p>
<b>Since:</b><br>
1.10<p></p>

</dd>
<dt class="d_decl">struct <a name="cairo_matrix_t"></a><span class="ddoc_psymbol">cairo_matrix_t</span>;
</dt>
<dd>A <span class="d_inlinecode"><a name="cairo_matrix_t"></a><span class="ddoc_psymbol">cairo_matrix_t</span></span> holds an affine transformation, such as a scale,
 rotation, shear, or a combination of those. The transformation of
 a point (x, y) is given by:
<pre class="d_code">     x_new = xx * x + xy * y + x0;
     y_new = yx * x + yy * y + y0;
</pre>
<p></p>

<dl><dt class="d_decl">double <a name="xx"></a><span class="ddoc_psymbol">xx</span>;
</dt>
<dd><a name="xx"></a><span class="ddoc_psymbol">xx</span> component of the affine transformation<p></p>

</dd>
<dt class="d_decl">double <a name="yx"></a><span class="ddoc_psymbol">yx</span>;
</dt>
<dd><a name="yx"></a><span class="ddoc_psymbol">yx</span> component of the affine transformation<p></p>

</dd>
<dt class="d_decl">double <a name="xy"></a><span class="ddoc_psymbol">xy</span>;
</dt>
<dd><a name="xy"></a><span class="ddoc_psymbol">xy</span> component of the affine transformation<p></p>

</dd>
<dt class="d_decl">double <a name="yy"></a><span class="ddoc_psymbol">yy</span>;
</dt>
<dd><a name="yy"></a><span class="ddoc_psymbol">yy</span> component of the affine transformation<p></p>

</dd>
<dt class="d_decl">double <a name="x0"></a><span class="ddoc_psymbol">x0</span>;
</dt>
<dd>X translation component of the affine transformation<p></p>

</dd>
<dt class="d_decl">double <a name="y0"></a><span class="ddoc_psymbol">y0</span>;
</dt>
<dd>Y translation component of the affine transformation<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="cairo_pattern_t"></a><span class="ddoc_psymbol">cairo_pattern_t</span>;
</dt>
<dd>A <span class="d_inlinecode"><a name="cairo_pattern_t"></a><span class="ddoc_psymbol">cairo_pattern_t</span></span> represents a source when drawing onto a
 surface. There are different subtypes of <span class="d_inlinecode"><a name="cairo_pattern_t"></a><span class="ddoc_psymbol">cairo_pattern_t</span></span>,
 for different types of sources; for example,
 <span class="d_inlinecode">cairo_pattern_create_rgb()</span> creates a pattern for a solid
 opaque color.
<p></p>
Other than various cairo_pattern_create_<b>type</b>()
 functions, some of the pattern types can be implicitly created
 using various cairo_set_source_<b>type</b>() functions;
 for example cairo_set_source_rgb().
<p></p>

 The type of a pattern can be queried with cairo_pattern_get_type().
<p></p>

 Memory management of <span class="d_inlinecode"><a name="cairo_pattern_t"></a><span class="ddoc_psymbol">cairo_pattern_t</span></span> is done with
 cairo_pattern_reference() and cairo_pattern_destroy().<p></p>

</dd>
<dt class="d_decl">alias <a name="cairo_destroy_func_t"></a><span class="ddoc_psymbol">cairo_destroy_func_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_destroy_func_t"></a><span class="ddoc_psymbol">cairo_destroy_func_t</span></span> the type of function which is called when a
 data element is destroyed. It is passed the pointer to the data
 element and should free any memory and resources allocated for it.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>data</td>
<td valign=top>The data element being destroyed.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">struct <a name="cairo_user_data_key_t"></a><span class="ddoc_psymbol">cairo_user_data_key_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_user_data_key_t"></a><span class="ddoc_psymbol">cairo_user_data_key_t</span></span> is used for attaching user data to cairo
 data structures.  The actual contents of the struct is never used,
 and there is no need to initialize the object; only the unique
 address of a <span class="d_inlinecode">cairo_data_key_t</span> object is used.  Typically, you
 would just use the address of a static <span class="d_inlinecode">cairo_data_key_t</span> object.<p></p>

<dl><dt class="d_decl">int <a name="unused"></a><span class="ddoc_psymbol">unused</span>;
</dt>
<dd>not used; ignore.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">enum <a name="cairo_status_t"></a><span class="ddoc_psymbol">cairo_status_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_status_t"></a><span class="ddoc_psymbol">cairo_status_t</span></span> is used to indicate errors that can occur when
 using Cairo. In some cases it is returned directly by functions.
 but when using <span class="d_inlinecode">cairo_t</span>, the last error, if any, is stored in
 the context and can be retrieved with cairo_status().
<p></p>
New entries may be added in future versions.  Use cairo_status_to_string()
 to get a human-readable representation of an error message.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_STATUS_SUCCESS"></a><span class="ddoc_psymbol">CAIRO_STATUS_SUCCESS</span></dt>
<dd>no error has occurred<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_NO_MEMORY"></a><span class="ddoc_psymbol">CAIRO_STATUS_NO_MEMORY</span></dt>
<dd>out of memory<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_RESTORE"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_RESTORE</span></dt>
<dd>cairo_restore() called without matching cairo_save()<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_POP_GROUP"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_POP_GROUP</span></dt>
<dd>no saved group to pop, i.e. cairo_pop_group() without matching cairo_push_group()<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_NO_CURRENT_POINT"></a><span class="ddoc_psymbol">CAIRO_STATUS_NO_CURRENT_POINT</span></dt>
<dd>no current point defined<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_MATRIX"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_MATRIX</span></dt>
<dd>invalid matrix (not invertible)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_STATUS"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_STATUS</span></dt>
<dd>invalid value for an input <span class="d_inlinecode">cairo_status_t</span><p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_NULL_POINTER"></a><span class="ddoc_psymbol">CAIRO_STATUS_NULL_POINTER</span></dt>
<dd><span class="d_inlinecode"><b>null</b></span> pointer<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_STRING"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_STRING</span></dt>
<dd>input string not valid UTF-8<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_PATH_DATA"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_PATH_DATA</span></dt>
<dd>input path data not valid<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_READ_ERROR"></a><span class="ddoc_psymbol">CAIRO_STATUS_READ_ERROR</span></dt>
<dd>error while reading from input stream<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_WRITE_ERROR"></a><span class="ddoc_psymbol">CAIRO_STATUS_WRITE_ERROR</span></dt>
<dd>error while writing to output stream<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_SURFACE_FINISHED"></a><span class="ddoc_psymbol">CAIRO_STATUS_SURFACE_FINISHED</span></dt>
<dd>target surface has been finished<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_SURFACE_TYPE_MISMATCH"></a><span class="ddoc_psymbol">CAIRO_STATUS_SURFACE_TYPE_MISMATCH</span></dt>
<dd>the surface type is not appropriate for the operation<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_PATTERN_TYPE_MISMATCH"></a><span class="ddoc_psymbol">CAIRO_STATUS_PATTERN_TYPE_MISMATCH</span></dt>
<dd>the pattern type is not appropriate for the operation<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_CONTENT"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_CONTENT</span></dt>
<dd>invalid value for an input <span class="d_inlinecode">cairo_content_t</span><p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_FORMAT"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_FORMAT</span></dt>
<dd>invalid value for an input <span class="d_inlinecode">cairo_format_t</span><p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_VISUAL"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_VISUAL</span></dt>
<dd>invalid value for an input Visual*<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_FILE_NOT_FOUND"></a><span class="ddoc_psymbol">CAIRO_STATUS_FILE_NOT_FOUND</span></dt>
<dd>file not found<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_DASH"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_DASH</span></dt>
<dd>invalid value for a dash setting<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_DSC_COMMENT"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_DSC_COMMENT</span></dt>
<dd>invalid value for a DSC comment (Since 1.2)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_INDEX"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_INDEX</span></dt>
<dd>invalid index passed to getter (Since 1.4)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_CLIP_NOT_REPRESENTABLE"></a><span class="ddoc_psymbol">CAIRO_STATUS_CLIP_NOT_REPRESENTABLE</span></dt>
<dd>clip region not representable in desired format (Since 1.4)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_TEMP_FILE_ERROR"></a><span class="ddoc_psymbol">CAIRO_STATUS_TEMP_FILE_ERROR</span></dt>
<dd>error creating or writing to a temporary file (Since 1.6)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_STRIDE"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_STRIDE</span></dt>
<dd>invalid value for stride (Since 1.6)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_FONT_TYPE_MISMATCH"></a><span class="ddoc_psymbol">CAIRO_STATUS_FONT_TYPE_MISMATCH</span></dt>
<dd>the font type is not appropriate for the operation (Since 1.8)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_USER_FONT_IMMUTABLE"></a><span class="ddoc_psymbol">CAIRO_STATUS_USER_FONT_IMMUTABLE</span></dt>
<dd>the user-font is immutable (Since 1.8)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_USER_FONT_ERROR"></a><span class="ddoc_psymbol">CAIRO_STATUS_USER_FONT_ERROR</span></dt>
<dd>error occurred in a user-font callback function (Since 1.8)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_NEGATIVE_COUNT"></a><span class="ddoc_psymbol">CAIRO_STATUS_NEGATIVE_COUNT</span></dt>
<dd>negative number used where it is not allowed (Since 1.8)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_CLUSTERS"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_CLUSTERS</span></dt>
<dd>input clusters do not represent the accompanying text and glyph array (Since 1.8)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_SLANT"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_SLANT</span></dt>
<dd>invalid value for an input <span class="d_inlinecode">cairo_font_slant_t</span> (Since 1.8)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_WEIGHT"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_WEIGHT</span></dt>
<dd>invalid value for an input <span class="d_inlinecode">cairo_font_weight_t</span> (Since 1.8)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_INVALID_SIZE"></a><span class="ddoc_psymbol">CAIRO_STATUS_INVALID_SIZE</span></dt>
<dd>invalid value (typically too big) for the size of the input (surface, pattern, etc.) (Since 1.10)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED"></a><span class="ddoc_psymbol">CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED</span></dt>
<dd>user-font method not implemented (Since 1.10)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_DEVICE_TYPE_MISMATCH"></a><span class="ddoc_psymbol">CAIRO_STATUS_DEVICE_TYPE_MISMATCH</span></dt>
<dd>the device type is not appropriate for the operation (Since 1.10)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_DEVICE_ERROR"></a><span class="ddoc_psymbol">CAIRO_STATUS_DEVICE_ERROR</span></dt>
<dd>an operation to the device caused an unspecified error (Since 1.10)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_STATUS_LAST_STATUS"></a><span class="ddoc_psymbol">CAIRO_STATUS_LAST_STATUS</span></dt>
<dd>this is a special value indicating the number of
 status values defined in this enumeration.  When using this value, note
 that the version of cairo at run-time may have additional status values
 defined than the value of this symbol at compile-time. (Since 1.10)<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">enum <a name="cairo_content_t"></a><span class="ddoc_psymbol">cairo_content_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_content_t"></a><span class="ddoc_psymbol">cairo_content_t</span></span> is used to describe the content that a surface will
 contain, whether color information, alpha information (translucence
 vs. opacity), or both.
<p></p>
<b>Note:</b><br>
The large values here are designed to keep <span class="d_inlinecode"><a name="cairo_content_t"></a><span class="ddoc_psymbol">cairo_content_t</span></span>
 values distinct from <span class="d_inlinecode">cairo_format_t</span> values so that the
 implementation can detect the error if users confuse the two types.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_CONTENT_COLOR"></a><span class="ddoc_psymbol">CAIRO_CONTENT_COLOR</span></dt>
<dd>The surface will hold color content only.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_CONTENT_ALPHA"></a><span class="ddoc_psymbol">CAIRO_CONTENT_ALPHA</span></dt>
<dd>The surface will hold alpha content only.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_CONTENT_COLOR_ALPHA"></a><span class="ddoc_psymbol">CAIRO_CONTENT_COLOR_ALPHA</span></dt>
<dd>The surface will hold color and alpha content.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">alias <a name="cairo_write_func_t"></a><span class="ddoc_psymbol">cairo_write_func_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_write_func_t"></a><span class="ddoc_psymbol">cairo_write_func_t</span></span> is the type of function which is called when a
 backend needs to write data to an output stream.  It is passed the
 closure which was specified by the user at the time the write
 function was registered, the data to write and the length of the
 data in bytes.  The write function should return
 <span class="d_inlinecode">CAIRO_STATUS_SUCCESS</span> if all the data was successfully written,
 <span class="d_inlinecode">CAIRO_STATUS_WRITE_ERROR</span> otherwise.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>closure</td>
<td valign=top>the output closure</td></tr>
<tr><td valign=top>data</td>
<td valign=top>the buffer containing the data to write</td></tr>
<tr><td valign=top>length</td>
<td valign=top>the amount of data to write</td></tr>
</table><p></p>
<b>Returns:</b><br>the status code of the write operation<p></p>

</dd>
<dt class="d_decl">alias <a name="cairo_read_func_t"></a><span class="ddoc_psymbol">cairo_read_func_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_read_func_t"></a><span class="ddoc_psymbol">cairo_read_func_t</span></span> is the type of function which is called when a
 backend needs to read data from an input stream.  It is passed the
 closure which was specified by the user at the time the read
 function was registered, the buffer to read the data into and the
 length of the data in bytes.  The read function should return
 <span class="d_inlinecode">CAIRO_STATUS_SUCCESS</span> if all the data was successfully read,
 <span class="d_inlinecode">CAIRO_STATUS_READ_ERROR</span> otherwise.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>closure</td>
<td valign=top>the input closure</td></tr>
<tr><td valign=top>data</td>
<td valign=top>the buffer into which to read the data</td></tr>
<tr><td valign=top>length</td>
<td valign=top>the amount of data to read</td></tr>
</table><p></p>
<b>Returns:</b><br>the status code of the read operation<p></p>

</dd>
<dt class="d_decl">cairo_t* <a name="cairo_create"></a><span class="ddoc_psymbol">cairo_create</span>(cairo_surface_t* <i>target</i>);
<br>cairo_t* <a name="cairo_reference"></a><span class="ddoc_psymbol">cairo_reference</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_destroy"></a><span class="ddoc_psymbol">cairo_destroy</span>(cairo_t* <i>cr</i>);
<br>uint <a name="cairo_get_reference_count"></a><span class="ddoc_psymbol">cairo_get_reference_count</span>(cairo_t* <i>cr</i>);
<br>void* <a name="cairo_get_user_data"></a><span class="ddoc_psymbol">cairo_get_user_data</span>(cairo_t* <i>cr</i>, const cairo_user_data_key_t* <i>key</i>);
<br>cairo_status_t <a name="cairo_set_user_data"></a><span class="ddoc_psymbol">cairo_set_user_data</span>(cairo_t* <i>cr</i>, const cairo_user_data_key_t* <i>key</i>, void* <i>user_data</i>, cairo_destroy_func_t <i>destroy</i>);
<br>void <a name="cairo_save"></a><span class="ddoc_psymbol">cairo_save</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_restore"></a><span class="ddoc_psymbol">cairo_restore</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_push_group"></a><span class="ddoc_psymbol">cairo_push_group</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_push_group_with_content"></a><span class="ddoc_psymbol">cairo_push_group_with_content</span>(cairo_t* <i>cr</i>, cairo_content_t <i>content</i>);
<br>cairo_pattern_t* <a name="cairo_pop_group"></a><span class="ddoc_psymbol">cairo_pop_group</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_pop_group_to_source"></a><span class="ddoc_psymbol">cairo_pop_group_to_source</span>(cairo_t* <i>cr</i>);
</dt>
<dd>Functions for manipulating state objects <p></p>

</dd>
<dt class="d_decl">enum <a name="cairo_operator_t"></a><span class="ddoc_psymbol">cairo_operator_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_operator_t"></a><span class="ddoc_psymbol">cairo_operator_t</span></span> is used to set the compositing operator for all cairo
 drawing operations.
<p></p>
The default operator is <span class="d_inlinecode">CAIRO_OPERATOR_OVER</span>.
<p></p>

 The operators marked as <i>unbounded</i> modify their
 destination even outside of the mask layer (that is, their effect is not
 bound by the mask layer).  However, their effect can still be limited by
 way of clipping.
<p></p>

 To keep things simple, the operator descriptions here
 document the behavior for when both source and destination are either fully
 transparent or fully opaque.  The actual implementation works for
 translucent layers too.
 For a more detailed explanation of the effects of each operator, including
 the mathematical definitions, see
 <a href="http://cairographics.org/operators/">http://cairographics.org/operators/</a>.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_OPERATOR_CLEAR"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_CLEAR</span></dt>
<dd>clear destination layer (bounded)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_SOURCE"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_SOURCE</span></dt>
<dd>replace destination layer (bounded)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_OVER"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_OVER</span></dt>
<dd>draw source layer on top of destination layer (bounded)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_IN"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_IN</span></dt>
<dd>draw source where there was destination content (unbounded)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_OUT"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_OUT</span></dt>
<dd>draw source where there was no destination content (unbounded)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_ATOP"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_ATOP</span></dt>
<dd>draw source on top of destination content and only there<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_DEST"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_DEST</span></dt>
<dd>ignore the source<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_DEST_OVER"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_DEST_OVER</span></dt>
<dd>draw destination on top of source<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_DEST_IN"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_DEST_IN</span></dt>
<dd>leave destination only where there was source content (unbounded)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_DEST_OUT"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_DEST_OUT</span></dt>
<dd>leave destination only where there was no source content<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_DEST_ATOP"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_DEST_ATOP</span></dt>
<dd>leave destination on top of source content and only there (unbounded)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_XOR"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_XOR</span></dt>
<dd>source and destination are shown where there is only one of them<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_ADD"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_ADD</span></dt>
<dd>source and destination layers are accumulated<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_SATURATE"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_SATURATE</span></dt>
<dd>like over, but assuming source and dest are disjoint geometries<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_MULTIPLY"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_MULTIPLY</span></dt>
<dd>source and destination layers are multiplied. This causes the result to be at least as dark as the darker inputs.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_SCREEN"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_SCREEN</span></dt>
<dd>source and destination are complemented and multiplied. This causes the result to be at least as light as the lighter inputs.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_OVERLAY"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_OVERLAY</span></dt>
<dd>multiplies or screens, depending on the lightness of the destination color.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_DARKEN"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_DARKEN</span></dt>
<dd>replaces the destination with the source if it is darker, otherwise keeps the source.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_LIGHTEN"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_LIGHTEN</span></dt>
<dd>replaces the destination with the source if it is lighter, otherwise keeps the source.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_COLOR_DODGE"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_COLOR_DODGE</span></dt>
<dd>brightens the destination color to reflect the source color.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_COLOR_BURN"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_COLOR_BURN</span></dt>
<dd>darkens the destination color to reflect the source color.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_HARD_LIGHT"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_HARD_LIGHT</span></dt>
<dd>Multiplies or screens, dependant on source color.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_SOFT_LIGHT"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_SOFT_LIGHT</span></dt>
<dd>Darkens or lightens, dependant on source color.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_DIFFERENCE"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_DIFFERENCE</span></dt>
<dd>Takes the difference of the source and destination color.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_EXCLUSION"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_EXCLUSION</span></dt>
<dd>Produces an effect similar to difference, but with lower contrast.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_HSL_HUE"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_HSL_HUE</span></dt>
<dd>Creates a color with the hue of the source and the saturation and luminosity of the target.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_HSL_SATURATION"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_HSL_SATURATION</span></dt>
<dd>Creates a color with the saturation of the source and the hue and luminosity of the target. Painting with this mode onto a gray area prduces no change.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_HSL_COLOR"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_HSL_COLOR</span></dt>
<dd>Creates a color with the hue and saturation
 of the source and the luminosity of the target. This preserves the gray
 levels of the target and is useful for coloring monochrome images or
 tinting color images.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_OPERATOR_HSL_LUMINOSITY"></a><span class="ddoc_psymbol">CAIRO_OPERATOR_HSL_LUMINOSITY</span></dt>
<dd>Creates a color with the luminosity of
 the source and the hue and saturation of the target. This produces an
 inverse effect to <span class="d_inlinecode">CAIRO_OPERATOR_HSL_COLOR</span>.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">void <a name="cairo_set_operator"></a><span class="ddoc_psymbol">cairo_set_operator</span>(cairo_t* <i>cr</i>, cairo_operator_t <i>op</i>);
<br>void <a name="cairo_set_source"></a><span class="ddoc_psymbol">cairo_set_source</span>(cairo_t* <i>cr</i>, cairo_pattern_t* <i>source</i>);
<br>void <a name="cairo_set_source_rgb"></a><span class="ddoc_psymbol">cairo_set_source_rgb</span>(cairo_t* <i>cr</i>, double <i>red</i>, double <i>green</i>, double <i>blue</i>);
<br>void <a name="cairo_set_source_rgba"></a><span class="ddoc_psymbol">cairo_set_source_rgba</span>(cairo_t* <i>cr</i>, double <i>red</i>, double <i>green</i>, double <i>blue</i>, double <i>alpha</i>);
<br>void <a name="cairo_set_source_surface"></a><span class="ddoc_psymbol">cairo_set_source_surface</span>(cairo_t* <i>cr</i>, cairo_surface_t* <i>surface</i>, double <i>x</i>, double <i>y</i>);
<br>void <a name="cairo_set_tolerance"></a><span class="ddoc_psymbol">cairo_set_tolerance</span>(cairo_t* <i>cr</i>, double <i>tolerance</i>);
</dt>
<dd>Modify state <p></p>

</dd>
<dt class="d_decl">enum <a name="cairo_antialias_t"></a><span class="ddoc_psymbol">cairo_antialias_t</span>;
</dt>
<dd>Specifies the type of antialiasing to do when rendering text or shapes.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_ANTIALIAS_DEFAULT"></a><span class="ddoc_psymbol">CAIRO_ANTIALIAS_DEFAULT</span></dt>
<dd>Use the default antialiasing for the subsystem and target device<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_ANTIALIAS_NONE"></a><span class="ddoc_psymbol">CAIRO_ANTIALIAS_NONE</span></dt>
<dd>Use a bilevel alpha mask<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_ANTIALIAS_GRAY"></a><span class="ddoc_psymbol">CAIRO_ANTIALIAS_GRAY</span></dt>
<dd>Perform single-color antialiasing (using
 shades of gray for black text on a white background, for example).<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_ANTIALIAS_SUBPIXEL"></a><span class="ddoc_psymbol">CAIRO_ANTIALIAS_SUBPIXEL</span></dt>
<dd>Perform antialiasing by taking
 advantage of the order of subpixel elements on devices
 such as LCD panels<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">void <a name="cairo_set_antialias"></a><span class="ddoc_psymbol">cairo_set_antialias</span>(cairo_t* <i>cr</i>, cairo_antialias_t <i>antialias</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">enum <a name="cairo_fill_rule_t"></a><span class="ddoc_psymbol">cairo_fill_rule_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_fill_rule_t"></a><span class="ddoc_psymbol">cairo_fill_rule_t</span></span> is used to select how paths are filled. For both
 fill rules, whether or not a point is included in the fill is
 determined by taking a ray from that point to infinity and looking
 at intersections with the path. The ray can be in any direction,
 as long as it doesn't pass through the end point of a segment
 or have a tricky intersection such as intersecting tangent to the path.
 (Note that filling is not actually implemented in this way. This
 is just a description of the rule that is applied.)
<p></p>
The default fill rule is <span class="d_inlinecode">CAIRO_FILL_RULE_WINDING</span>.
<p></p>

 New entries may be added in future versions.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_FILL_RULE_WINDING"></a><span class="ddoc_psymbol">CAIRO_FILL_RULE_WINDING</span></dt>
<dd>If the path crosses the ray from
 left-to-right, counts +1. If the path crosses the ray
 from right to left, counts -1. (Left and right are determined
 from the perspective of looking along the ray from the starting
 point.) If the total count is non-zero, the point will be filled.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FILL_RULE_EVEN_ODD"></a><span class="ddoc_psymbol">CAIRO_FILL_RULE_EVEN_ODD</span></dt>
<dd>Counts the total number of
 intersections, without regard to the orientation of the contour. If
 the total number of intersections is odd, the point will be
 filled.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">void <a name="cairo_set_fill_rule"></a><span class="ddoc_psymbol">cairo_set_fill_rule</span>(cairo_t* <i>cr</i>, cairo_fill_rule_t <i>fill_rule</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_set_line_width"></a><span class="ddoc_psymbol">cairo_set_line_width</span>(cairo_t* <i>cr</i>, double <i>width</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">enum <a name="cairo_line_cap_t"></a><span class="ddoc_psymbol">cairo_line_cap_t</span>;
</dt>
<dd>Specifies how to render the endpoints of the path when stroking.
<p></p>
The default line cap style is <span class="d_inlinecode">CAIRO_LINE_CAP_BUTT</span>.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_LINE_CAP_BUTT"></a><span class="ddoc_psymbol">CAIRO_LINE_CAP_BUTT</span></dt>
<dd>start(stop) the line exactly at the start(end) point<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_LINE_CAP_ROUND"></a><span class="ddoc_psymbol">CAIRO_LINE_CAP_ROUND</span></dt>
<dd>use a round ending, the center of the circle is the end point<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_LINE_CAP_SQUARE"></a><span class="ddoc_psymbol">CAIRO_LINE_CAP_SQUARE</span></dt>
<dd>use squared ending, the center of the square is the end point<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">void <a name="cairo_set_line_cap"></a><span class="ddoc_psymbol">cairo_set_line_cap</span>(cairo_t* <i>cr</i>, cairo_line_cap_t <i>line_cap</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">enum <a name="cairo_line_join_t"></a><span class="ddoc_psymbol">cairo_line_join_t</span>;
</dt>
<dd>Specifies how to render the junction of two lines when stroking.
<p></p>
The default line join style is <span class="d_inlinecode">CAIRO_LINE_JOIN_MITER</span>.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_LINE_JOIN_MITER"></a><span class="ddoc_psymbol">CAIRO_LINE_JOIN_MITER</span></dt>
<dd>use a sharp (angled) corner, see cairo_set_miter_limit()<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_LINE_JOIN_ROUND"></a><span class="ddoc_psymbol">CAIRO_LINE_JOIN_ROUND</span></dt>
<dd>use a rounded join, the center of the circle is the
 joint point<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_LINE_JOIN_BEVEL"></a><span class="ddoc_psymbol">CAIRO_LINE_JOIN_BEVEL</span></dt>
<dd>use a cut-off join, the join is cut off at half
 the line width from the joint point<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">void <a name="cairo_set_line_join"></a><span class="ddoc_psymbol">cairo_set_line_join</span>(cairo_t* <i>cr</i>, cairo_line_join_t <i>line_join</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_set_dash"></a><span class="ddoc_psymbol">cairo_set_dash</span>(cairo_t* <i>cr</i>, const double* <i>dashes</i>, int <i>num_dashes</i>, double <i>offset</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_set_miter_limit"></a><span class="ddoc_psymbol">cairo_set_miter_limit</span>(cairo_t* <i>cr</i>, double <i>limit</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_translate"></a><span class="ddoc_psymbol">cairo_translate</span>(cairo_t* <i>cr</i>, double <i>tx</i>, double <i>ty</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_scale"></a><span class="ddoc_psymbol">cairo_scale</span>(cairo_t* <i>cr</i>, double <i>sx</i>, double <i>sy</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_rotate"></a><span class="ddoc_psymbol">cairo_rotate</span>(cairo_t* <i>cr</i>, double <i>angle</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_transform"></a><span class="ddoc_psymbol">cairo_transform</span>(cairo_t* <i>cr</i>, const cairo_matrix_t* <i>matrix</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_set_matrix"></a><span class="ddoc_psymbol">cairo_set_matrix</span>(cairo_t* <i>cr</i>, const cairo_matrix_t* <i>matrix</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_identity_matrix"></a><span class="ddoc_psymbol">cairo_identity_matrix</span>(cairo_t* <i>cr</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_user_to_device"></a><span class="ddoc_psymbol">cairo_user_to_device</span>(cairo_t* <i>cr</i>, double* <i>x</i>, double* <i>y</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_user_to_device_distance"></a><span class="ddoc_psymbol">cairo_user_to_device_distance</span>(cairo_t* <i>cr</i>, double* <i>dx</i>, double* <i>dy</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_device_to_user"></a><span class="ddoc_psymbol">cairo_device_to_user</span>(cairo_t* <i>cr</i>, double* <i>x</i>, double* <i>y</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_device_to_user_distance"></a><span class="ddoc_psymbol">cairo_device_to_user_distance</span>(cairo_t* <i>cr</i>, double* <i>dx</i>, double* <i>dy</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_new_path"></a><span class="ddoc_psymbol">cairo_new_path</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_move_to"></a><span class="ddoc_psymbol">cairo_move_to</span>(cairo_t* <i>cr</i>, double <i>x</i>, double <i>y</i>);
<br>void <a name="cairo_new_sub_path"></a><span class="ddoc_psymbol">cairo_new_sub_path</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_line_to"></a><span class="ddoc_psymbol">cairo_line_to</span>(cairo_t* <i>cr</i>, double <i>x</i>, double <i>y</i>);
<br>void <a name="cairo_curve_to"></a><span class="ddoc_psymbol">cairo_curve_to</span>(cairo_t* <i>cr</i>, double <i>x1</i>, double <i>y1</i>, double <i>x2</i>, double <i>y2</i>, double <i>x3</i>, double <i>y3</i>);
<br>void <a name="cairo_arc"></a><span class="ddoc_psymbol">cairo_arc</span>(cairo_t* <i>cr</i>, double <i>xc</i>, double <i>yc</i>, double <i>radius</i>, double <i>angle1</i>, double <i>angle2</i>);
<br>void <a name="cairo_arc_negative"></a><span class="ddoc_psymbol">cairo_arc_negative</span>(cairo_t* <i>cr</i>, double <i>xc</i>, double <i>yc</i>, double <i>radius</i>, double <i>angle1</i>, double <i>angle2</i>);
<br>void <a name="cairo_rel_move_to"></a><span class="ddoc_psymbol">cairo_rel_move_to</span>(cairo_t* <i>cr</i>, double <i>dx</i>, double <i>dy</i>);
<br>void <a name="cairo_rel_line_to"></a><span class="ddoc_psymbol">cairo_rel_line_to</span>(cairo_t* <i>cr</i>, double <i>dx</i>, double <i>dy</i>);
<br>void <a name="cairo_rel_curve_to"></a><span class="ddoc_psymbol">cairo_rel_curve_to</span>(cairo_t* <i>cr</i>, double <i>dx1</i>, double <i>dy1</i>, double <i>dx2</i>, double <i>dy2</i>, double <i>dx3</i>, double <i>dy3</i>);
<br>void <a name="cairo_rectangle"></a><span class="ddoc_psymbol">cairo_rectangle</span>(cairo_t* <i>cr</i>, double <i>x</i>, double <i>y</i>, double <i>width</i>, double <i>height</i>);
<br>void <a name="cairo_close_path"></a><span class="ddoc_psymbol">cairo_close_path</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_path_extents"></a><span class="ddoc_psymbol">cairo_path_extents</span>(cairo_t* <i>cr</i>, double* <i>x1</i>, double* <i>y1</i>, double* <i>x2</i>, double* <i>y2</i>);
</dt>
<dd>Path creation functions <p></p>

</dd>
<dt class="d_decl">void <a name="cairo_paint"></a><span class="ddoc_psymbol">cairo_paint</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_paint_with_alpha"></a><span class="ddoc_psymbol">cairo_paint_with_alpha</span>(cairo_t* <i>cr</i>, double <i>alpha</i>);
<br>void <a name="cairo_mask"></a><span class="ddoc_psymbol">cairo_mask</span>(cairo_t* <i>cr</i>, cairo_pattern_t* <i>pattern</i>);
<br>void <a name="cairo_mask_surface"></a><span class="ddoc_psymbol">cairo_mask_surface</span>(cairo_t* <i>cr</i>, cairo_surface_t* <i>surface</i>, double <i>surface_x</i>, double <i>surface_y</i>);
<br>void <a name="cairo_stroke"></a><span class="ddoc_psymbol">cairo_stroke</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_stroke_preserve"></a><span class="ddoc_psymbol">cairo_stroke_preserve</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_fill"></a><span class="ddoc_psymbol">cairo_fill</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_fill_preserve"></a><span class="ddoc_psymbol">cairo_fill_preserve</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_copy_page"></a><span class="ddoc_psymbol">cairo_copy_page</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_show_page"></a><span class="ddoc_psymbol">cairo_show_page</span>(cairo_t* <i>cr</i>);
</dt>
<dd>Painting functions <p></p>

</dd>
<dt class="d_decl">cairo_bool_t <a name="cairo_in_stroke"></a><span class="ddoc_psymbol">cairo_in_stroke</span>(cairo_t* <i>cr</i>, double <i>x</i>, double <i>y</i>);
<br>cairo_bool_t <a name="cairo_in_fill"></a><span class="ddoc_psymbol">cairo_in_fill</span>(cairo_t* <i>cr</i>, double <i>x</i>, double <i>y</i>);
<br>cairo_bool_t <a name="cairo_in_clip"></a><span class="ddoc_psymbol">cairo_in_clip</span>(cairo_t* <i>cr</i>, double <i>x</i>, double <i>y</i>);
</dt>
<dd>Insideness testing <p></p>

</dd>
<dt class="d_decl">void <a name="cairo_stroke_extents"></a><span class="ddoc_psymbol">cairo_stroke_extents</span>(cairo_t* <i>cr</i>, double* <i>x1</i>, double* <i>y1</i>, double* <i>x2</i>, double* <i>y2</i>);
<br>void <a name="cairo_fill_extents"></a><span class="ddoc_psymbol">cairo_fill_extents</span>(cairo_t* <i>cr</i>, double* <i>x1</i>, double* <i>y1</i>, double* <i>x2</i>, double* <i>y2</i>);
</dt>
<dd>Rectangular extents <p></p>

</dd>
<dt class="d_decl">void <a name="cairo_reset_clip"></a><span class="ddoc_psymbol">cairo_reset_clip</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_clip"></a><span class="ddoc_psymbol">cairo_clip</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_clip_preserve"></a><span class="ddoc_psymbol">cairo_clip_preserve</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_clip_extents"></a><span class="ddoc_psymbol">cairo_clip_extents</span>(cairo_t* <i>cr</i>, double* <i>x1</i>, double* <i>y1</i>, double* <i>x2</i>, double* <i>y2</i>);
</dt>
<dd>Clipping <p></p>

</dd>
<dt class="d_decl">struct <a name="cairo_rectangle_t"></a><span class="ddoc_psymbol">cairo_rectangle_t</span>;
</dt>
<dd>A data structure for holding a rectangle.
<p></p>
<b>Since:</b><br>
1.4<p></p>

<dl><dt class="d_decl">double <a name="x"></a><span class="ddoc_psymbol">x</span>;
</dt>
<dd>X coordinate of the left side of the rectangle<p></p>

</dd>
<dt class="d_decl">double <a name="y"></a><span class="ddoc_psymbol">y</span>;
</dt>
<dd>Y coordinate of the the top side of the rectangle<p></p>

</dd>
<dt class="d_decl">double <a name="width"></a><span class="ddoc_psymbol">width</span>;
</dt>
<dd><a name="width"></a><span class="ddoc_psymbol">width</span> of the rectangle<p></p>

</dd>
<dt class="d_decl">double <a name="height"></a><span class="ddoc_psymbol">height</span>;
</dt>
<dd><a name="height"></a><span class="ddoc_psymbol">height</span> of the rectangle<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="cairo_rectangle_list_t"></a><span class="ddoc_psymbol">cairo_rectangle_list_t</span>;
</dt>
<dd>A data structure for holding a dynamically allocated
 array of rectangles.
<p></p>
<b>Since:</b><br>
1.4<p></p>

<dl><dt class="d_decl">cairo_status_t <a name="status"></a><span class="ddoc_psymbol">status</span>;
</dt>
<dd>Error <a name="status"></a><span class="ddoc_psymbol">status</span> of the rectangle list<p></p>

</dd>
<dt class="d_decl">cairo_rectangle_t* <a name="rectangles"></a><span class="ddoc_psymbol">rectangles</span>;
</dt>
<dd>Array containing the <a name="rectangles"></a><span class="ddoc_psymbol">rectangles</span><p></p>

</dd>
<dt class="d_decl">int <a name="num_rectangles"></a><span class="ddoc_psymbol">num_rectangles</span>;
</dt>
<dd>Number of rectangles in this list<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">cairo_rectangle_list_t* <a name="cairo_copy_clip_rectangle_list"></a><span class="ddoc_psymbol">cairo_copy_clip_rectangle_list</span>(cairo_t* <i>cr</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_rectangle_list_destroy"></a><span class="ddoc_psymbol">cairo_rectangle_list_destroy</span>(cairo_rectangle_list_t* <i>rectangle_list</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">struct <a name="cairo_scaled_font_t"></a><span class="ddoc_psymbol">cairo_scaled_font_t</span>;
</dt>
<dd>A <span class="d_inlinecode"><a name="cairo_scaled_font_t"></a><span class="ddoc_psymbol">cairo_scaled_font_t</span></span> is a font scaled to a particular size and device
 resolution. A <span class="d_inlinecode"><a name="cairo_scaled_font_t"></a><span class="ddoc_psymbol">cairo_scaled_font_t</span></span> is most useful for low-level font
 usage where a library or application wants to cache a reference
 to a scaled font to speed up the computation of metrics.
<p></p>
There are various types of scaled fonts, depending on the
 <i>font backend</i> they use. The type of a
 scaled font can be queried using cairo_scaled_font_get_type().
<p></p>

 Memory management of <span class="d_inlinecode"><a name="cairo_scaled_font_t"></a><span class="ddoc_psymbol">cairo_scaled_font_t</span></span> is done with
 cairo_scaled_font_reference() and cairo_scaled_font_destroy().<p></p>

</dd>
<dt class="d_decl">struct <a name="cairo_font_face_t"></a><span class="ddoc_psymbol">cairo_font_face_t</span>;
</dt>
<dd>A <span class="d_inlinecode"><a name="cairo_font_face_t"></a><span class="ddoc_psymbol">cairo_font_face_t</span></span> specifies all aspects of a font other
 than the size or font matrix (a font matrix is used to distort
 a font by sheering it or scaling it unequally in the two
 directions) . A font face can be set on a <span class="d_inlinecode">cairo_t</span> by using
 cairo_set_font_face(); the size and font matrix are set with
 cairo_set_font_size() and cairo_set_font_matrix().
<p></p>
There are various types of font faces, depending on the
 <i>font backend</i> they use. The type of a
 font face can be queried using cairo_font_face_get_type().
<p></p>

 Memory management of <span class="d_inlinecode"><a name="cairo_font_face_t"></a><span class="ddoc_psymbol">cairo_font_face_t</span></span> is done with
 cairo_font_face_reference() and cairo_font_face_destroy().<p></p>

</dd>
<dt class="d_decl">struct <a name="cairo_glyph_t"></a><span class="ddoc_psymbol">cairo_glyph_t</span>;
</dt>
<dd>The <span class="d_inlinecode"><a name="cairo_glyph_t"></a><span class="ddoc_psymbol">cairo_glyph_t</span></span> structure holds information about a single glyph
 when drawing or measuring text. A font is (in simple terms) a
 collection of shapes used to draw text. A glyph is one of these
 shapes. There can be multiple glyphs for a single character
 (alternates to be used in different contexts, for example), or a
 glyph can be a <i>ligature</i> of multiple
 characters. Cairo doesn't expose any way of converting input text
 into glyphs, so in order to use the Cairo interfaces that take
 arrays of glyphs, you must directly access the appropriate
 underlying font system.
<p></p>
Note that the offsets given by <span class="d_inlinecode">x</span> and <span class="d_inlinecode">y</span> are not cumulative. When
 drawing or measuring text, each glyph is individually positioned
 with respect to the overall origin<p></p>

<dl><dt class="d_decl">ulong <a name="index"></a><span class="ddoc_psymbol">index</span>;
</dt>
<dd>glyph <a name="index"></a><span class="ddoc_psymbol">index</span> in the font. The exact interpretation of the
 glyph <a name="index"></a><span class="ddoc_psymbol">index</span> depends on the font technology being used.<p></p>

</dd>
<dt class="d_decl">double <a name="x"></a><span class="ddoc_psymbol">x</span>;
</dt>
<dd>the offset in the X direction between the origin used for
 drawing or measuring the string and the origin of this glyph.<p></p>

</dd>
<dt class="d_decl">double <a name="y"></a><span class="ddoc_psymbol">y</span>;
</dt>
<dd>the offset in the Y direction between the origin used for
 drawing or measuring the string and the origin of this glyph.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">cairo_glyph_t* <a name="cairo_glyph_allocate"></a><span class="ddoc_psymbol">cairo_glyph_allocate</span>(int <i>num_glyphs</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_glyph_free"></a><span class="ddoc_psymbol">cairo_glyph_free</span>(cairo_glyph_t* <i>glyphs</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">struct <a name="cairo_text_cluster_t"></a><span class="ddoc_psymbol">cairo_text_cluster_t</span>;
</dt>
<dd>The <span class="d_inlinecode"><a name="cairo_text_cluster_t"></a><span class="ddoc_psymbol">cairo_text_cluster_t</span></span> structure holds information about a single
 <i>text cluster</i>.  A text cluster is a minimal
 mapping of some glyphs corresponding to some UTF-8 text.
<p></p>
For a cluster to be valid, both <span class="d_inlinecode">num_bytes</span> and <span class="d_inlinecode">num_glyphs</span> should
 be non-negative, and at least one should be non-zero.
 Note that clusters with zero glyphs are not as well supported as
 normal clusters.  For example, PDF rendering applications typically
 ignore those clusters when PDF text is being selected.
<p></p>

 See cairo_show_text_glyphs() for how clusters are used in advanced
 text operations.

<p></p>
<b>Since:</b><br>
1.8<p></p>

<dl><dt class="d_decl">int <a name="num_bytes"></a><span class="ddoc_psymbol">num_bytes</span>;
</dt>
<dd>the number of bytes of UTF-8 text covered by cluster<p></p>

</dd>
<dt class="d_decl">int <a name="num_glyphs"></a><span class="ddoc_psymbol">num_glyphs</span>;
</dt>
<dd>the number of glyphs covered by cluster<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">cairo_text_cluster_t* <a name="cairo_text_cluster_allocate"></a><span class="ddoc_psymbol">cairo_text_cluster_allocate</span>(int <i>num_clusters</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_text_cluster_free"></a><span class="ddoc_psymbol">cairo_text_cluster_free</span>(cairo_text_cluster_t* <i>clusters</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">enum <a name="cairo_text_cluster_flags_t"></a><span class="ddoc_psymbol">cairo_text_cluster_flags_t</span>;
</dt>
<dd>Specifies properties of a text cluster mapping.
<p></p>
<b>Since:</b><br>
1.8<p></p>

<dl><dt class="d_decl"><a name="CAIRO_TEXT_CLUSTER_FLAG_BACKWARD"></a><span class="ddoc_psymbol">CAIRO_TEXT_CLUSTER_FLAG_BACKWARD</span></dt>
<dd>The clusters in the cluster array
 map to glyphs in the glyph array from end to start.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="cairo_text_extents_t"></a><span class="ddoc_psymbol">cairo_text_extents_t</span>;
</dt>
<dd>The <span class="d_inlinecode"><a name="cairo_text_extents_t"></a><span class="ddoc_psymbol">cairo_text_extents_t</span></span> structure stores the extents of a single
 glyph or a string of glyphs in user-space coordinates. Because text
 extents are in user-space coordinates, they are mostly, but not
 entirely, independent of the current transformation matrix. If you call
 <span class="d_inlinecode">cairo_scale(cr, 2.0, 2.0)</span>, text will
 be drawn twice as big, but the reported text extents will not be
 doubled. They will change slightly due to hinting (so you can't
 assume that metrics are independent of the transformation matrix),
 but otherwise will remain unchanged.<p></p>

<dl><dt class="d_decl">double <a name="x_bearing"></a><span class="ddoc_psymbol">x_bearing</span>;
</dt>
<dd>the horizontal distance from the origin to the
 leftmost part of the glyphs as drawn. Positive if the
 glyphs lie entirely to the right of the origin.<p></p>

</dd>
<dt class="d_decl">double <a name="y_bearing"></a><span class="ddoc_psymbol">y_bearing</span>;
</dt>
<dd>the vertical distance from the origin to the
 topmost part of the glyphs as drawn. Positive only if the
 glyphs lie completely below the origin; will usually be
 negative.<p></p>

</dd>
<dt class="d_decl">double <a name="width"></a><span class="ddoc_psymbol">width</span>;
</dt>
<dd><a name="width"></a><span class="ddoc_psymbol">width</span> of the glyphs as drawn<p></p>

</dd>
<dt class="d_decl">double <a name="height"></a><span class="ddoc_psymbol">height</span>;
</dt>
<dd><a name="height"></a><span class="ddoc_psymbol">height</span> of the glyphs as drawn<p></p>

</dd>
<dt class="d_decl">double <a name="x_advance"></a><span class="ddoc_psymbol">x_advance</span>;
</dt>
<dd>distance to advance in the X direction
 after drawing these glyphs<p></p>

</dd>
<dt class="d_decl">double <a name="y_advance"></a><span class="ddoc_psymbol">y_advance</span>;
</dt>
<dd>distance to advance in the Y direction
 after drawing these glyphs. Will typically be zero except
 for vertical text layout as found in East-Asian languages.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="cairo_font_extents_t"></a><span class="ddoc_psymbol">cairo_font_extents_t</span>;
</dt>
<dd>The <span class="d_inlinecode"><a name="cairo_font_extents_t"></a><span class="ddoc_psymbol">cairo_font_extents_t</span></span> structure stores metric information for
 a font. Values are given in the current user-space coordinate
 system.
<p></p>
Because font metrics are in user-space coordinates, they are
 mostly, but not entirely, independent of the current transformation
 matrix. If you call <span class="d_inlinecode">cairo_scale(cr, 2.0, 2.0)</span>,
 text will be drawn twice as big, but the reported text extents will
 not be doubled. They will change slightly due to hinting (so you
 can't assume that metrics are independent of the transformation
 matrix), but otherwise will remain unchanged.<p></p>

<dl><dt class="d_decl">double <a name="ascent"></a><span class="ddoc_psymbol">ascent</span>;
</dt>
<dd>the distance that the font extends above the baseline.
 Note that this is not always exactly equal to the maximum
 of the extents of all the glyphs in the font, but rather
 is picked to express the font designer's intent as to
 how the font should align with elements above it.<p></p>

</dd>
<dt class="d_decl">double <a name="descent"></a><span class="ddoc_psymbol">descent</span>;
</dt>
<dd>the distance that the font extends below the baseline.
  This value is positive for typical fonts that include
  portions below the baseline. Note that this is not always
  exactly equal to the maximum of the extents of all the
  glyphs in the font, but rather is picked to express the
  font designer's intent as to how the the font should
  align with elements below it.<p></p>

</dd>
<dt class="d_decl">double <a name="height"></a><span class="ddoc_psymbol">height</span>;
</dt>
<dd>the recommended vertical distance between baselines when
 setting consecutive lines of text with the font. This
 is greater than @ascent+@descent by a
 quantity known as the <i>line spacing</i>
 or <i>external leading</i>. When space
 is at a premium, most fonts can be set with only
 a distance of @ascent+@descent between lines.<p></p>

</dd>
<dt class="d_decl">double <a name="max_x_advance"></a><span class="ddoc_psymbol">max_x_advance</span>;
</dt>
<dd>the maximum distance in the X direction that
         the the origin is advanced for any glyph in the font.<p></p>

</dd>
<dt class="d_decl">double <a name="max_y_advance"></a><span class="ddoc_psymbol">max_y_advance</span>;
</dt>
<dd>the maximum distance in the Y direction that
         the the origin is advanced for any glyph in the font.
         this will be zero for normal fonts used for horizontal
         writing. (The scripts of East Asia are sometimes written
         vertically.)<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">enum <a name="cairo_font_slant_t"></a><span class="ddoc_psymbol">cairo_font_slant_t</span>;
</dt>
<dd>Specifies variants of a font face based on their slant.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_FONT_SLANT_NORMAL"></a><span class="ddoc_psymbol">CAIRO_FONT_SLANT_NORMAL</span></dt>
<dd>Upright font style<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FONT_SLANT_ITALIC"></a><span class="ddoc_psymbol">CAIRO_FONT_SLANT_ITALIC</span></dt>
<dd>Italic font style<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FONT_SLANT_OBLIQUE"></a><span class="ddoc_psymbol">CAIRO_FONT_SLANT_OBLIQUE</span></dt>
<dd>Oblique font style<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">enum <a name="cairo_font_weight_t"></a><span class="ddoc_psymbol">cairo_font_weight_t</span>;
</dt>
<dd>Specifies variants of a font face based on their weight.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_FONT_WEIGHT_NORMAL"></a><span class="ddoc_psymbol">CAIRO_FONT_WEIGHT_NORMAL</span></dt>
<dd>Normal font weight<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FONT_WEIGHT_BOLD"></a><span class="ddoc_psymbol">CAIRO_FONT_WEIGHT_BOLD</span></dt>
<dd>Bold font weight<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">enum <a name="cairo_subpixel_order_t"></a><span class="ddoc_psymbol">cairo_subpixel_order_t</span>;
</dt>
<dd>The subpixel order specifies the order of color elements within
 each pixel on the display device when rendering with an
 antialiasing mode of <span class="d_inlinecode">CAIRO_ANTIALIAS_SUBPIXEL</span>.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_SUBPIXEL_ORDER_DEFAULT"></a><span class="ddoc_psymbol">CAIRO_SUBPIXEL_ORDER_DEFAULT</span></dt>
<dd>Use the default subpixel order for
 for the target device<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SUBPIXEL_ORDER_RGB"></a><span class="ddoc_psymbol">CAIRO_SUBPIXEL_ORDER_RGB</span></dt>
<dd>Subpixel elements are arranged horizontally
 with red at the left<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SUBPIXEL_ORDER_BGR"></a><span class="ddoc_psymbol">CAIRO_SUBPIXEL_ORDER_BGR</span></dt>
<dd>Subpixel elements are arranged horizontally
 with blue at the left<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SUBPIXEL_ORDER_VRGB"></a><span class="ddoc_psymbol">CAIRO_SUBPIXEL_ORDER_VRGB</span></dt>
<dd>Subpixel elements are arranged vertically
 with red at the top<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SUBPIXEL_ORDER_VBGR"></a><span class="ddoc_psymbol">CAIRO_SUBPIXEL_ORDER_VBGR</span></dt>
<dd>Subpixel elements are arranged vertically
 with blue at the top<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">enum <a name="cairo_hint_style_t"></a><span class="ddoc_psymbol">cairo_hint_style_t</span>;
</dt>
<dd>Specifies the type of hinting to do on font outlines. Hinting
 is the process of fitting outlines to the pixel grid in order
 to improve the appearance of the result. Since hinting outlines
 involves distorting them, it also reduces the faithfulness
 to the original outline shapes. Not all of the outline hinting
 styles are supported by all font backends.
<p></p>
New entries may be added in future versions.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_HINT_STYLE_DEFAULT"></a><span class="ddoc_psymbol">CAIRO_HINT_STYLE_DEFAULT</span></dt>
<dd>Use the default hint style for font backend and target device<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_HINT_STYLE_NONE"></a><span class="ddoc_psymbol">CAIRO_HINT_STYLE_NONE</span></dt>
<dd>Do not hint outlines<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_HINT_STYLE_SLIGHT"></a><span class="ddoc_psymbol">CAIRO_HINT_STYLE_SLIGHT</span></dt>
<dd>Hint outlines slightly to improve
 contrast while retaining good fidelity to the original
 shapes.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_HINT_STYLE_MEDIUM"></a><span class="ddoc_psymbol">CAIRO_HINT_STYLE_MEDIUM</span></dt>
<dd>Hint outlines with medium strength
 giving a compromise between fidelity to the original shapes
 and contrast<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_HINT_STYLE_FULL"></a><span class="ddoc_psymbol">CAIRO_HINT_STYLE_FULL</span></dt>
<dd>Hint outlines to maximize contrast<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">enum <a name="cairo_hint_metrics_t"></a><span class="ddoc_psymbol">cairo_hint_metrics_t</span>;
</dt>
<dd>Specifies whether to hint font metrics; hinting font metrics
 means quantizing them so that they are integer values in
 device space. Doing this improves the consistency of
 letter and line spacing, however it also means that text
 will be laid out differently at different zoom factors.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_HINT_METRICS_DEFAULT"></a><span class="ddoc_psymbol">CAIRO_HINT_METRICS_DEFAULT</span></dt>
<dd>Hint metrics in the default
 manner for the font backend and target device<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_HINT_METRICS_OFF"></a><span class="ddoc_psymbol">CAIRO_HINT_METRICS_OFF</span></dt>
<dd>Do not hint font metrics<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_HINT_METRICS_ON"></a><span class="ddoc_psymbol">CAIRO_HINT_METRICS_ON</span></dt>
<dd>Hint font metrics<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="cairo_font_options_t"></a><span class="ddoc_psymbol">cairo_font_options_t</span>;
</dt>
<dd>An opaque structure holding all options that are used when
 rendering fonts.
<p></p>
Individual features of a <span class="d_inlinecode"><a name="cairo_font_options_t"></a><span class="ddoc_psymbol">cairo_font_options_t</span></span> can be set or
 accessed using functions named
 cairo_font_options_set_<b>feature_name</b> and
 cairo_font_options_get_<b>feature_name</b>, like
 cairo_font_options_set_antialias() and
 cairo_font_options_get_antialias().
<p></p>

 New features may be added to a <span class="d_inlinecode"><a name="cairo_font_options_t"></a><span class="ddoc_psymbol">cairo_font_options_t</span></span> in the
 future.  For this reason, cairo_font_options_copy(),
 cairo_font_options_equal(), cairo_font_options_merge(), and
 cairo_font_options_hash() should be used to copy, check
 for equality, merge, or compute a hash value of
 <span class="d_inlinecode"><a name="cairo_font_options_t"></a><span class="ddoc_psymbol">cairo_font_options_t</span></span> objects.<p></p>

</dd>
<dt class="d_decl">cairo_font_options_t* <a name="cairo_font_options_create"></a><span class="ddoc_psymbol">cairo_font_options_create</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_font_options_t* <a name="cairo_font_options_copy"></a><span class="ddoc_psymbol">cairo_font_options_copy</span>(const cairo_font_options_t* <i>original</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_font_options_destroy"></a><span class="ddoc_psymbol">cairo_font_options_destroy</span>(cairo_font_options_t* <i>options</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_font_options_status"></a><span class="ddoc_psymbol">cairo_font_options_status</span>(cairo_font_options_t* <i>options</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_font_options_merge"></a><span class="ddoc_psymbol">cairo_font_options_merge</span>(cairo_font_options_t* <i>options</i>, const cairo_font_options_t* <i>other</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_bool_t <a name="cairo_font_options_equal"></a><span class="ddoc_psymbol">cairo_font_options_equal</span>(const cairo_font_options_t* <i>options</i>, const cairo_font_options_t* <i>other</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">ulong <a name="cairo_font_options_hash"></a><span class="ddoc_psymbol">cairo_font_options_hash</span>(const cairo_font_options_t* <i>options</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_font_options_set_antialias"></a><span class="ddoc_psymbol">cairo_font_options_set_antialias</span>(cairo_font_options_t* <i>options</i>, cairo_antialias_t <i>antialias</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_antialias_t <a name="cairo_font_options_get_antialias"></a><span class="ddoc_psymbol">cairo_font_options_get_antialias</span>(const cairo_font_options_t* <i>options</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_font_options_set_subpixel_order"></a><span class="ddoc_psymbol">cairo_font_options_set_subpixel_order</span>(cairo_font_options_t* <i>options</i>, cairo_subpixel_order_t <i>subpixel_order</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_subpixel_order_t <a name="cairo_font_options_get_subpixel_order"></a><span class="ddoc_psymbol">cairo_font_options_get_subpixel_order</span>(const cairo_font_options_t* <i>options</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_font_options_set_hint_style"></a><span class="ddoc_psymbol">cairo_font_options_set_hint_style</span>(cairo_font_options_t* <i>options</i>, cairo_hint_style_t <i>hint_style</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_hint_style_t <a name="cairo_font_options_get_hint_style"></a><span class="ddoc_psymbol">cairo_font_options_get_hint_style</span>(const cairo_font_options_t* <i>options</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_font_options_set_hint_metrics"></a><span class="ddoc_psymbol">cairo_font_options_set_hint_metrics</span>(cairo_font_options_t* <i>options</i>, cairo_hint_metrics_t <i>hint_metrics</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_hint_metrics_t <a name="cairo_font_options_get_hint_metrics"></a><span class="ddoc_psymbol">cairo_font_options_get_hint_metrics</span>(const cairo_font_options_t* <i>options</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_select_font_face"></a><span class="ddoc_psymbol">cairo_select_font_face</span>(cairo_t* <i>cr</i>, const char* <i>family</i>, cairo_font_slant_t <i>slant</i>, cairo_font_weight_t <i>weight</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_set_font_size"></a><span class="ddoc_psymbol">cairo_set_font_size</span>(cairo_t* <i>cr</i>, double <i>size</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_set_font_matrix"></a><span class="ddoc_psymbol">cairo_set_font_matrix</span>(cairo_t* <i>cr</i>, const cairo_matrix_t* <i>matrix</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_get_font_matrix"></a><span class="ddoc_psymbol">cairo_get_font_matrix</span>(cairo_t* <i>cr</i>, cairo_matrix_t* <i>matrix</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_set_font_options"></a><span class="ddoc_psymbol">cairo_set_font_options</span>(cairo_t* <i>cr</i>, const cairo_font_options_t* <i>options</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_get_font_options"></a><span class="ddoc_psymbol">cairo_get_font_options</span>(cairo_t* <i>cr</i>, cairo_font_options_t* <i>options</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_set_font_face"></a><span class="ddoc_psymbol">cairo_set_font_face</span>(cairo_t* <i>cr</i>, cairo_font_face_t* <i>font_face</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_font_face_t* <a name="cairo_get_font_face"></a><span class="ddoc_psymbol">cairo_get_font_face</span>(cairo_t* <i>cr</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_set_scaled_font"></a><span class="ddoc_psymbol">cairo_set_scaled_font</span>(cairo_t* <i>cr</i>, const cairo_scaled_font_t* <i>scaled_font</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_scaled_font_t* <a name="cairo_get_scaled_font"></a><span class="ddoc_psymbol">cairo_get_scaled_font</span>(cairo_t* <i>cr</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_show_text"></a><span class="ddoc_psymbol">cairo_show_text</span>(cairo_t* <i>cr</i>, const char* <i>utf8</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_show_glyphs"></a><span class="ddoc_psymbol">cairo_show_glyphs</span>(cairo_t* <i>cr</i>, const cairo_glyph_t* <i>glyphs</i>, int <i>num_glyphs</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_show_text_glyphs"></a><span class="ddoc_psymbol">cairo_show_text_glyphs</span>(cairo_t* <i>cr</i>, const char* <i>utf8</i>, int <i>utf8_len</i>, const cairo_glyph_t* <i>glyphs</i>, int <i>num_glyphs</i>, const cairo_text_cluster_t* <i>clusters</i>, int <i>num_clusters</i>, cairo_text_cluster_flags_t <i>cluster_flags</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_text_path"></a><span class="ddoc_psymbol">cairo_text_path</span>(cairo_t* <i>cr</i>, const char* <i>utf8</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_glyph_path"></a><span class="ddoc_psymbol">cairo_glyph_path</span>(cairo_t* <i>cr</i>, const cairo_glyph_t* <i>glyphs</i>, int <i>num_glyphs</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_text_extents"></a><span class="ddoc_psymbol">cairo_text_extents</span>(cairo_t* <i>cr</i>, const char* <i>utf8</i>, cairo_text_extents_t* <i>extents</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_glyph_extents"></a><span class="ddoc_psymbol">cairo_glyph_extents</span>(cairo_t* <i>cr</i>, const cairo_glyph_t* <i>glyphs</i>, int <i>num_glyphs</i>, cairo_text_extents_t* <i>extents</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_font_extents"></a><span class="ddoc_psymbol">cairo_font_extents</span>(cairo_t* <i>cr</i>, cairo_font_extents_t* <i>extents</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_font_face_t* <a name="cairo_font_face_reference"></a><span class="ddoc_psymbol">cairo_font_face_reference</span>(cairo_font_face_t* <i>font_face</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_font_face_destroy"></a><span class="ddoc_psymbol">cairo_font_face_destroy</span>(cairo_font_face_t* <i>font_face</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">uint <a name="cairo_font_face_get_reference_count"></a><span class="ddoc_psymbol">cairo_font_face_get_reference_count</span>(cairo_font_face_t* <i>font_face</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_font_face_status"></a><span class="ddoc_psymbol">cairo_font_face_status</span>(cairo_font_face_t* <i>font_face</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">enum <a name="cairo_font_type_t"></a><span class="ddoc_psymbol">cairo_font_type_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_font_type_t"></a><span class="ddoc_psymbol">cairo_font_type_t</span></span> is used to describe the type of a given font
 face or scaled font. The font types are also known as "font
 backends" within cairo.
<p></p>
The type of a font face is determined by the function used to
 create it, which will generally be of the form
 cairo_<b>type</b>font_face_create(). The font face type can be queried
 with cairo_font_face_get_type()
<p></p>

 The various <span class="d_inlinecode">cairo_font_face_t</span> functions can be used with a font face
 of any type.
<p></p>

 The type of a scaled font is determined by the type of the font
 face passed to cairo_scaled_font_create(). The scaled font type can
 be queried with cairo_scaled_font_get_type()
<p></p>

 The various <span class="d_inlinecode">cairo_scaled_font_t functions</span> can be used with scaled
 fonts of any type, but some font backends also provide
 type-specific functions that must only be called with a scaled font
 of the appropriate type. These functions have names that begin with
 cairo_<b>type</b>scaled_font() such as cairo_ft_scaled_font_lock_face().
<p></p>

 The behavior of calling a type-specific function with a scaled font
 of the wrong type is undefined.
<p></p>

 New entries may be added in future versions.

<p></p>
<b>Since:</b><br>
1.2<p></p>

<dl><dt class="d_decl"><a name="CAIRO_FONT_TYPE_TOY"></a><span class="ddoc_psymbol">CAIRO_FONT_TYPE_TOY</span></dt>
<dd>The font was created using cairo's toy font api<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FONT_TYPE_FT"></a><span class="ddoc_psymbol">CAIRO_FONT_TYPE_FT</span></dt>
<dd>The font is of type FreeType<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FONT_TYPE_WIN32"></a><span class="ddoc_psymbol">CAIRO_FONT_TYPE_WIN32</span></dt>
<dd>The font is of type Win32<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FONT_TYPE_QUARTZ"></a><span class="ddoc_psymbol">CAIRO_FONT_TYPE_QUARTZ</span></dt>
<dd>The font is of type Quartz (Since: 1.6)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FONT_TYPE_USER"></a><span class="ddoc_psymbol">CAIRO_FONT_TYPE_USER</span></dt>
<dd>The font was create using cairo's user font api (Since: 1.8)<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">cairo_font_type_t <a name="cairo_font_face_get_type"></a><span class="ddoc_psymbol">cairo_font_face_get_type</span>(cairo_font_face_t* <i>font_face</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void* <a name="cairo_font_face_get_user_data"></a><span class="ddoc_psymbol">cairo_font_face_get_user_data</span>(cairo_font_face_t* <i>font_face</i>, const cairo_user_data_key_t* <i>key</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_font_face_set_user_data"></a><span class="ddoc_psymbol">cairo_font_face_set_user_data</span>(cairo_font_face_t* <i>font_face</i>, const cairo_user_data_key_t* <i>key</i>, void* <i>user_data</i>, cairo_destroy_func_t <i>destroy</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_scaled_font_t* <a name="cairo_scaled_font_create"></a><span class="ddoc_psymbol">cairo_scaled_font_create</span>(cairo_font_face_t* <i>font_face</i>, const cairo_matrix_t* <i>font_matrix</i>, const cairo_matrix_t* <i>ctm</i>, const cairo_font_options_t* <i>options</i>);
<br>cairo_scaled_font_t* <a name="cairo_scaled_font_reference"></a><span class="ddoc_psymbol">cairo_scaled_font_reference</span>(cairo_scaled_font_t* <i>scaled_font</i>);
<br>void <a name="cairo_scaled_font_destroy"></a><span class="ddoc_psymbol">cairo_scaled_font_destroy</span>(cairo_scaled_font_t* <i>scaled_font</i>);
<br>uint <a name="cairo_scaled_font_get_reference_count"></a><span class="ddoc_psymbol">cairo_scaled_font_get_reference_count</span>(cairo_scaled_font_t* <i>scaled_font</i>);
<br>cairo_status_t <a name="cairo_scaled_font_status"></a><span class="ddoc_psymbol">cairo_scaled_font_status</span>(cairo_scaled_font_t* <i>scaled_font</i>);
<br>cairo_font_type_t <a name="cairo_scaled_font_get_type"></a><span class="ddoc_psymbol">cairo_scaled_font_get_type</span>(cairo_scaled_font_t* <i>scaled_font</i>);
<br>void* <a name="cairo_scaled_font_get_user_data"></a><span class="ddoc_psymbol">cairo_scaled_font_get_user_data</span>(cairo_scaled_font_t* <i>scaled_font</i>, const cairo_user_data_key_t* <i>key</i>);
<br>cairo_status_t <a name="cairo_scaled_font_set_user_data"></a><span class="ddoc_psymbol">cairo_scaled_font_set_user_data</span>(cairo_scaled_font_t* <i>scaled_font</i>, const cairo_user_data_key_t* <i>key</i>, void* <i>user_data</i>, cairo_destroy_func_t <i>destroy</i>);
<br>void <a name="cairo_scaled_font_extents"></a><span class="ddoc_psymbol">cairo_scaled_font_extents</span>(cairo_scaled_font_t* <i>scaled_font</i>, cairo_font_extents_t* <i>extents</i>);
<br>void <a name="cairo_scaled_font_text_extents"></a><span class="ddoc_psymbol">cairo_scaled_font_text_extents</span>(cairo_scaled_font_t* <i>scaled_font</i>, const char* <i>utf8</i>, cairo_text_extents_t* <i>extents</i>);
<br>void <a name="cairo_scaled_font_glyph_extents"></a><span class="ddoc_psymbol">cairo_scaled_font_glyph_extents</span>(cairo_scaled_font_t* <i>scaled_font</i>, const cairo_glyph_t* <i>glyphs</i>, int <i>num_glyphs</i>, cairo_text_extents_t* <i>extents</i>);
<br>cairo_status_t <a name="cairo_scaled_font_text_to_glyphs"></a><span class="ddoc_psymbol">cairo_scaled_font_text_to_glyphs</span>(cairo_scaled_font_t* <i>scaled_font</i>, double <i>x</i>, double <i>y</i>, const char* <i>utf8</i>, int <i>utf8_len</i>, cairo_glyph_t** <i>glyphs</i>, int* <i>num_glyphs</i>, cairo_text_cluster_t** <i>clusters</i>, int* <i>num_clusters</i>, cairo_text_cluster_flags_t* <i>cluster_flags</i>);
<br>cairo_font_face_t* <a name="cairo_scaled_font_get_font_face"></a><span class="ddoc_psymbol">cairo_scaled_font_get_font_face</span>(cairo_scaled_font_t* <i>scaled_font</i>);
<br>void <a name="cairo_scaled_font_get_font_matrix"></a><span class="ddoc_psymbol">cairo_scaled_font_get_font_matrix</span>(cairo_scaled_font_t* <i>scaled_font</i>, cairo_matrix_t* <i>font_matrix</i>);
<br>void <a name="cairo_scaled_font_get_ctm"></a><span class="ddoc_psymbol">cairo_scaled_font_get_ctm</span>(cairo_scaled_font_t* <i>scaled_font</i>, cairo_matrix_t* <i>ctm</i>);
<br>void <a name="cairo_scaled_font_get_scale_matrix"></a><span class="ddoc_psymbol">cairo_scaled_font_get_scale_matrix</span>(cairo_scaled_font_t* <i>scaled_font</i>, cairo_matrix_t* <i>scale_matrix</i>);
<br>void <a name="cairo_scaled_font_get_font_options"></a><span class="ddoc_psymbol">cairo_scaled_font_get_font_options</span>(cairo_scaled_font_t* <i>scaled_font</i>, cairo_font_options_t* <i>options</i>);
</dt>
<dd>Portable interface to general font features. <p></p>

</dd>
<dt class="d_decl">cairo_font_face_t* <a name="cairo_toy_font_face_create"></a><span class="ddoc_psymbol">cairo_toy_font_face_create</span>(const char* <i>family</i>, cairo_font_slant_t <i>slant</i>, cairo_font_weight_t <i>weight</i>);
<br>const(char)* <a name="cairo_toy_font_face_get_family"></a><span class="ddoc_psymbol">cairo_toy_font_face_get_family</span>(cairo_font_face_t* <i>font_face</i>);
<br>cairo_font_slant_t <a name="cairo_toy_font_face_get_slant"></a><span class="ddoc_psymbol">cairo_toy_font_face_get_slant</span>(cairo_font_face_t* <i>font_face</i>);
<br>cairo_font_weight_t <a name="cairo_toy_font_face_get_weight"></a><span class="ddoc_psymbol">cairo_toy_font_face_get_weight</span>(cairo_font_face_t* <i>font_face</i>);
</dt>
<dd>Toy fonts <p></p>

</dd>
<dt class="d_decl">cairo_font_face_t* <a name="cairo_user_font_face_create"></a><span class="ddoc_psymbol">cairo_user_font_face_create</span>();
</dt>
<dd>User fonts <p></p>

</dd>
<dt class="d_decl">alias <a name="cairo_user_scaled_font_init_func_t"></a><span class="ddoc_psymbol">cairo_user_scaled_font_init_func_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_user_scaled_font_init_func_t"></a><span class="ddoc_psymbol">cairo_user_scaled_font_init_func_t</span></span> is the type of function which is
 called when a scaled-font needs to be created for a user font-face.
<p></p>
The cairo context <span class="d_inlinecode">cr</span> is not used by the caller, but is prepared in font
 space, similar to what the cairo contexts passed to the render_glyph
 method will look like.  The callback can use this context for extents
 computation for example.  After the callback is called, <span class="d_inlinecode">cr</span> is checked
 for any error status.
<p></p>

 The <span class="d_inlinecode">extents</span> argument is where the user font sets the font extents for
 <span class="d_inlinecode">scaled_font</span>.  It is in font space, which means that for most cases its
 ascent and descent members should add to 1.0.  <span class="d_inlinecode">extents</span> is preset to
 hold a value of 1.0 for ascent, height, and max_x_advance, and 0.0 for
 descent and max_y_advance members.
<p></p>

 The callback is optional.  If not set, default font extents as described
 in the previous paragraph will be used.
<p></p>

 Note that <span class="d_inlinecode">scaled_font</span> is not fully initialized at this
 point and trying to use it for text operations in the callback will result
 in deadlock.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>scaled_font</td>
<td valign=top>the scaled-font being created</td></tr>
<tr><td valign=top>cr</td>
<td valign=top>a cairo context, in font space</td></tr>
<tr><td valign=top>extents</td>
<td valign=top>font extents to fill in, in font space</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode">CAIRO_STATUS_SUCCESS</span> upon success, or an error status on error.

<p></p>
<b>Since:</b><br>
1.8<p></p>

</dd>
<dt class="d_decl">alias <a name="cairo_user_scaled_font_render_glyph_func_t"></a><span class="ddoc_psymbol">cairo_user_scaled_font_render_glyph_func_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_user_scaled_font_render_glyph_func_t"></a><span class="ddoc_psymbol">cairo_user_scaled_font_render_glyph_func_t</span></span> is the type of function which
 is called when a user scaled-font needs to render a glyph.
<p></p>
The callback is mandatory, and expected to draw the glyph with code <span class="d_inlinecode">glyph</span> to
 the cairo context <span class="d_inlinecode">cr</span>.  <span class="d_inlinecode">cr</span> is prepared such that the glyph drawing is done in
 font space.  That is, the matrix set on <span class="d_inlinecode">cr</span> is the scale matrix of <span class="d_inlinecode">scaled_font</span>,
 The <span class="d_inlinecode">extents</span> argument is where the user font sets the font extents for
 <span class="d_inlinecode">scaled_font</span>.  However, if user prefers to draw in user space, they can
 achieve that by changing the matrix on <span class="d_inlinecode">cr</span>.  All cairo rendering operations
 to <span class="d_inlinecode">cr</span> are permitted, however, the result is undefined if any source other
 than the default source on <span class="d_inlinecode">cr</span> is used.  That means, glyph bitmaps should
 be rendered using cairo_mask() instead of cairo_paint().
<p></p>

 Other non-default settings on <span class="d_inlinecode">cr</span> include a font size of 1.0 (given that
 it is set up to be in font space), and font options corresponding to
 <span class="d_inlinecode">scaled_font</span>.
<p></p>

 The <span class="d_inlinecode">extents</span> argument is preset to have <span class="d_inlinecode">x_bearing</span>,
 <span class="d_inlinecode">width</span>, and <span class="d_inlinecode">y_advance</span> of zero,
 <span class="d_inlinecode">y_bearing</span> set to <span class="d_inlinecode">-font_extents.ascent</span>,
 <span class="d_inlinecode">height</span> to <span class="d_inlinecode">font_extents.ascent+font_extents.descent</span>,
 and <span class="d_inlinecode">x_advance</span> to <span class="d_inlinecode">font_extents.max_x_advance</span>.
 The only field user needs to set in majority of cases is
 <span class="d_inlinecode">x_advance</span>.
 If the <span class="d_inlinecode">width</span> field is zero upon the callback returning
 (which is its preset value), the glyph extents are automatically computed
 based on the drawings done to <span class="d_inlinecode">cr</span>.  This is in most cases exactly what the
 desired behavior is.  However, if for any reason the callback sets the
 extents, it must be ink extents, and include the extents of all drawing
 done to <span class="d_inlinecode">cr</span> in the callback.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>scaled_font</td>
<td valign=top>user scaled-font</td></tr>
<tr><td valign=top>glyph</td>
<td valign=top>glyph code to render</td></tr>
<tr><td valign=top>cr</td>
<td valign=top>cairo context to draw to, in font space</td></tr>
<tr><td valign=top>extents</td>
<td valign=top>glyph extents to fill in, in font space</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode">CAIRO_STATUS_SUCCESS</span> upon success, or
 <span class="d_inlinecode">CAIRO_STATUS_USER_FONT_ERROR</span> or any other error status on error.

<p></p>
<b>Since:</b><br>
1.8<p></p>

</dd>
<dt class="d_decl">alias <a name="cairo_user_scaled_font_text_to_glyphs_func_t"></a><span class="ddoc_psymbol">cairo_user_scaled_font_text_to_glyphs_func_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_user_scaled_font_text_to_glyphs_func_t"></a><span class="ddoc_psymbol">cairo_user_scaled_font_text_to_glyphs_func_t</span></span> is the type of function which
 is called to convert input text to an array of glyphs.  This is used by the
 cairo_show_text() operation.
<p></p>
Using this callback the user-font has full control on glyphs and their
 positions.  That means, it allows for features like ligatures and kerning,
 as well as complex <i>shaping</i> required for scripts like
 Arabic and Indic.
<p></p>

 The <span class="d_inlinecode">num_glyphs</span> argument is preset to the number of glyph entries available
 in the <span class="d_inlinecode">glyphs</span> buffer. If the <span class="d_inlinecode">glyphs</span> buffer is <span class="d_inlinecode">NULL</span>, the value of
 <span class="d_inlinecode">num_glyphs</span> will be zero.  If the provided glyph array is too short for
 the conversion (or for convenience), a new glyph array may be allocated
 using cairo_glyph_allocate() and placed in <span class="d_inlinecode">glyphs</span>.  Upon return,
 <span class="d_inlinecode">num_glyphs</span> should contain the number of generated glyphs.  If the value
 <span class="d_inlinecode">glyphs</span> points at has changed after the call, the caller will free the
 allocated glyph array using cairo_glyph_free().
 The callback should populate the glyph indices and positions (in font space)
 assuming that the text is to be shown at the origin.
<p></p>

 If <span class="d_inlinecode">clusters</span> is not <span class="d_inlinecode">NULL</span>, <span class="d_inlinecode">num_clusters</span> and <span class="d_inlinecode">cluster_flags</span> are also
 non-<span class="d_inlinecode">NULL</span>, and cluster mapping should be computed. The semantics of how
 cluster array allocation works is similar to the glyph array.  That is,
 if <span class="d_inlinecode">clusters</span> initially points to a non-<span class="d_inlinecode">NULL</span> value, that array may be used
 as a cluster buffer, and <span class="d_inlinecode">num_clusters</span> points to the number of cluster
 entries available there.  If the provided cluster array is too short for
 the conversion (or for convenience), a new cluster array may be allocated
 using cairo_text_cluster_allocate() and placed in <span class="d_inlinecode">clusters</span>.  Upon return,
 <span class="d_inlinecode">num_clusters</span> should contain the number of generated clusters.
 If the value <span class="d_inlinecode">clusters</span> points at has changed after the call, the caller
 will free the allocated cluster array using cairo_text_cluster_free().
<p></p>

 The callback is optional.  If <span class="d_inlinecode">num_glyphs</span> is negative upon
 the callback returning or if the return value
 is <span class="d_inlinecode">CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED</span>, the unicode_to_glyph callback
 is tried.  See <span class="d_inlinecode">cairo_user_scaled_font_unicode_to_glyph_func_t</span>.

<p></p>
<b>Note:</b><br>
While cairo does not impose any limitation on glyph indices,
 some applications may assume that a glyph index fits in a 16-bit
 unsigned integer.  As such, it is advised that user-fonts keep their
 glyphs in the 0 to 65535 range.  Furthermore, some applications may
 assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
 are advised to use glyph 0 for such purposes and do not use that
 glyph value for other purposes.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>scaled_font</td>
<td valign=top>the scaled-font being created</td></tr>
<tr><td valign=top>utf8</td>
<td valign=top>a string of text encoded in UTF-8</td></tr>
<tr><td valign=top>utf8_len</td>
<td valign=top>length of @utf8 in bytes</td></tr>
<tr><td valign=top>glyphs</td>
<td valign=top>pointer to array of glyphs to fill, in font space</td></tr>
<tr><td valign=top>num_glyphs</td>
<td valign=top>pointer to number of glyphs</td></tr>
<tr><td valign=top>clusters</td>
<td valign=top>pointer to array of cluster mapping information to fill, or %NULL</td></tr>
<tr><td valign=top>num_clusters</td>
<td valign=top>pointer to number of clusters</td></tr>
<tr><td valign=top>cluster_flags</td>
<td valign=top>pointer to location to store cluster flags corresponding to the
                 output @clusters</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode">CAIRO_STATUS_SUCCESS</span> upon success,
 <span class="d_inlinecode">CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED</span> if fallback options should be tried,
 or <span class="d_inlinecode">CAIRO_STATUS_USER_FONT_ERROR</span> or any other error status on error.

<p></p>
<b>Since:</b><br>
1.8<p></p>

</dd>
<dt class="d_decl">alias <a name="cairo_user_scaled_font_unicode_to_glyph_func_t"></a><span class="ddoc_psymbol">cairo_user_scaled_font_unicode_to_glyph_func_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_user_scaled_font_unicode_to_glyph_func_t"></a><span class="ddoc_psymbol">cairo_user_scaled_font_unicode_to_glyph_func_t</span></span> is the type of function which
 is called to convert an input Unicode character to a single glyph.
 This is used by the cairo_show_text() operation.
<p></p>
This callback is used to provide the same functionality as the
 text_to_glyphs callback does (see <span class="d_inlinecode">cairo_user_scaled_font_text_to_glyphs_func_t</span>)
 but has much less control on the output,
 in exchange for increased ease of use.  The inherent assumption to using
 this callback is that each character maps to one glyph, and that the
 mapping is context independent.  It also assumes that glyphs are positioned
 according to their advance width.  These mean no ligatures, kerning, or
 complex scripts can be implemented using this callback.
<p></p>

 The callback is optional, and only used if text_to_glyphs callback is not
 set or fails to return glyphs.  If this callback is not set or if it returns
 <span class="d_inlinecode">CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED</span>, an identity mapping from Unicode
 code-points to glyph indices is assumed.

<p></p>
<b>Note:</b><br>
While cairo does not impose any limitation on glyph indices,
 some applications may assume that a glyph index fits in a 16-bit
 unsigned integer.  As such, it is advised that user-fonts keep their
 glyphs in the 0 to 65535 range.  Furthermore, some applications may
 assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
 are advised to use glyph 0 for such purposes and do not use that
 glyph value for other purposes.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>scaled_font</td>
<td valign=top>the scaled-font being created</td></tr>
<tr><td valign=top>unicode</td>
<td valign=top>input unicode character code-point</td></tr>
<tr><td valign=top>glyph_index</td>
<td valign=top>output glyph index</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode">CAIRO_STATUS_SUCCESS</span> upon success,
 <span class="d_inlinecode">CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED</span> if fallback options should be tried,
 or <span class="d_inlinecode">CAIRO_STATUS_USER_FONT_ERROR</span> or any other error status on error.

<p></p>
<b>Since:</b><br>
1.8<p></p>

</dd>
<dt class="d_decl">void <a name="cairo_user_font_face_set_init_func"></a><span class="ddoc_psymbol">cairo_user_font_face_set_init_func</span>(cairo_font_face_t* <i>font_face</i>, cairo_user_scaled_font_init_func_t <i>init_func</i>);
<br>void <a name="cairo_user_font_face_set_render_glyph_func"></a><span class="ddoc_psymbol">cairo_user_font_face_set_render_glyph_func</span>(cairo_font_face_t* <i>font_face</i>, cairo_user_scaled_font_render_glyph_func_t <i>render_glyph_func</i>);
<br>void <a name="cairo_user_font_face_set_text_to_glyphs_func"></a><span class="ddoc_psymbol">cairo_user_font_face_set_text_to_glyphs_func</span>(cairo_font_face_t* <i>font_face</i>, cairo_user_scaled_font_text_to_glyphs_func_t <i>text_to_glyphs_func</i>);
<br>void <a name="cairo_user_font_face_set_unicode_to_glyph_func"></a><span class="ddoc_psymbol">cairo_user_font_face_set_unicode_to_glyph_func</span>(cairo_font_face_t* <i>font_face</i>, cairo_user_scaled_font_unicode_to_glyph_func_t <i>unicode_to_glyph_func</i>);
</dt>
<dd>User-font method setters <p></p>

</dd>
<dt class="d_decl">cairo_user_scaled_font_init_func_t <a name="cairo_user_font_face_get_init_func"></a><span class="ddoc_psymbol">cairo_user_font_face_get_init_func</span>(cairo_font_face_t* <i>font_face</i>);
<br>cairo_user_scaled_font_render_glyph_func_t <a name="cairo_user_font_face_get_render_glyph_func"></a><span class="ddoc_psymbol">cairo_user_font_face_get_render_glyph_func</span>(cairo_font_face_t* <i>font_face</i>);
<br>cairo_user_scaled_font_text_to_glyphs_func_t <a name="cairo_user_font_face_get_text_to_glyphs_func"></a><span class="ddoc_psymbol">cairo_user_font_face_get_text_to_glyphs_func</span>(cairo_font_face_t* <i>font_face</i>);
<br>cairo_user_scaled_font_unicode_to_glyph_func_t <a name="cairo_user_font_face_get_unicode_to_glyph_func"></a><span class="ddoc_psymbol">cairo_user_font_face_get_unicode_to_glyph_func</span>(cairo_font_face_t* <i>font_face</i>);
</dt>
<dd>User-font method getters <p></p>

</dd>
<dt class="d_decl">cairo_operator_t <a name="cairo_get_operator"></a><span class="ddoc_psymbol">cairo_get_operator</span>(cairo_t* <i>cr</i>);
<br>cairo_pattern_t* <a name="cairo_get_source"></a><span class="ddoc_psymbol">cairo_get_source</span>(cairo_t* <i>cr</i>);
<br>double <a name="cairo_get_tolerance"></a><span class="ddoc_psymbol">cairo_get_tolerance</span>(cairo_t* <i>cr</i>);
<br>cairo_antialias_t <a name="cairo_get_antialias"></a><span class="ddoc_psymbol">cairo_get_antialias</span>(cairo_t* <i>cr</i>);
<br>cairo_bool_t <a name="cairo_has_current_point"></a><span class="ddoc_psymbol">cairo_has_current_point</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_get_current_point"></a><span class="ddoc_psymbol">cairo_get_current_point</span>(cairo_t* <i>cr</i>, double* <i>x</i>, double* <i>y</i>);
<br>cairo_fill_rule_t <a name="cairo_get_fill_rule"></a><span class="ddoc_psymbol">cairo_get_fill_rule</span>(cairo_t* <i>cr</i>);
<br>double <a name="cairo_get_line_width"></a><span class="ddoc_psymbol">cairo_get_line_width</span>(cairo_t* <i>cr</i>);
<br>cairo_line_cap_t <a name="cairo_get_line_cap"></a><span class="ddoc_psymbol">cairo_get_line_cap</span>(cairo_t* <i>cr</i>);
<br>cairo_line_join_t <a name="cairo_get_line_join"></a><span class="ddoc_psymbol">cairo_get_line_join</span>(cairo_t* <i>cr</i>);
<br>double <a name="cairo_get_miter_limit"></a><span class="ddoc_psymbol">cairo_get_miter_limit</span>(cairo_t* <i>cr</i>);
<br>int <a name="cairo_get_dash_count"></a><span class="ddoc_psymbol">cairo_get_dash_count</span>(cairo_t* <i>cr</i>);
<br>void <a name="cairo_get_dash"></a><span class="ddoc_psymbol">cairo_get_dash</span>(cairo_t* <i>cr</i>, double* <i>dashes</i>, double* <i>offset</i>);
<br>void <a name="cairo_get_matrix"></a><span class="ddoc_psymbol">cairo_get_matrix</span>(cairo_t* <i>cr</i>, cairo_matrix_t* <i>matrix</i>);
<br>cairo_surface_t* <a name="cairo_get_target"></a><span class="ddoc_psymbol">cairo_get_target</span>(cairo_t* <i>cr</i>);
<br>cairo_surface_t* <a name="cairo_get_group_target"></a><span class="ddoc_psymbol">cairo_get_group_target</span>(cairo_t* <i>cr</i>);
</dt>
<dd>Query functions <p></p>

</dd>
<dt class="d_decl">enum <a name="cairo_path_data_type_t"></a><span class="ddoc_psymbol">cairo_path_data_type_t</span>;
</dt>
<dd><span class="d_inlinecode">cairo_path_data_t</span> is used to describe the type of one portion
 of a path when represented as a <span class="d_inlinecode">cairo_path_t</span>.
 See <span class="d_inlinecode">cairo_path_data_t</span> for details.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_PATH_MOVE_TO"></a><span class="ddoc_psymbol">CAIRO_PATH_MOVE_TO</span></dt>
<dd>A move-to operation<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_PATH_LINE_TO"></a><span class="ddoc_psymbol">CAIRO_PATH_LINE_TO</span></dt>
<dd>A line-to operation<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_PATH_CURVE_TO"></a><span class="ddoc_psymbol">CAIRO_PATH_CURVE_TO</span></dt>
<dd>A curve-to operation<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_PATH_CLOSE_PATH"></a><span class="ddoc_psymbol">CAIRO_PATH_CLOSE_PATH</span></dt>
<dd>A close-path operation<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="cairo_path_data_t"></a><span class="ddoc_psymbol">cairo_path_data_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_path_data_t"></a><span class="ddoc_psymbol">cairo_path_data_t</span></span> is used to represent the path data inside a
 <span class="d_inlinecode">cairo_path_t</span>.
<p></p>
The data structure is designed to try to balance the demands of
 efficiency and ease-of-use. A path is represented as an array of
 <span class="d_inlinecode"><a name="cairo_path_data_t"></a><span class="ddoc_psymbol">cairo_path_data_t</span></span>, which is a union of headers and points.
<p></p>

 Each portion of the path is represented by one or more elements in
 the array, (one header followed by 0 or more points). The length
 value of the header is the number of array elements for the current
 portion including the header, (ie. length == 1 + # of points), and
 where the number of points for each element type is as follows:
<p></p>

<pre class="d_code">     <span class="d_inlinecode">CAIRO_PATH_MOVE_TO</span>:     1 point
     <span class="d_inlinecode">CAIRO_PATH_LINE_TO</span>:     1 point
     <span class="d_inlinecode">CAIRO_PATH_CURVE_TO</span>:    3 points
     <span class="d_inlinecode">CAIRO_PATH_CLOSE_PATH</span>:  0 points
</pre>

 The semantics and ordering of the coordinate values are consistent
 with cairo_move_to(), cairo_line_to(), cairo_curve_to(), and
 cairo_close_path().

<p></p>
<b>Examples:</b><br>Here is sample code for iterating through a <span class="d_inlinecode">cairo_path_t</span>:
<p></p>

<pre class="d_code">      <span class="d_keyword">int</span> i;
      cairo_path_t *path;
      <span class="d_psymbol">cairo_path_data_t</span> *data;

      path = cairo_copy_path (cr);

      <span class="d_keyword">for</span> (i=0; i &lt; path-&gt;num_data; i += path-&gt;data[i].header.length) {
          data = &amp;amp;path-&gt;data[i];
          <span class="d_keyword">switch</span> (data-&gt;header.type) {
          <span class="d_keyword">case</span> CAIRO_PATH_MOVE_TO:
              do_move_to_things (data[1].point.x, data[1].point.y);
              <span class="d_keyword">break</span>;
          <span class="d_keyword">case</span> CAIRO_PATH_LINE_TO:
              do_line_to_things (data[1].point.x, data[1].point.y);
              <span class="d_keyword">break</span>;
          <span class="d_keyword">case</span> CAIRO_PATH_CURVE_TO:
              do_curve_to_things (data[1].point.x, data[1].point.y,
                                  data[2].point.x, data[2].point.y,
                                  data[3].point.x, data[3].point.y);
              <span class="d_keyword">break</span>;
          <span class="d_keyword">case</span> CAIRO_PATH_CLOSE_PATH:
              do_close_path_things ();
              <span class="d_keyword">break</span>;
          }
      }
      cairo_path_destroy (path);
</pre>

 As of cairo 1.4, cairo does not mind if there are more elements in
 a portion of the path than needed.  Such elements can be used by
 users of the cairo API to hold extra values in the path data
 structure.  For this reason, it is recommended that applications
 always use <span class="d_inlinecode">data-&gt;header.length</span> to
 iterate over the path data, instead of hardcoding the number of
 elements for each element type.<p></p>

<dl><dt class="d_decl">PathDataHeader <a name="header"></a><span class="ddoc_psymbol">header</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">PathDataPoint <a name="point"></a><span class="ddoc_psymbol">point</span>;
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="PathDataHeader"></a><span class="ddoc_psymbol">PathDataHeader</span>;
</dt>
<dd><p></p>
<dl><dt class="d_decl">cairo_path_data_type_t <a name="type"></a><span class="ddoc_psymbol">type</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="length"></a><span class="ddoc_psymbol">length</span>;
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="PathDataPoint"></a><span class="ddoc_psymbol">PathDataPoint</span>;
</dt>
<dd><p></p>
<dl><dt class="d_decl">double <a name="y"></a><span class="ddoc_psymbol">y</span>;
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="cairo_path_t"></a><span class="ddoc_psymbol">cairo_path_t</span>;
</dt>
<dd>A data structure for holding a path. This data structure serves as
 the return value for cairo_copy_path() and
 cairo_copy_path_flat() as well the input value for
 cairo_append_path().
<p></p>
See <span class="d_inlinecode">cairo_path_data_t</span> for hints on how to iterate over the
 actual data within the path.
<p></p>

 The num_data member gives the number of elements in the data
 array. This number is larger than the number of independent path
 portions (defined in <span class="d_inlinecode">cairo_path_data_type_t</span>), since the data
 includes both headers and coordinates for each portion.<p></p>

<dl><dt class="d_decl">cairo_status_t <a name="status"></a><span class="ddoc_psymbol">status</span>;
</dt>
<dd>the current error <a name="status"></a><span class="ddoc_psymbol">status</span><p></p>

</dd>
<dt class="d_decl">cairo_path_data_t* <a name="data"></a><span class="ddoc_psymbol">data</span>;
</dt>
<dd>the elements in the path<p></p>

</dd>
<dt class="d_decl">int <a name="num_data"></a><span class="ddoc_psymbol">num_data</span>;
</dt>
<dd>the number of elements in the data array<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">cairo_path_t* <a name="cairo_copy_path"></a><span class="ddoc_psymbol">cairo_copy_path</span>(cairo_t* <i>cr</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_path_t* <a name="cairo_copy_path_flat"></a><span class="ddoc_psymbol">cairo_copy_path_flat</span>(cairo_t* <i>cr</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_append_path"></a><span class="ddoc_psymbol">cairo_append_path</span>(cairo_t* <i>cr</i>, const cairo_path_t* <i>path</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_path_destroy"></a><span class="ddoc_psymbol">cairo_path_destroy</span>(cairo_path_t* <i>path</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_status"></a><span class="ddoc_psymbol">cairo_status</span>(cairo_t* <i>cr</i>);
<br>immutable(char)* <a name="cairo_status_to_string"></a><span class="ddoc_psymbol">cairo_status_to_string</span>(cairo_status_t <i>status</i>);
</dt>
<dd>Error status queries <p></p>

</dd>
<dt class="d_decl">cairo_device_t* <a name="cairo_device_reference"></a><span class="ddoc_psymbol">cairo_device_reference</span>(cairo_device_t* <i>device</i>);
</dt>
<dd>Backend <i>device</i> manipulation <p></p>

</dd>
<dt class="d_decl">enum <a name="cairo_device_type_t"></a><span class="ddoc_psymbol">cairo_device_type_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_device_type_t"></a><span class="ddoc_psymbol">cairo_device_type_t</span></span> is used to describe the type of a given
 device. The devices types are also known as "backends" within cairo.
<p></p>
The device type can be queried with cairo_device_get_type()
<p></p>

 The various <span class="d_inlinecode">cairo_device_t</span> functions can be used with surfaces of
 any type, but some backends also provide type-specific functions
 that must only be called with a device of the appropriate
 type. These functions have names that begin with
 cairo_<b>type</b>device<...&gt; such as cairo_xcb_device_debug_set_render_version().
<p></p>

 The behavior of calling a type-specific function with a surface of
 the wrong type is undefined.
<p></p>

 New entries may be added in future versions.

<p></p>
<b>Since:</b><br>
1.10<p></p>

<dl><dt class="d_decl"><a name="CAIRO_DEVICE_TYPE_DRM"></a><span class="ddoc_psymbol">CAIRO_DEVICE_TYPE_DRM</span></dt>
<dd>The surface is of type Direct Render Manager<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_DEVICE_TYPE_GL"></a><span class="ddoc_psymbol">CAIRO_DEVICE_TYPE_GL</span></dt>
<dd>The surface is of type OpenGL<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_DEVICE_TYPE_SCRIPT"></a><span class="ddoc_psymbol">CAIRO_DEVICE_TYPE_SCRIPT</span></dt>
<dd>The surface is of type script<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_DEVICE_TYPE_XCB"></a><span class="ddoc_psymbol">CAIRO_DEVICE_TYPE_XCB</span></dt>
<dd>The surface is of type xcb<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_DEVICE_TYPE_XLIB"></a><span class="ddoc_psymbol">CAIRO_DEVICE_TYPE_XLIB</span></dt>
<dd>The surface is of type xlib<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_DEVICE_TYPE_XML"></a><span class="ddoc_psymbol">CAIRO_DEVICE_TYPE_XML</span></dt>
<dd>The surface is of type XML<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">cairo_device_type_t <a name="cairo_device_get_type"></a><span class="ddoc_psymbol">cairo_device_get_type</span>(cairo_device_t* <i>device</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_device_status"></a><span class="ddoc_psymbol">cairo_device_status</span>(cairo_device_t* <i>device</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_device_acquire"></a><span class="ddoc_psymbol">cairo_device_acquire</span>(cairo_device_t* <i>device</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_device_release"></a><span class="ddoc_psymbol">cairo_device_release</span>(cairo_device_t* <i>device</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_device_flush"></a><span class="ddoc_psymbol">cairo_device_flush</span>(cairo_device_t* <i>device</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_device_finish"></a><span class="ddoc_psymbol">cairo_device_finish</span>(cairo_device_t* <i>device</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_device_destroy"></a><span class="ddoc_psymbol">cairo_device_destroy</span>(cairo_device_t* <i>device</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">uint <a name="cairo_device_get_reference_count"></a><span class="ddoc_psymbol">cairo_device_get_reference_count</span>(cairo_device_t* <i>device</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void* <a name="cairo_device_get_user_data"></a><span class="ddoc_psymbol">cairo_device_get_user_data</span>(cairo_device_t* <i>device</i>, const cairo_user_data_key_t* <i>key</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_device_set_user_data"></a><span class="ddoc_psymbol">cairo_device_set_user_data</span>(cairo_device_t* <i>device</i>, const cairo_user_data_key_t* <i>key</i>, void* <i>user_data</i>, cairo_destroy_func_t <i>destroy</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_surface_t* <a name="cairo_surface_create_similar"></a><span class="ddoc_psymbol">cairo_surface_create_similar</span>(cairo_surface_t* <i>other</i>, cairo_content_t <i>content</i>, int <i>width</i>, int <i>height</i>);
<br>cairo_surface_t* <a name="cairo_surface_create_for_rectangle"></a><span class="ddoc_psymbol">cairo_surface_create_for_rectangle</span>(cairo_surface_t* <i>target</i>, double <i>x</i>, double <i>y</i>, double <i>width</i>, double <i>height</i>);
<br>cairo_surface_t* <a name="cairo_surface_reference"></a><span class="ddoc_psymbol">cairo_surface_reference</span>(cairo_surface_t* <i>surface</i>);
<br>void <a name="cairo_surface_finish"></a><span class="ddoc_psymbol">cairo_surface_finish</span>(cairo_surface_t* <i>surface</i>);
<br>void <a name="cairo_surface_destroy"></a><span class="ddoc_psymbol">cairo_surface_destroy</span>(cairo_surface_t* <i>surface</i>);
<br>cairo_device_t* <a name="cairo_surface_get_device"></a><span class="ddoc_psymbol">cairo_surface_get_device</span>(cairo_surface_t* <i>surface</i>);
<br>uint <a name="cairo_surface_get_reference_count"></a><span class="ddoc_psymbol">cairo_surface_get_reference_count</span>(cairo_surface_t* <i>surface</i>);
<br>cairo_status_t <a name="cairo_surface_status"></a><span class="ddoc_psymbol">cairo_surface_status</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd>Surface manipulation <p></p>

</dd>
<dt class="d_decl">enum <a name="cairo_surface_type_t"></a><span class="ddoc_psymbol">cairo_surface_type_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_surface_type_t"></a><span class="ddoc_psymbol">cairo_surface_type_t</span></span> is used to describe the type of a given
 surface. The surface types are also known as "backends" or "surface
 backends" within cairo.
<p></p>
The type of a surface is determined by the function used to create
 it, which will generally be of the form cairo_<b>type</b>surface_create(),
 (though see cairo_surface_create_similar() as well).
<p></p>

 The surface type can be queried with cairo_surface_get_type()
<p></p>

 The various <span class="d_inlinecode">cairo_surface_t</span> functions can be used with surfaces of
 any type, but some backends also provide type-specific functions
 that must only be called with a surface of the appropriate
 type. These functions have names that begin with
 cairo_<b>type</b>surface<...&gt; such as cairo_image_surface_get_width().
<p></p>

 The behavior of calling a type-specific function with a surface of
 the wrong type is undefined.
<p></p>

 New entries may be added in future versions.

<p></p>
<b>Since:</b><br>
1.2<p></p>

<dl><dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_IMAGE"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_IMAGE</span></dt>
<dd>The surface is of type image<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_PDF"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_PDF</span></dt>
<dd>The surface is of type pdf<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_PS"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_PS</span></dt>
<dd>The surface is of type ps<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_XLIB"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_XLIB</span></dt>
<dd>The surface is of type xlib<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_XCB"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_XCB</span></dt>
<dd>The surface is of type xcb<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_GLITZ"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_GLITZ</span></dt>
<dd>The surface is of type glitz<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_QUARTZ"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_QUARTZ</span></dt>
<dd>The surface is of type quartz<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_WIN32"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_WIN32</span></dt>
<dd>The surface is of type win32<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_BEOS"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_BEOS</span></dt>
<dd>The surface is of type beos<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_DIRECTFB"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_DIRECTFB</span></dt>
<dd>The surface is of type directfb<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_SVG"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_SVG</span></dt>
<dd>The surface is of type svg<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_OS2"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_OS2</span></dt>
<dd>The surface is of type os2<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_WIN32_PRINTING"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_WIN32_PRINTING</span></dt>
<dd>The surface is a win32 printing surface<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_QUARTZ_IMAGE"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_QUARTZ_IMAGE</span></dt>
<dd>The surface is of type quartz_image<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_SCRIPT"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_SCRIPT</span></dt>
<dd>The surface is of type script, since 1.10<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_QT"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_QT</span></dt>
<dd>The surface is of type Qt, since 1.10<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_RECORDING"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_RECORDING</span></dt>
<dd>The surface is of type recording, since 1.10<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_VG"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_VG</span></dt>
<dd>The surface is a OpenVG surface, since 1.10<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_GL"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_GL</span></dt>
<dd>The surface is of type OpenGL, since 1.10<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_DRM"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_DRM</span></dt>
<dd>The surface is of type Direct Render Manager, since 1.10<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_TEE"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_TEE</span></dt>
<dd>The surface is of type 'tee' (a multiplexing surface), since 1.10<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_XML"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_XML</span></dt>
<dd>The surface is of type XML (for debugging), since 1.10<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_SKIA"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_SKIA</span></dt>
<dd>The surface is of type Skia, since 1.10<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_SURFACE_TYPE_SUBSURFACE"></a><span class="ddoc_psymbol">CAIRO_SURFACE_TYPE_SUBSURFACE</span></dt>
<dd>The surface is a subsurface created with
 cairo_surface_create_for_rectangle(), since 1.10<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">cairo_surface_type_t <a name="cairo_surface_get_type"></a><span class="ddoc_psymbol">cairo_surface_get_type</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_content_t <a name="cairo_surface_get_content"></a><span class="ddoc_psymbol">cairo_surface_get_content</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_surface_write_to_png"></a><span class="ddoc_psymbol">cairo_surface_write_to_png</span>(cairo_surface_t* <i>surface</i>, const char* <i>filename</i>);
<br>cairo_status_t <a name="cairo_surface_write_to_png_stream"></a><span class="ddoc_psymbol">cairo_surface_write_to_png_stream</span>(cairo_surface_t* <i>surface</i>, cairo_write_func_t <i>write_func</i>, void* <i>closure</i>);
</dt>
<dd>requires -version=CAIRO_HAS_PNG_FUNCTIONS<p></p>

</dd>
<dt class="d_decl">void* <a name="cairo_surface_get_user_data"></a><span class="ddoc_psymbol">cairo_surface_get_user_data</span>(cairo_surface_t* <i>surface</i>, const cairo_user_data_key_t* <i>key</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_surface_set_user_data"></a><span class="ddoc_psymbol">cairo_surface_set_user_data</span>(cairo_surface_t* <i>surface</i>, const cairo_user_data_key_t* <i>key</i>, void* <i>user_data</i>, cairo_destroy_func_t <i>destroy</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">string <a name="CAIRO_MIME_TYPE_JPEG"></a><span class="ddoc_psymbol">CAIRO_MIME_TYPE_JPEG</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">string <a name="CAIRO_MIME_TYPE_PNG"></a><span class="ddoc_psymbol">CAIRO_MIME_TYPE_PNG</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">string <a name="CAIRO_MIME_TYPE_JP2"></a><span class="ddoc_psymbol">CAIRO_MIME_TYPE_JP2</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">string <a name="CAIRO_MIME_TYPE_URI"></a><span class="ddoc_psymbol">CAIRO_MIME_TYPE_URI</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_surface_get_mime_data"></a><span class="ddoc_psymbol">cairo_surface_get_mime_data</span>(cairo_surface_t* <i>surface</i>, const char* <i>mime_type</i>, const ubyte** <i>data</i>, ulong* <i>length</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_surface_set_mime_data"></a><span class="ddoc_psymbol">cairo_surface_set_mime_data</span>(cairo_surface_t* <i>surface</i>, const char* <i>mime_type</i>, const ubyte* <i>data</i>, ulong <i>length</i>, cairo_destroy_func_t <i>destroy</i>, void* <i>closure</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_surface_get_font_options"></a><span class="ddoc_psymbol">cairo_surface_get_font_options</span>(cairo_surface_t* <i>surface</i>, cairo_font_options_t* <i>options</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_surface_flush"></a><span class="ddoc_psymbol">cairo_surface_flush</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_surface_mark_dirty"></a><span class="ddoc_psymbol">cairo_surface_mark_dirty</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_surface_mark_dirty_rectangle"></a><span class="ddoc_psymbol">cairo_surface_mark_dirty_rectangle</span>(cairo_surface_t* <i>surface</i>, int <i>x</i>, int <i>y</i>, int <i>width</i>, int <i>height</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_surface_set_device_offset"></a><span class="ddoc_psymbol">cairo_surface_set_device_offset</span>(cairo_surface_t* <i>surface</i>, double <i>x_offset</i>, double <i>y_offset</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_surface_get_device_offset"></a><span class="ddoc_psymbol">cairo_surface_get_device_offset</span>(cairo_surface_t* <i>surface</i>, double* <i>x_offset</i>, double* <i>y_offset</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_surface_set_fallback_resolution"></a><span class="ddoc_psymbol">cairo_surface_set_fallback_resolution</span>(cairo_surface_t* <i>surface</i>, double <i>x_pixels_per_inch</i>, double <i>y_pixels_per_inch</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_surface_get_fallback_resolution"></a><span class="ddoc_psymbol">cairo_surface_get_fallback_resolution</span>(cairo_surface_t* <i>surface</i>, double* <i>x_pixels_per_inch</i>, double* <i>y_pixels_per_inch</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_surface_copy_page"></a><span class="ddoc_psymbol">cairo_surface_copy_page</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_surface_show_page"></a><span class="ddoc_psymbol">cairo_surface_show_page</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_bool_t <a name="cairo_surface_has_show_text_glyphs"></a><span class="ddoc_psymbol">cairo_surface_has_show_text_glyphs</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">enum <a name="cairo_format_t"></a><span class="ddoc_psymbol">cairo_format_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_format_t"></a><span class="ddoc_psymbol">cairo_format_t</span></span> is used to identify the memory format of
 image data.
<p></p>
New entries may be added in future versions.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_FORMAT_INVALID"></a><span class="ddoc_psymbol">CAIRO_FORMAT_INVALID</span></dt>
<dd>no such format exists or is supported.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FORMAT_ARGB32"></a><span class="ddoc_psymbol">CAIRO_FORMAT_ARGB32</span></dt>
<dd>each pixel is a 32-bit quantity, with
 alpha in the upper 8 bits, then red, then green, then blue.
 The 32-bit quantities are stored native-endian. Pre-multiplied
 alpha is used. (That is, 50% transparent red is 0x80800000,
 not 0x80ff0000.)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FORMAT_RGB24"></a><span class="ddoc_psymbol">CAIRO_FORMAT_RGB24</span></dt>
<dd>each pixel is a 32-bit quantity, with
 the upper 8 bits unused. Red, Green, and Blue are stored
 in the remaining 24 bits in that order.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FORMAT_A8"></a><span class="ddoc_psymbol">CAIRO_FORMAT_A8</span></dt>
<dd>each pixel is a 8-bit quantity holding
 an alpha value.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FORMAT_A1"></a><span class="ddoc_psymbol">CAIRO_FORMAT_A1</span></dt>
<dd>each pixel is a 1-bit quantity holding
 an alpha value. Pixels are packed together into 32-bit
 quantities. The ordering of the bits matches the
 endianess of the platform. On a big-endian machine, the
 first pixel is in the uppermost bit, on a little-endian
 machine the first pixel is in the least-significant bit.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FORMAT_RGB16_565"></a><span class="ddoc_psymbol">CAIRO_FORMAT_RGB16_565</span></dt>
<dd>each pixel is a 16-bit quantity
 with red in the upper 5 bits, then green in the middle
 6 bits, and blue in the lower 5 bits.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">cairo_surface_t* <a name="cairo_image_surface_create"></a><span class="ddoc_psymbol">cairo_image_surface_create</span>(cairo_format_t <i>format</i>, int <i>width</i>, int <i>height</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="cairo_format_stride_for_width"></a><span class="ddoc_psymbol">cairo_format_stride_for_width</span>(cairo_format_t <i>format</i>, int <i>width</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_surface_t* <a name="cairo_image_surface_create_for_data"></a><span class="ddoc_psymbol">cairo_image_surface_create_for_data</span>(ubyte* <i>data</i>, cairo_format_t <i>format</i>, int <i>width</i>, int <i>height</i>, int <i>stride</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">ubyte* <a name="cairo_image_surface_get_data"></a><span class="ddoc_psymbol">cairo_image_surface_get_data</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_format_t <a name="cairo_image_surface_get_format"></a><span class="ddoc_psymbol">cairo_image_surface_get_format</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="cairo_image_surface_get_width"></a><span class="ddoc_psymbol">cairo_image_surface_get_width</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="cairo_image_surface_get_height"></a><span class="ddoc_psymbol">cairo_image_surface_get_height</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="cairo_image_surface_get_stride"></a><span class="ddoc_psymbol">cairo_image_surface_get_stride</span>(cairo_surface_t* <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_surface_t* <a name="cairo_image_surface_create_from_png"></a><span class="ddoc_psymbol">cairo_image_surface_create_from_png</span>(const char* <i>filename</i>);
<br>cairo_surface_t* <a name="cairo_image_surface_create_from_png_stream"></a><span class="ddoc_psymbol">cairo_image_surface_create_from_png_stream</span>(cairo_read_func_t <i>read_func</i>, void* <i>closure</i>);
</dt>
<dd>requires -version=CAIRO_HAS_PNG_FUNCTIONS<p></p>

</dd>
<dt class="d_decl">cairo_surface_t* <a name="cairo_recording_surface_create"></a><span class="ddoc_psymbol">cairo_recording_surface_create</span>(cairo_content_t <i>content</i>, const cairo_rectangle_t* <i>extents</i>);
<br>void <a name="cairo_recording_surface_ink_extents"></a><span class="ddoc_psymbol">cairo_recording_surface_ink_extents</span>(cairo_surface_t* <i>surface</i>, double* <i>x0</i>, double* <i>y0</i>, double* <i>width</i>, double* <i>height</i>);
</dt>
<dd>Recording-surface functions <p></p>

</dd>
<dt class="d_decl">cairo_pattern_t* <a name="cairo_pattern_create_rgb"></a><span class="ddoc_psymbol">cairo_pattern_create_rgb</span>(double <i>red</i>, double <i>green</i>, double <i>blue</i>);
<br>cairo_pattern_t* <a name="cairo_pattern_create_rgba"></a><span class="ddoc_psymbol">cairo_pattern_create_rgba</span>(double <i>red</i>, double <i>green</i>, double <i>blue</i>, double <i>alpha</i>);
<br>cairo_pattern_t* <a name="cairo_pattern_create_for_surface"></a><span class="ddoc_psymbol">cairo_pattern_create_for_surface</span>(cairo_surface_t* <i>surface</i>);
<br>cairo_pattern_t* <a name="cairo_pattern_create_linear"></a><span class="ddoc_psymbol">cairo_pattern_create_linear</span>(double <i>x0</i>, double <i>y0</i>, double <i>x1</i>, double <i>y1</i>);
<br>cairo_pattern_t* <a name="cairo_pattern_create_radial"></a><span class="ddoc_psymbol">cairo_pattern_create_radial</span>(double <i>cx0</i>, double <i>cy0</i>, double <i>radius0</i>, double <i>cx1</i>, double <i>cy1</i>, double <i>radius1</i>);
<br>cairo_pattern_t* <a name="cairo_pattern_reference"></a><span class="ddoc_psymbol">cairo_pattern_reference</span>(cairo_pattern_t* <i>pattern</i>);
<br>void <a name="cairo_pattern_destroy"></a><span class="ddoc_psymbol">cairo_pattern_destroy</span>(cairo_pattern_t* <i>pattern</i>);
<br>uint <a name="cairo_pattern_get_reference_count"></a><span class="ddoc_psymbol">cairo_pattern_get_reference_count</span>(cairo_pattern_t* <i>pattern</i>);
<br>cairo_status_t <a name="cairo_pattern_status"></a><span class="ddoc_psymbol">cairo_pattern_status</span>(cairo_pattern_t* <i>pattern</i>);
<br>void* <a name="cairo_pattern_get_user_data"></a><span class="ddoc_psymbol">cairo_pattern_get_user_data</span>(cairo_pattern_t* <i>pattern</i>, const cairo_user_data_key_t* <i>key</i>);
<br>cairo_status_t <a name="cairo_pattern_set_user_data"></a><span class="ddoc_psymbol">cairo_pattern_set_user_data</span>(cairo_pattern_t* <i>pattern</i>, const cairo_user_data_key_t* <i>key</i>, void* <i>user_data</i>, cairo_destroy_func_t <i>destroy</i>);
</dt>
<dd>Pattern creation functions <p></p>

</dd>
<dt class="d_decl">enum <a name="cairo_pattern_type_t"></a><span class="ddoc_psymbol">cairo_pattern_type_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_pattern_type_t"></a><span class="ddoc_psymbol">cairo_pattern_type_t</span></span> is used to describe the type of a given pattern.
<p></p>
The type of a pattern is determined by the function used to create
 it. The cairo_pattern_create_rgb() and cairo_pattern_create_rgba()
 functions create SOLID patterns. The remaining
 cairo_pattern_create&lt;...&gt; functions map to pattern types in obvious
 ways.
<p></p>

 The pattern type can be queried with cairo_pattern_get_type()
<p></p>

 Most <span class="d_inlinecode">cairo_pattern_t</span> functions can be called with a pattern of any
 type, (though trying to change the extend or filter for a solid
 pattern will have no effect). A notable exception is
 cairo_pattern_add_color_stop_rgb() and
 cairo_pattern_add_color_stop_rgba() which must only be called with
 gradient patterns (either LINEAR or RADIAL). Otherwise the pattern
 will be shutdown and put into an error state.
<p></p>

 New entries may be added in future versions.

<p></p>
<b>Since:</b><br>
1.2<p></p>

<dl><dt class="d_decl"><a name="CAIRO_PATTERN_TYPE_SOLID"></a><span class="ddoc_psymbol">CAIRO_PATTERN_TYPE_SOLID</span></dt>
<dd>The pattern is a solid (uniform)
 color. It may be opaque or translucent.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_PATTERN_TYPE_SURFACE"></a><span class="ddoc_psymbol">CAIRO_PATTERN_TYPE_SURFACE</span></dt>
<dd>The pattern is a based on a surface (an image).<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_PATTERN_TYPE_LINEAR"></a><span class="ddoc_psymbol">CAIRO_PATTERN_TYPE_LINEAR</span></dt>
<dd>The pattern is a linear gradient.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_PATTERN_TYPE_RADIAL"></a><span class="ddoc_psymbol">CAIRO_PATTERN_TYPE_RADIAL</span></dt>
<dd>The pattern is a radial gradient.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">cairo_pattern_type_t <a name="cairo_pattern_get_type"></a><span class="ddoc_psymbol">cairo_pattern_get_type</span>(cairo_pattern_t* <i>pattern</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_pattern_add_color_stop_rgb"></a><span class="ddoc_psymbol">cairo_pattern_add_color_stop_rgb</span>(cairo_pattern_t* <i>pattern</i>, double <i>offset</i>, double <i>red</i>, double <i>green</i>, double <i>blue</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_pattern_add_color_stop_rgba"></a><span class="ddoc_psymbol">cairo_pattern_add_color_stop_rgba</span>(cairo_pattern_t* <i>pattern</i>, double <i>offset</i>, double <i>red</i>, double <i>green</i>, double <i>blue</i>, double <i>alpha</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_pattern_set_matrix"></a><span class="ddoc_psymbol">cairo_pattern_set_matrix</span>(cairo_pattern_t* <i>pattern</i>, const cairo_matrix_t* <i>matrix</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_pattern_get_matrix"></a><span class="ddoc_psymbol">cairo_pattern_get_matrix</span>(cairo_pattern_t* <i>pattern</i>, cairo_matrix_t* <i>matrix</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">enum <a name="cairo_extend_t"></a><span class="ddoc_psymbol">cairo_extend_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_extend_t"></a><span class="ddoc_psymbol">cairo_extend_t</span></span> is used to describe how pattern color/alpha will be
 determined for areas "outside" the pattern's natural area, (for
 example, outside the surface bounds or outside the gradient
 geometry).
<p></p>
The default extend mode is <span class="d_inlinecode">CAIRO_EXTEND_NONE</span> for surface patterns
 and <span class="d_inlinecode">CAIRO_EXTEND_PAD</span> for gradient patterns.
<p></p>

 New entries may be added in future versions.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_EXTEND_NONE"></a><span class="ddoc_psymbol">CAIRO_EXTEND_NONE</span></dt>
<dd>pixels outside of the source pattern
 are fully transparent<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_EXTEND_REPEAT"></a><span class="ddoc_psymbol">CAIRO_EXTEND_REPEAT</span></dt>
<dd>the pattern is tiled by repeating<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_EXTEND_REFLECT"></a><span class="ddoc_psymbol">CAIRO_EXTEND_REFLECT</span></dt>
<dd>the pattern is tiled by reflecting
 at the edges (Implemented for surface patterns since 1.6)<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_EXTEND_PAD"></a><span class="ddoc_psymbol">CAIRO_EXTEND_PAD</span></dt>
<dd>pixels outside of the pattern copy
 the closest pixel from the source (Since 1.2; but only
 implemented for surface patterns since 1.6)<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">void <a name="cairo_pattern_set_extend"></a><span class="ddoc_psymbol">cairo_pattern_set_extend</span>(cairo_pattern_t* <i>pattern</i>, cairo_extend_t <i>extend</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_extend_t <a name="cairo_pattern_get_extend"></a><span class="ddoc_psymbol">cairo_pattern_get_extend</span>(cairo_pattern_t* <i>pattern</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">enum <a name="cairo_filter_t"></a><span class="ddoc_psymbol">cairo_filter_t</span>;
</dt>
<dd><span class="d_inlinecode"><a name="cairo_filter_t"></a><span class="ddoc_psymbol">cairo_filter_t</span></span> is used to indicate what filtering should be
 applied when reading pixel values from patterns. See
 cairo_pattern_set_source() for indicating the desired filter to be
 used with a particular pattern.<p></p>

<dl><dt class="d_decl"><a name="CAIRO_FILTER_FAST"></a><span class="ddoc_psymbol">CAIRO_FILTER_FAST</span></dt>
<dd>A high-performance filter, with quality similar
 to %CAIRO_FILTER_NEAREST<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FILTER_GOOD"></a><span class="ddoc_psymbol">CAIRO_FILTER_GOOD</span></dt>
<dd>A reasonable-performance filter, with quality
 similar to %CAIRO_FILTER_BILINEAR<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FILTER_BEST"></a><span class="ddoc_psymbol">CAIRO_FILTER_BEST</span></dt>
<dd>The highest-quality available, performance may
 not be suitable for interactive use.<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FILTER_NEAREST"></a><span class="ddoc_psymbol">CAIRO_FILTER_NEAREST</span></dt>
<dd>Nearest-neighbor filtering<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FILTER_BILINEAR"></a><span class="ddoc_psymbol">CAIRO_FILTER_BILINEAR</span></dt>
<dd>Linear interpolation in two dimensions<p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_FILTER_GAUSSIAN"></a><span class="ddoc_psymbol">CAIRO_FILTER_GAUSSIAN</span></dt>
<dd>This filter value is currently
 unimplemented, and should not be used in current code.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">void <a name="cairo_pattern_set_filter"></a><span class="ddoc_psymbol">cairo_pattern_set_filter</span>(cairo_pattern_t* <i>pattern</i>, cairo_filter_t <i>filter</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_filter_t <a name="cairo_pattern_get_filter"></a><span class="ddoc_psymbol">cairo_pattern_get_filter</span>(cairo_pattern_t* <i>pattern</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_pattern_get_rgba"></a><span class="ddoc_psymbol">cairo_pattern_get_rgba</span>(cairo_pattern_t* <i>pattern</i>, double* <i>red</i>, double* <i>green</i>, double* <i>blue</i>, double* <i>alpha</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_pattern_get_surface"></a><span class="ddoc_psymbol">cairo_pattern_get_surface</span>(cairo_pattern_t* <i>pattern</i>, cairo_surface_t** <i>surface</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_pattern_get_color_stop_rgba"></a><span class="ddoc_psymbol">cairo_pattern_get_color_stop_rgba</span>(cairo_pattern_t* <i>pattern</i>, int <i>index</i>, double* <i>offset</i>, double* <i>red</i>, double* <i>green</i>, double* <i>blue</i>, double* <i>alpha</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_pattern_get_color_stop_count"></a><span class="ddoc_psymbol">cairo_pattern_get_color_stop_count</span>(cairo_pattern_t* <i>pattern</i>, int* <i>count</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_pattern_get_linear_points"></a><span class="ddoc_psymbol">cairo_pattern_get_linear_points</span>(cairo_pattern_t* <i>pattern</i>, double* <i>x0</i>, double* <i>y0</i>, double* <i>x1</i>, double* <i>y1</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_pattern_get_radial_circles"></a><span class="ddoc_psymbol">cairo_pattern_get_radial_circles</span>(cairo_pattern_t* <i>pattern</i>, double* <i>x0</i>, double* <i>y0</i>, double* <i>r0</i>, double* <i>x1</i>, double* <i>y1</i>, double* <i>r1</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_matrix_init"></a><span class="ddoc_psymbol">cairo_matrix_init</span>(cairo_matrix_t* <i>matrix</i>, double <i>xx</i>, double <i>yx</i>, double <i>xy</i>, double <i>yy</i>, double <i>x0</i>, double <i>y0</i>);
<br>void <a name="cairo_matrix_init_identity"></a><span class="ddoc_psymbol">cairo_matrix_init_identity</span>(cairo_matrix_t* <i>matrix</i>);
<br>void <a name="cairo_matrix_init_translate"></a><span class="ddoc_psymbol">cairo_matrix_init_translate</span>(cairo_matrix_t* <i>matrix</i>, double <i>tx</i>, double <i>ty</i>);
<br>void <a name="cairo_matrix_init_scale"></a><span class="ddoc_psymbol">cairo_matrix_init_scale</span>(cairo_matrix_t* <i>matrix</i>, double <i>sx</i>, double <i>sy</i>);
<br>void <a name="cairo_matrix_init_rotate"></a><span class="ddoc_psymbol">cairo_matrix_init_rotate</span>(cairo_matrix_t* <i>matrix</i>, double <i>radians</i>);
<br>void <a name="cairo_matrix_translate"></a><span class="ddoc_psymbol">cairo_matrix_translate</span>(cairo_matrix_t* <i>matrix</i>, double <i>tx</i>, double <i>ty</i>);
<br>void <a name="cairo_matrix_scale"></a><span class="ddoc_psymbol">cairo_matrix_scale</span>(cairo_matrix_t* <i>matrix</i>, double <i>sx</i>, double <i>sy</i>);
<br>void <a name="cairo_matrix_rotate"></a><span class="ddoc_psymbol">cairo_matrix_rotate</span>(cairo_matrix_t* <i>matrix</i>, double <i>radians</i>);
<br>cairo_status_t <a name="cairo_matrix_invert"></a><span class="ddoc_psymbol">cairo_matrix_invert</span>(cairo_matrix_t* <i>matrix</i>);
<br>void <a name="cairo_matrix_multiply"></a><span class="ddoc_psymbol">cairo_matrix_multiply</span>(cairo_matrix_t* <i>result</i>, const cairo_matrix_t* <i>a</i>, const cairo_matrix_t* <i>b</i>);
<br>void <a name="cairo_matrix_transform_distance"></a><span class="ddoc_psymbol">cairo_matrix_transform_distance</span>(const cairo_matrix_t* <i>matrix</i>, double* <i>dx</i>, double* <i>dy</i>);
<br>void <a name="cairo_matrix_transform_point"></a><span class="ddoc_psymbol">cairo_matrix_transform_point</span>(const cairo_matrix_t* <i>matrix</i>, double* <i>x</i>, double* <i>y</i>);
</dt>
<dd>Matrix functions <p></p>

</dd>
<dt class="d_decl">struct <a name="cairo_region_t"></a><span class="ddoc_psymbol">cairo_region_t</span>;
</dt>
<dd>A <span class="d_inlinecode"><a name="cairo_region_t"></a><span class="ddoc_psymbol">cairo_region_t</span></span> represents a set of integer-aligned rectangles.
<p></p>
It allows set-theoretical operations like cairo_region_union() and
 cairo_region_intersect() to be performed on them.
<p></p>

 Memory management of <span class="d_inlinecode"><a name="cairo_region_t"></a><span class="ddoc_psymbol">cairo_region_t</span></span> is done with
 cairo_region_reference() and cairo_region_destroy().

<p></p>
<b>Since:</b><br>
1.10<p></p>

</dd>
<dt class="d_decl">struct <a name="cairo_rectangle_int_t"></a><span class="ddoc_psymbol">cairo_rectangle_int_t</span>;
</dt>
<dd>A data structure for holding a rectangle with integer coordinates.
<p></p>
<b>Since:</b><br>
1.10<p></p>

<dl><dt class="d_decl">int <a name="x"></a><span class="ddoc_psymbol">x</span>;
</dt>
<dd>X coordinate of the left side of the rectangle<p></p>

</dd>
<dt class="d_decl">int <a name="y"></a><span class="ddoc_psymbol">y</span>;
</dt>
<dd>Y coordinate of the the top side of the rectangle<p></p>

</dd>
<dt class="d_decl">int <a name="width"></a><span class="ddoc_psymbol">width</span>;
</dt>
<dd><a name="width"></a><span class="ddoc_psymbol">width</span> of the rectangle<p></p>

</dd>
<dt class="d_decl">int <a name="height"></a><span class="ddoc_psymbol">height</span>;
</dt>
<dd><a name="height"></a><span class="ddoc_psymbol">height</span> of the rectangle<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">enum <a name="cairo_region_overlap_t"></a><span class="ddoc_psymbol">cairo_region_overlap_t</span>;
</dt>
<dd><p></p>
<dl><dt class="d_decl"><a name="CAIRO_REGION_OVERLAP_IN"></a><span class="ddoc_psymbol">CAIRO_REGION_OVERLAP_IN</span></dt>
<dd>completely inside region <p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_REGION_OVERLAP_OUT"></a><span class="ddoc_psymbol">CAIRO_REGION_OVERLAP_OUT</span></dt>
<dd>completely outside region <p></p>

</dd>
<dt class="d_decl"><a name="CAIRO_REGION_OVERLAP_PART"></a><span class="ddoc_psymbol">CAIRO_REGION_OVERLAP_PART</span></dt>
<dd>partly inside region <p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">cairo_region_t* <a name="cairo_region_create"></a><span class="ddoc_psymbol">cairo_region_create</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_region_t* <a name="cairo_region_create_rectangle"></a><span class="ddoc_psymbol">cairo_region_create_rectangle</span>(const cairo_rectangle_int_t* <i>rectangle</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_region_t* <a name="cairo_region_create_rectangles"></a><span class="ddoc_psymbol">cairo_region_create_rectangles</span>(const cairo_rectangle_int_t* <i>rects</i>, int <i>count</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_region_t* <a name="cairo_region_copy"></a><span class="ddoc_psymbol">cairo_region_copy</span>(const cairo_region_t* <i>original</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_region_t* <a name="cairo_region_reference"></a><span class="ddoc_psymbol">cairo_region_reference</span>(cairo_region_t* <i>region</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_region_destroy"></a><span class="ddoc_psymbol">cairo_region_destroy</span>(cairo_region_t* <i>region</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_bool_t <a name="cairo_region_equal"></a><span class="ddoc_psymbol">cairo_region_equal</span>(const cairo_region_t* <i>a</i>, const cairo_region_t* <i>b</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_region_status"></a><span class="ddoc_psymbol">cairo_region_status</span>(const cairo_region_t* <i>region</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_region_get_extents"></a><span class="ddoc_psymbol">cairo_region_get_extents</span>(const cairo_region_t* <i>region</i>, cairo_rectangle_int_t* <i>extents</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="cairo_region_num_rectangles"></a><span class="ddoc_psymbol">cairo_region_num_rectangles</span>(const cairo_region_t* <i>region</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_region_get_rectangle"></a><span class="ddoc_psymbol">cairo_region_get_rectangle</span>(const cairo_region_t* <i>region</i>, int <i>nth</i>, cairo_rectangle_int_t* <i>rectangle</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_bool_t <a name="cairo_region_is_empty"></a><span class="ddoc_psymbol">cairo_region_is_empty</span>(const cairo_region_t* <i>region</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_region_overlap_t <a name="cairo_region_contains_rectangle"></a><span class="ddoc_psymbol">cairo_region_contains_rectangle</span>(const cairo_region_t* <i>region</i>, const cairo_rectangle_int_t* <i>rectangle</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_bool_t <a name="cairo_region_contains_point"></a><span class="ddoc_psymbol">cairo_region_contains_point</span>(const cairo_region_t* <i>region</i>, int <i>x</i>, int <i>y</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_region_translate"></a><span class="ddoc_psymbol">cairo_region_translate</span>(cairo_region_t* <i>region</i>, int <i>dx</i>, int <i>dy</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_region_subtract"></a><span class="ddoc_psymbol">cairo_region_subtract</span>(cairo_region_t* <i>dst</i>, const cairo_region_t* <i>other</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_region_subtract_rectangle"></a><span class="ddoc_psymbol">cairo_region_subtract_rectangle</span>(cairo_region_t* <i>dst</i>, const cairo_rectangle_int_t* <i>rectangle</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_region_intersect"></a><span class="ddoc_psymbol">cairo_region_intersect</span>(cairo_region_t* <i>dst</i>, const cairo_region_t* <i>other</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_region_intersect_rectangle"></a><span class="ddoc_psymbol">cairo_region_intersect_rectangle</span>(cairo_region_t* <i>dst</i>, const cairo_rectangle_int_t* <i>rectangle</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_region_union"></a><span class="ddoc_psymbol">cairo_region_union</span>(cairo_region_t* <i>dst</i>, const cairo_region_t* <i>other</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_region_union_rectangle"></a><span class="ddoc_psymbol">cairo_region_union_rectangle</span>(cairo_region_t* <i>dst</i>, const cairo_rectangle_int_t* <i>rectangle</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_region_xor"></a><span class="ddoc_psymbol">cairo_region_xor</span>(cairo_region_t* <i>dst</i>, const cairo_region_t* <i>other</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">cairo_status_t <a name="cairo_region_xor_rectangle"></a><span class="ddoc_psymbol">cairo_region_xor_rectangle</span>(cairo_region_t* <i>dst</i>, const cairo_rectangle_int_t* <i>rectangle</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">void <a name="cairo_debug_reset_static_data"></a><span class="ddoc_psymbol">cairo_debug_reset_static_data</span>();
</dt>
<dd>Functions to be used while debugging (not intended for use in production code) <p></p>

</dd>
</dl>

    
</div>


<div id="copyright">
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
