<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>cairo.cairo - CairoD </title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="../js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="header">
		<a id="d-language" href="https://github.com/jpf91/cairoD">cairod api reference</a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
</div>
    
<div class="navblock">
    <h2><a href="" title="CairoD wrapper">cairo</a></h2>
    <ul><li><a href="cairo_cairo.html" title="">cairo.cairo</a></li>
	<li><a href="cairo_directfb.html" title="">cairo.directfb</a></li>
	<li><a href="cairo_pdf.html" title="">cairo.pdf</a></li>
	<li><a href="cairo_ps.html" title="">cairo.ps</a></li>
	<li><a href="cairo_svg.html" title="">cairo.svg</a></li>
    <li><a href="cairo_win32.html" title="">cairo.win32</a></li>
    <li><a href="cairo_xcb.html" title="">cairo.xcb</a></li>
    <li><a href="cairo_ft.html" title="">cairo.ft</a></li>
    <li><a href="cairo_xlib.html" title="">cairo.xlib</a></li>
    <li><a href="cairo_util.html" title="">cairo.util</a></li>
    </ul>
    <h2><a href="" title="cairo D bindings">cairo.c</a></h2>
    <ul><li><a href="cairo_c_cairo.html" title="">cairo.c.cairo</a></li>
	<li><a href="cairo_c_directfb.html" title="">cairo.c.directfb</a></li>
	<li><a href="cairo_c_pdf.html" title="">cairo.c.pdf</a></li>
	<li><a href="cairo_c_ps.html" title="">cairo.c.ps</a></li>
	<li><a href="cairo_c_svg.html" title="">cairo.c.svg</a></li>
    <li><a href="cairo_c_win32.html" title="">cairo.c.win32</a></li>
    <li><a href="cairo_c_xcb.html" title="">cairo.c.xcb</a></li>
    <li><a href="cairo_c_ft.html" title="">cairo.c.ft</a></li>
    <li><a href="cairo_c_xlib.html" title="">cairo.c.xlib</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>cairo.cairo</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from cairo/cairo.d -->
This module contains wrappers for most of <a name="cairo"></a><span class="ddoc_psymbol">cairo</span>'s fuctionality.
 Additional wrappers for subsets of <a name="cairo"></a><span class="ddoc_psymbol">cairo</span> are available in the
 <a name="cairo"></a><span class="ddoc_psymbol">cairo</span>.* modules.
<p></p>
<b>Note:</b><br>
Most cairoD functions could throw an OutOfMemoryError. This is therefore not
 explicitly stated in the functions' api documenation.

<p></p>
<b>See Also:</b><br><a href="http://cairographics.org/documentation/">http://cairographics.org/documentation/</a>

<p></p>
<b>License:</b><br><table cellspacing=0 cellpadding=5 class=book><caption></caption>   <tr><td valign=top>cairoD wrapper/bindings</td>
     <td valign=top><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a></td></tr>
   <tr><td valign=top><a href="http://cgit.freedesktop.org/cairo/tree/COPYING">cairo</a></td>
     <td valign=top><a href="http://cgit.freedesktop.org/cairo/tree/COPYING-LGPL-2.1">LGPL 2.1</a> /
     <a href="http://cgit.freedesktop.org/cairo/plain/COPYING-MPL-1.1">MPL 1.1</a></td></tr>
 </table>
<p></p>
<b>Authors:</b><br><table cellspacing=0 cellpadding=5 class=book><caption></caption>   <tr><td valign=top>Johannes Pfau</td> <td valign=top>cairoD</td></tr>
   <tr><td valign=top><a href="http://cairographics.org">cairo team</a></td> <td valign=top>cairo</td></tr>
 </table><p></p>

<dl><dt class="d_decl">void <a name="throwError"></a><span class="ddoc_psymbol">throwError</span>(cairo_status_t <i>status</i>);
</dt>
<dd>Mainly used internally by cairoD.
 If <i>status</i> is CAIRO_STATUS_NO_MEMORY a OutOfMemoryError is thrown.
 If <i>status</i> is  CAIRO_STATUS_SUCCESS nothing happens.
 For all other statuses, this functions throws
 a <span class="d_inlinecode">CairoException</span> with the <i>status</i> value.<p></p>

</dd>
<dt class="d_decl">class <a name="CairoException"></a><span class="ddoc_psymbol">CairoException</span>: object.Exception;
</dt>
<dd>Exception thrown by cairoD if an error occurs.<p></p>

<dl><dt class="d_decl">cairo_status_t <a name="status"></a><span class="ddoc_psymbol">status</span>;
</dt>
<dd>Cairo's error <a name="status"></a><span class="ddoc_psymbol">status</span>.
 Gives further information about the error.<p></p>

</dd>
<dt class="d_decl">this(cairo_status_t <i>stat</i>);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl">alias <a name="Content"></a><span class="ddoc_psymbol">Content</span>;
<br>alias <a name="AntiAlias"></a><span class="ddoc_psymbol">AntiAlias</span>;
<br>alias <a name="SubpixelOrder"></a><span class="ddoc_psymbol">SubpixelOrder</span>;
<br>alias <a name="HintStyle"></a><span class="ddoc_psymbol">HintStyle</span>;
<br>alias <a name="HintMetrics"></a><span class="ddoc_psymbol">HintMetrics</span>;
<br>alias <a name="SurfaceType"></a><span class="ddoc_psymbol">SurfaceType</span>;
<br>alias <a name="Format"></a><span class="ddoc_psymbol">Format</span>;
<br>alias <a name="Extend"></a><span class="ddoc_psymbol">Extend</span>;
<br>alias <a name="Filter"></a><span class="ddoc_psymbol">Filter</span>;
<br>alias <a name="PatternType"></a><span class="ddoc_psymbol">PatternType</span>;
<br>alias <a name="FillRule"></a><span class="ddoc_psymbol">FillRule</span>;
<br>alias <a name="LineCap"></a><span class="ddoc_psymbol">LineCap</span>;
<br>alias <a name="LineJoin"></a><span class="ddoc_psymbol">LineJoin</span>;
<br>alias <a name="Operator"></a><span class="ddoc_psymbol">Operator</span>;
<br>alias <a name="PathElementType"></a><span class="ddoc_psymbol">PathElementType</span>;
<br>alias <a name="FontExtents"></a><span class="ddoc_psymbol">FontExtents</span>;
<br>alias <a name="TextExtents"></a><span class="ddoc_psymbol">TextExtents</span>;
<br>alias <a name="Glyph"></a><span class="ddoc_psymbol">Glyph</span>;
<br>alias <a name="TextCluster"></a><span class="ddoc_psymbol">TextCluster</span>;
<br>alias <a name="TextClusterFlags"></a><span class="ddoc_psymbol">TextClusterFlags</span>;
<br>alias <a name="FontSlant"></a><span class="ddoc_psymbol">FontSlant</span>;
<br>alias <a name="FontWeight"></a><span class="ddoc_psymbol">FontWeight</span>;
<br>alias <a name="DeviceType"></a><span class="ddoc_psymbol">DeviceType</span>;
<br>alias <a name="FontType"></a><span class="ddoc_psymbol">FontType</span>;
</dt>
<dd>Aliases for simple cairo enums and structs.
 Theses aliases provide D-like names when
 using the cairoD API.
<p></p>
<span style="color:red">BUGS:</span><br>DDOC doesn't document what an alias actually aliases.
 If you can't guess the corresponding cairo C types, you should
 have a look at the cairo.d source.<p></p>

</dd>
<dt class="d_decl">struct <a name="Point"></a><span class="ddoc_psymbol">Point</span>;
<br>struct <a name="<a name="PointInt"></a><span class="ddoc_psymbol">PointInt</span>"></a><span class="ddoc_psymbol"><a name="PointInt"></a><span class="ddoc_psymbol">PointInt</span></span>;
</dt>
<dd>A simple struct to store the coordinates of a point.<p></p>

<dl><dt class="d_decl">this(double <i>x</i>, double <i>y</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">double <a name="x"></a><span class="ddoc_psymbol">x</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">double <a name="y"></a><span class="ddoc_psymbol">y</span>;
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="Rectangle"></a><span class="ddoc_psymbol">Rectangle</span>(T) if (is(T == double) || is(T == int));
</dt>
<dd>A simple struct representing a rectangle with <span class="d_inlinecode">int</span> or  values<p></p>

<dl><dt class="d_decl">auto this(PointType <i>point</i>, T <i>width</i>, T <i>height</i>);
<br>auto this(T <i>x</i>, T <i>y</i>, T <i>width</i>, T <i>height</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">PointType <a name="point"></a><span class="ddoc_psymbol">point</span>;
</dt>
<dd>TOP-LEFT <a name="point"></a><span class="ddoc_psymbol">point</span> of the rectangle<p></p>

</dd>
<dt class="d_decl">T <a name="width"></a><span class="ddoc_psymbol">width</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">T <a name="height"></a><span class="ddoc_psymbol">height</span>;
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl">auto <a name="rectangle"></a><span class="ddoc_psymbol">rectangle</span>(T)(T <i>x</i>, T <i>y</i>, T <i>width</i>, T <i>height</i>);
</dt>
<dd>Convenience function to create a <span class="d_inlinecode">Rectangle!int</span> or <span class="d_inlinecode">Rectangle!double</span>
 depending on the argument types.
<p></p>
<b>Examples:</b><br><pre class="d_code"> <span class="d_keyword">auto</span> a = <span class="d_psymbol">rectangle</span>(1, 1, 4, 4);
 <span class="d_keyword">auto</span> b = <span class="d_psymbol">rectangle</span>(0.99, 0.99, 3.99, 3.99);
</pre>
<p></p>

</dd>
<dt class="d_decl">struct <a name="Size"></a><span class="ddoc_psymbol">Size</span>(T) if (is(T == int));
</dt>
<dd>A simple struct representing a size with only <span class="d_inlinecode">int</span> values<p></p>

<dl><dt class="d_decl">auto this(int <i>width</i>, int <i>height</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="width"></a><span class="ddoc_psymbol">width</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="height"></a><span class="ddoc_psymbol">height</span>;
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="Size"></a><span class="ddoc_psymbol">Size</span>(T) if (is(T == double));
</dt>
<dd>A simple struct representing a size with <span class="d_inlinecode">double</span> values<p></p>

<dl><dt class="d_decl">auto this(double <i>width</i>, double <i>height</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">double <a name="width"></a><span class="ddoc_psymbol">width</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">double <a name="height"></a><span class="ddoc_psymbol">height</span>;
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="Box"></a><span class="ddoc_psymbol">Box</span>;
</dt>
<dd>A simple struct representing a box.
 Used for Extents.<p></p>

<dl><dt class="d_decl">this(Point <i>point1</i>, Point <i>point2</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">this(double <i>x1</i>, double <i>y1</i>, double <i>x2</i>, double <i>y2</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">Point <a name="point1"></a><span class="ddoc_psymbol">point1</span>;
</dt>
<dd>Top-left point<p></p>

</dd>
<dt class="d_decl">Point <a name="point2"></a><span class="ddoc_psymbol">point2</span>;
</dt>
<dd>Bottom-right point<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="Resolution"></a><span class="ddoc_psymbol">Resolution</span>;
</dt>
<dd>A simple struct representing a resolution<p></p>

<dl><dt class="d_decl">this(double <i>resX</i>, double <i>resY</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">double <a name="x"></a><span class="ddoc_psymbol">x</span>;
</dt>
<dd>In pixels per inch<p></p>

</dd>
<dt class="d_decl">double <a name="y"></a><span class="ddoc_psymbol">y</span>;
</dt>
<dd>In pixels per inch<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="RGBA"></a><span class="ddoc_psymbol">RGBA</span>;
</dt>
<dd>Struct representing a <a name="RGBA"></a><span class="ddoc_psymbol">RGBA</span> color<p></p>

<dl><dt class="d_decl">this(double <i>red</i>, double <i>green</i>, double <i>blue</i>, double <i>alpha</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">double <a name="red"></a><span class="ddoc_psymbol">red</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">double <a name="green"></a><span class="ddoc_psymbol">green</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">double <a name="blue"></a><span class="ddoc_psymbol">blue</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">double <a name="alpha"></a><span class="ddoc_psymbol">alpha</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">RGB <a name="opCast"></a><span class="ddoc_psymbol">opCast</span>(RGB)();
</dt>
<dd>convert RGBA struct to RGB struct. Alpha is discarded<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="RGB"></a><span class="ddoc_psymbol">RGB</span>;
</dt>
<dd>Struct representing a <a name="RGB"></a><span class="ddoc_psymbol">RGB</span> color<p></p>

<dl><dt class="d_decl">this(double <i>red</i>, double <i>green</i>, double <i>blue</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">double <a name="red"></a><span class="ddoc_psymbol">red</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">double <a name="green"></a><span class="ddoc_psymbol">green</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">double <a name="blue"></a><span class="ddoc_psymbol">blue</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">RGBA <a name="opCast"></a><span class="ddoc_psymbol">opCast</span>(RGBA)();
</dt>
<dd>convert RGBA struct to RGB struct. Alpha is set to '1.0'<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="Path"></a><span class="ddoc_psymbol">Path</span>;
</dt>
<dd>Reference counted wrapper around <span class="d_inlinecode">cairo_path_t</span>.
 This struct can only be obtained from cairoD. It should not be created
 manually.<p></p>

<dl><dt class="d_decl">this(cairo_path_t* <i>path</i>);
</dt>
<dd>Create a Path from a existing <span class="d_inlinecode">cairo_path_t*</span>.
 Path is a reference-counted type. It will call <span class="d_inlinecode">cairo_path_destroy</span>
 when there are no more references to the <i>path</i>.
<p></p>
This means you should not destroy the <span class="d_inlinecode">cairo_path_t*</span> manually
 and you should not use <span class="d_inlinecode">cairo_path_t*</span> anymore after you created a Path
 with this constructor.

<p></p>
<b>Warning:</b><br>
<span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">@property cairo_path_t* <a name="nativePointer"></a><span class="ddoc_psymbol">nativePointer</span>();
</dt>
<dd>The underlying <span class="d_inlinecode">cairo_path_t*</span> handle<p></p>

</dd>
<dt class="d_decl">@property bool <a name="debugging"></a><span class="ddoc_psymbol">debugging</span>();
<br>@property void <a name="debugging"></a><span class="ddoc_psymbol">debugging</span>(bool <i>value</i>);
</dt>
<dd>Enable / disable memory management <a name="debugging"></a><span class="ddoc_psymbol">debugging</span> for this Path
 instance. Only available if both cairoD and the cairoD user
 code were compiled with "debug=RefCounted"
<p></p>
Output is written to stdout, see
 <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging">https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging</a>
 for more information<p></p>

</dd>
<dt class="d_decl">PathRange <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</dt>
<dd>Get a <span class="d_inlinecode">PathRange</span> for this path to iterate the paths
 elements.
<p></p>
<b>Examples:</b><br><pre class="d_code"> <span class="d_keyword">auto</span> path = context.copyPath();
 <span class="d_keyword">foreach</span>(PathElement element; path[])
 {
     <span class="d_keyword">switch</span>(element.type)
     {
          <span class="d_keyword">case</span> PathElementType.CAIRO_PATH_MOVE_TO:
          {
              writefln(<span class="d_string">"Move to %s:%s"</span>, element.getPoint(0).x,
                       element.getPoint(0).y);
          }
     }
 }
</pre>
<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="PathRange"></a><span class="ddoc_psymbol">PathRange</span>;
</dt>
<dd>ForwardRange to iterate a cairo path.
 This range keeps a reference to its <span class="d_inlinecode">Path</span> object,
 so it can be passed around without thinking about memory management.<p></p>

<dl><dt class="d_decl">this(Path <i>path</i>);
</dt>
<dd>Constructor to get a PathRange for a <span class="d_inlinecode">Path</span> object.
 You should usually use <span class="d_inlinecode">Path</span>'s opSlice method insted, see
 the <span class="d_inlinecode">Path</span> documentation for an example.<p></p>

</dd>
<dt class="d_decl">@property PathRange <a name="save"></a><span class="ddoc_psymbol">save</span>();
<br>@property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
<br>@property PathElement <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd>ForwardRange implementation<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="PathElement"></a><span class="ddoc_psymbol">PathElement</span>;
</dt>
<dd>An element of a cairo <span class="d_inlinecode">Path</span> and the objects iterated by a
 <span class="d_inlinecode">PathRange</span>.<p></p>

<dl><dt class="d_decl">@property PathElementType <a name="type"></a><span class="ddoc_psymbol">type</span>();
</dt>
<dd>The <a name="type"></a><span class="ddoc_psymbol">type</span> of this element.<p></p>

</dd>
<dt class="d_decl">Point <a name="getPoint"></a><span class="ddoc_psymbol">getPoint</span>(int <i>index</i>);
</dt>
<dd>Get a point from this element.
 Index is zero-based. The number of available points
 depends on the elements <span class="d_inlinecode">type</span>:
<pre class="d_code">     CAIRO_PATH_MOVE_TO:     1 point
     CAIRO_PATH_LINE_TO:     1 point
     CAIRO_PATH_CURVE_TO:    3 points
     CAIRO_PATH_CLOSE_PATH:  0 points
</pre>
<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="Matrix"></a><span class="ddoc_psymbol">Matrix</span>;
</dt>
<dd>Wrapper for cairo's <span class="d_inlinecode">cairo_matrix_t</span>.
 A <span class="d_inlinecode">cairo_matrix_t</span> holds an affine transformation, such as a scale,
 rotation, shear, or a combination of those. The transformation of
 a point (x, y) is given by:
<pre class="d_code">     x_new = xx * x + xy * y + x0;
     y_new = yx * x + yy * y + y0;
</pre>
<p></p>

<dl><dt class="d_decl">cairo_matrix_t <a name="nativeMatrix"></a><span class="ddoc_psymbol">nativeMatrix</span>;
</dt>
<dd>Cairo's <span class="d_inlinecode">cairo_matrix_t</span> struct<p></p>

</dd>
<dt class="d_decl">this(double <i>xx</i>, double <i>yx</i>, double <i>xy</i>, double <i>yy</i>, double <i>x0</i>, double <i>y0</i>);
</dt>
<dd>Sets matrix to be the affine transformation given by <i>xx</i>, <i>yx</i>, <i>xy</i>, <i>yy</i>, <i>x0</i>, <i>y0</i>.
 The transformation is given by:
<pre class="d_code">  x_new = <span class="d_param">xx</span> * x + <span class="d_param">xy</span> * y + <span class="d_param">x0</span>;
  y_new = <span class="d_param">yx</span> * x + <span class="d_param">yy</span> * y + <span class="d_param">y0</span>;
</pre>
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>xx</i></td>
<td valign=top><i>xx</i> component of the affine transformation</td></tr>
<tr><td valign=top>double <i>yx</i></td>
<td valign=top><i>yx</i> component of the affine transformation</td></tr>
<tr><td valign=top>double <i>xy</i></td>
<td valign=top><i>xy</i> component of the affine transformation</td></tr>
<tr><td valign=top>double <i>yy</i></td>
<td valign=top><i>yy</i> component of the affine transformation</td></tr>
<tr><td valign=top>double <i>x0</i></td>
<td valign=top>X translation component of the affine transformation</td></tr>
<tr><td valign=top>double <i>y0</i></td>
<td valign=top>Y translation component of the affine transformation</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="initIdentity"></a><span class="ddoc_psymbol">initIdentity</span>();
</dt>
<dd>Modifies matrix to be an identity transformation.<p></p>

</dd>
<dt class="d_decl">void <a name="initTranslate"></a><span class="ddoc_psymbol">initTranslate</span>(double <i>tx</i>, double <i>ty</i>);
</dt>
<dd>Initializes matrix to a transformation that translates by <i>tx</i>
 and <i>ty</i> in the X and Y dimensions, respectively.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>tx</i></td>
<td valign=top>amount to translate in the X direction</td></tr>
<tr><td valign=top>double <i>ty</i></td>
<td valign=top>amount to translate in the Y direction</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="initScale"></a><span class="ddoc_psymbol">initScale</span>(double <i>sx</i>, double <i>sy</i>);
<br>void <a name="initScale"></a><span class="ddoc_psymbol">initScale</span>(Point <i>point</i>);
</dt>
<dd>nitializes matrix to a transformation that scales by <i>sx</i> and <i>sy</i>
 in the X and Y dimensions, respectively.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>sx</i></td>
<td valign=top>scale factor in the X direction</td></tr>
<tr><td valign=top>double <i>sy</i></td>
<td valign=top>scale factor in the Y direction</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="initRotate"></a><span class="ddoc_psymbol">initRotate</span>(double <i>radians</i>);
</dt>
<dd>Initialized matrix to a transformation that rotates by <i>radians</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>radians</i></td>
<td valign=top>angle of rotation, in <i>radians</i>. The direction of
     rotation is defined such that positive angles rotate in
     the direction from the positive X axis toward the positive
     Y axis. With the default axis orientation of cairo,
     positive angles rotate in a clockwise direction</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="translate"></a><span class="ddoc_psymbol">translate</span>(double <i>tx</i>, double <i>ty</i>);
</dt>
<dd>Applies a translation by <i>tx</i>, <i>ty</i> to the transformation in matrix.
 The effect of the new transformation is to first <a name="translate"></a><span class="ddoc_psymbol">translate</span> the
 coordinates by <i>tx</i> and <i>ty</i>, then apply the original transformation
 to the coordinates.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>tx</i></td>
<td valign=top>amount to <a name="translate"></a><span class="ddoc_psymbol">translate</span> in the X direction</td></tr>
<tr><td valign=top>double <i>ty</i></td>
<td valign=top>amount to <a name="translate"></a><span class="ddoc_psymbol">translate</span> in the Y direction</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="scale"></a><span class="ddoc_psymbol">scale</span>(double <i>sx</i>, double <i>sy</i>);
<br>void <a name="scale"></a><span class="ddoc_psymbol">scale</span>(Point <i>point</i>);
</dt>
<dd>Applies scaling by <i>sx</i>, <i>sy</i> to the transformation in matrix.
 The effect of the new transformation is to first <a name="scale"></a><span class="ddoc_psymbol">scale</span> the
 coordinates by <i>sx</i> and <i>sy</i>, then apply the original transformation
 to the coordinates.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>sx</i></td>
<td valign=top><a name="scale"></a><span class="ddoc_psymbol">scale</span> factor in the X direction</td></tr>
<tr><td valign=top>double <i>sy</i></td>
<td valign=top><a name="scale"></a><span class="ddoc_psymbol">scale</span> factor in the Y direction</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="rotate"></a><span class="ddoc_psymbol">rotate</span>(double <i>radians</i>);
</dt>
<dd>Applies rotation by <i>radians</i> to the transformation in matrix.
 The effect of the new transformation is to first <a name="rotate"></a><span class="ddoc_psymbol">rotate</span> the
 coordinates by <i>radians</i>, then apply the original transformation
 to the coordinates.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>radians</i></td>
<td valign=top>angle of rotation, in <i>radians</i>. The direction of
 rotation is defined such that positive angles <a name="rotate"></a><span class="ddoc_psymbol">rotate</span> in the
 direction from the positive X axis toward the positive Y axis.
 With the default axis orientation of cairo, positive angles
 <a name="rotate"></a><span class="ddoc_psymbol">rotate</span> in a clockwise direction.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="invert"></a><span class="ddoc_psymbol">invert</span>();
</dt>
<dd>Changes matrix to be the inverse of its original value.
 Not all transformation matrices have inverses; if the matrix
 collapses points together (it is degenerate), then it has no
 inverse and this function will fail.
<p></p>
<b>Throws:</b><br>If matrix has an inverse, modifies matrix to be the inverse matrix.
 Otherwise, throws a cairo exception
 with CAIRO_STATUS_INVALID_MATRIX type.<p></p>

</dd>
<dt class="d_decl">Matrix <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op)(Matrix <i>rhs</i>);
</dt>
<dd>Multiplies the affine transformations in a and b together and
 returns the result. The effect of the resulting transformation
 is to first apply the transformation in a to the coordinates
 and then apply the transformation in b to the coordinates.
<p></p>
It is allowable for result to be identical to either a or b.<p></p>

</dd>
<dt class="d_decl">Point <a name="transformDistance"></a><span class="ddoc_psymbol">transformDistance</span>(Point <i>dist</i>);
</dt>
<dd>Transforms the distance vector (dx,dy) by matrix. This is similar
 to <span class="d_inlinecode">transformPoint</span> except that the translation
 components of the transformation are ignored. The calculation
 of the returned vector is as follows:
<pre class="d_code"> dx2 = dx1 * a + dy1 * c;
 dy2 = dx1 * b + dy1 * d;
</pre>
<p></p>

</dd>
<dt class="d_decl">Point <a name="transformPoint"></a><span class="ddoc_psymbol">transformPoint</span>(Point <i>point</i>);
</dt>
<dd>Transforms the <i>point</i> (x, y) by matrix.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">class <a name="Pattern"></a><span class="ddoc_psymbol">Pattern</span>;
</dt>
<dd>A <span class="d_inlinecode"><a name="Pattern"></a><span class="ddoc_psymbol">Pattern</span></span> represents a source when drawing onto a
 <span class="d_inlinecode">Surface</span>. There are different subtypes of <span class="d_inlinecode"><a name="Pattern"></a><span class="ddoc_psymbol">Pattern</span></span>,
 for different types of sources; for example,
 <span class="d_inlinecode">SolidPattern.fromRGB</span> creates a pattern for a solid
 opaque color.
<p></p>
Other than various <span class="d_inlinecode"><a name="Pattern"></a><span class="ddoc_psymbol">Pattern</span></span> subclasses,
 some of the pattern types can be implicitly created
 using various <span class="d_inlinecode">Context.setSource</span> functions;
 for example <span class="d_inlinecode">Context.setSourceRGB</span>.
<p></p>

 The C type of a pattern can be queried with <span class="d_inlinecode">getType()</span>,
 although D polymorphism features also work.
<p></p>

 Memory management of <span class="d_inlinecode"><a name="Pattern"></a><span class="ddoc_psymbol">Pattern</span></span> can be done with the <span class="d_inlinecode">dispose()</span>
 method, see <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class">https://github.com/jpf91/cairoD/wiki/Memory-Management#3-RC-class</a>

<p></p>
<b>Note:</b><br>
This class uses the <span class="d_inlinecode">CairoCountedClass</span> mixin, so all it's members
 are also available in <span class="d_inlinecode"><a name="Pattern"></a><span class="ddoc_psymbol">Pattern</span></span> classes, although they do not show
 up in the documentation because of a limitation in ddoc.<p></p>

<dl><dt class="d_decl">protected final void <a name="checkError"></a><span class="ddoc_psymbol">checkError</span>();
</dt>
<dd>Method for use in subclasses.
 Calls <span class="d_inlinecode">cairo_pattern_status(nativePointer)</span> and throws
 an exception if the status isn't CAIRO_STATUS_SUCCESS<p></p>

</dd>
<dt class="d_decl">this(cairo_pattern_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">Pattern</span> from a existing <span class="d_inlinecode">cairo_pattern_t*</span>.
 Pattern is a garbage collected class. It will call <span class="d_inlinecode">cairo_pattern_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">static Pattern <a name="createFromNative"></a><span class="ddoc_psymbol">createFromNative</span>(cairo_pattern_t* <i>ptr</i>, bool <i>adjRefCount</i> = true);
</dt>
<dd>The <a name="createFromNative"></a><span class="ddoc_psymbol">createFromNative</span> method for the Pattern classes.
 See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative">https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative</a>
 for more information.
<p></p>
<b>Warning:</b><br>
<span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">void <a name="setExtend"></a><span class="ddoc_psymbol">setExtend</span>(Extend <i>ext</i>);
</dt>
<dd>Sets the mode to be used for drawing outside the area of a pattern.
 See <span class="d_inlinecode">Extend</span> for details on the semantics of each extend strategy.
 The default extend mode is CAIRO_EXTEND_NONE for surface patterns
 and CAIRO_EXTEND_PAD for gradient patterns.<p></p>

</dd>
<dt class="d_decl">Extend <a name="getExtend"></a><span class="ddoc_psymbol">getExtend</span>();
</dt>
<dd>Gets the current extend mode for a pattern. See <span class="d_inlinecode">Extend</span>
 for details on the semantics of each extend strategy.<p></p>

</dd>
<dt class="d_decl">void <a name="setFilter"></a><span class="ddoc_psymbol">setFilter</span>(Filter <i>fil</i>);
</dt>
<dd>Sets the filter to be used for resizing when using this pattern.
 See <span class="d_inlinecode">Filter</span> for details on each filter.
<p></p>
<b>Note:</b><br>
You might want to control filtering even when you do not have
 an explicit cairo_pattern_t object, (for example when using
 <span class="d_inlinecode">context.setSourceSourface()</span>). In these cases, it is convenient
 to use <span class="d_inlinecode">Context.getSource()</span> to get access to the pattern
 that cairo creates implicitly.
 For example:
<pre class="d_code"> context.setSourceSurface(image, x, y);
 context.getSource().<span class="d_psymbol">setFilter</span>(Filter.CAIRO_FILTER_NEAREST);
</pre>
<p></p>

</dd>
<dt class="d_decl">Filter <a name="getFilter"></a><span class="ddoc_psymbol">getFilter</span>();
</dt>
<dd>Gets the current filter for a pattern. See <span class="d_inlinecode">Filter</span> for details on each filter.<p></p>

</dd>
<dt class="d_decl">void <a name="setMatrix"></a><span class="ddoc_psymbol">setMatrix</span>(Matrix <i>mat</i>);
</dt>
<dd>Sets the pattern's transformation matrix to matrix.
 This matrix is a transformation from user space to pattern space.
<p></p>
When a pattern is first created it always has the identity matrix
 for its transformation matrix, which means that pattern space
 is initially identical to user space.
<p></p>
<b>Important:</b><br>
Please note that the direction of this transformation
 matrix is from user space to pattern space. This means that if
 you imagine the flow from a pattern to user space (and on to
 device space), then coordinates in that flow will be transformed
 by the inverse of the pattern matrix.
<p></p>

 For example, if you want to make a pattern appear twice as large
 as it does by default the correct code to use is:
<pre class="d_code"> Matrix matrix;
 matrix.initScale(0.5, 0.5);
 pattern.<span class="d_psymbol">setMatrix</span>(matrix);
</pre>
 Meanwhile, using values of 2.0 rather than 0.5 in the code above
 would cause the pattern to appear at half of its default size.
<p></p>

 Also, please note the discussion of the user-space locking semantics
 of <span class="d_inlinecode">Context.setSource()</span>.<p></p>

</dd>
<dt class="d_decl">Matrix <a name="getMatrix"></a><span class="ddoc_psymbol">getMatrix</span>();
</dt>
<dd>Returns the pattern's transformation matrix.<p></p>

</dd>
<dt class="d_decl">PatternType <a name="getType"></a><span class="ddoc_psymbol">getType</span>();
</dt>
<dd>This function returns the C type of a pattern. See <span class="d_inlinecode">PatternType</span>
 for available types.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">class <a name="SolidPattern"></a><span class="ddoc_psymbol">SolidPattern</span>: cairo.cairo.Pattern;
</dt>
<dd>A solid pattern.
<p></p>
Use the <span class="d_inlinecode">fromRGB</span> and <span class="d_inlinecode">fromRGBA</span> methods to create an
 instance.<p></p>

<dl><dt class="d_decl">this(cairo_pattern_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">SolidPattern</span> from a existing <span class="d_inlinecode">cairo_pattern_t*</span>.
 SolidPattern is a garbage collected class. It will call <span class="d_inlinecode">cairo_pattern_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">static SolidPattern <a name="fromRGB"></a><span class="ddoc_psymbol">fromRGB</span>(double <i>red</i>, double <i>green</i>, double <i>blue</i>);
<br>static SolidPattern <a name="fromRGB"></a><span class="ddoc_psymbol">fromRGB</span>(RGB <i>rgb</i>);
</dt>
<dd>Creates a new <span class="d_inlinecode">SolidPattern</span> corresponding to an opaque color.
 The color components are floating point numbers in the range 0
 to 1. If the values passed in are outside that range, they will
 be clamped.<p></p>

</dd>
<dt class="d_decl">static SolidPattern <a name="fromRGBA"></a><span class="ddoc_psymbol">fromRGBA</span>(double <i>red</i>, double <i>green</i>, double <i>blue</i>, double <i>alpha</i>);
<br>static SolidPattern <a name="fromRGBA"></a><span class="ddoc_psymbol">fromRGBA</span>(RGBA <i>rgba</i>);
</dt>
<dd>Creates a new <span class="d_inlinecode">SolidPattern</span> corresponding to a translucent color.
 The color components are floating point numbers in the range 0 to 1.
 If the values passed in are outside that range, they will be clamped.<p></p>

</dd>
<dt class="d_decl">RGBA <a name="getRGBA"></a><span class="ddoc_psymbol">getRGBA</span>();
</dt>
<dd>Gets the solid color for a solid color pattern.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">class <a name="SurfacePattern"></a><span class="ddoc_psymbol">SurfacePattern</span>: cairo.cairo.Pattern;
</dt>
<dd>A surface pattern.
<p></p>
Use the  constructor to create an
 instance.<p></p>

<dl><dt class="d_decl">this(cairo_pattern_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">SurfacePattern</span> from a existing <span class="d_inlinecode">cairo_pattern_t*</span>.
 SurfacePattern is a garbage collected class. It will call <span class="d_inlinecode">cairo_pattern_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">this(Surface <i>surface</i>);
</dt>
<dd>Create a new <span class="d_inlinecode">SurfacePattern</span> for the given <i>surface</i>.<p></p>

</dd>
<dt class="d_decl">Surface <a name="getSurface"></a><span class="ddoc_psymbol">getSurface</span>();
</dt>
<dd>Gets the <span class="d_inlinecode">Surface</span> of a SurfacePattern.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">class <a name="Gradient"></a><span class="ddoc_psymbol">Gradient</span>: cairo.cairo.Pattern;
</dt>
<dd>Base class for <span class="d_inlinecode">LinearGradient</span> and <span class="d_inlinecode">RadialGradient</span>.
<p></p>
It's not possible to create instances of this class.<p></p>

<dl><dt class="d_decl">this(cairo_pattern_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">Gradient</span> from a existing <span class="d_inlinecode">cairo_pattern_t*</span>.
 Gradient is a garbage collected class. It will call <span class="d_inlinecode">cairo_pattern_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">void <a name="addColorStopRGB"></a><span class="ddoc_psymbol">addColorStopRGB</span>(double <i>offset</i>, RGB <i>color</i>);
<br>void <a name="addColorStopRGB"></a><span class="ddoc_psymbol">addColorStopRGB</span>(double <i>offset</i>, double <i>red</i>, double <i>green</i>, double <i>blue</i>);
</dt>
<dd>Adds an opaque <i>color</i> stop to a gradient pattern. The <i>offset</i>
 specifies the location along the gradient's control vector.
 For example, a <span class="d_inlinecode">LinearGradient</span>'s control vector is from
 (x0,y0) to (x1,y1) while a <span class="d_inlinecode">RadialGradient</span>'s control vector is
 from any point on the start circle to the corresponding point
 on the end circle.
<p></p>
The <i>color</i> is specified in the same way as in <span class="d_inlinecode">context.setSourceRGB()</span>.
<p></p>

 If two (or more) stops are specified with identical <i>offset</i>
 values, they will be sorted according to the order in which the
 stops are added, (stops added earlier will compare less than
 stops added later). This can be useful for reliably making sharp
 <i>color</i> transitions instead of the typical blend.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>offset</i></td>
<td valign=top>an <i>offset</i> in the range [0.0 .. 1.0]</td></tr>
</table><p></p>
<b>Note:</b><br>
If the pattern is not a gradient pattern, (eg. a linear
 or radial pattern), then the pattern will be put into an error
 status with a status of CAIRO_STATUS_PATTERN_TYPE_MISMATCH.<p></p>

</dd>
<dt class="d_decl">void <a name="addColorStopRGBA"></a><span class="ddoc_psymbol">addColorStopRGBA</span>(double <i>offset</i>, RGBA <i>color</i>);
<br>void <a name="addColorStopRGBA"></a><span class="ddoc_psymbol">addColorStopRGBA</span>(double <i>offset</i>, double <i>red</i>, double <i>green</i>, double <i>blue</i>, double <i>alpha</i>);
</dt>
<dd>Adds a translucent <i>color</i> stop to a gradient pattern. The <i>offset</i>
 specifies the location along the gradient's control vector. For
 example, a linear gradient's control vector is from (x0,y0) to
 (x1,y1) while a radial gradient's control vector is from any point
 on the start circle to the corresponding point on the end circle.
<p></p>
The <i>color</i> is specified in the same way as in
 <span class="d_inlinecode">context.setSourceRGBA()</span>.
<p></p>

 If two (or more) stops are specified with identical <i>offset</i> values,
 they will be sorted according to the order in which the stops are added,
 (stops added earlier will compare less than stops added later).
 This can be useful for reliably making sharp <i>color</i> transitions
 instead of the typical blend.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>offset</i></td>
<td valign=top>an <i>offset</i> in the range [0.0 .. 1.0]</td></tr>
</table><p></p>
<b>Note:</b><br>
If the pattern is not a gradient pattern, (eg. a linear
 or radial pattern), then the pattern will be put into an error
 status with a status of CAIRO_STATUS_PATTERN_TYPE_MISMATCH.<p></p>

</dd>
<dt class="d_decl">int <a name="getColorStopCount"></a><span class="ddoc_psymbol">getColorStopCount</span>();
</dt>
<dd>Gets the number of color stops specified in the given gradient pattern.<p></p>

</dd>
<dt class="d_decl">void <a name="getColorStopRGBA"></a><span class="ddoc_psymbol">getColorStopRGBA</span>(int <i>index</i>, out double <i>offset</i>, out RGBA <i>color</i>);
</dt>
<dd>Gets the <i>color</i> and <i>offset</i> information at the given <i>index</i> for a
 gradient pattern. Values of <i>index</i> are 0 to 1 less than the number
 returned by <span class="d_inlinecode">getColorStopCount()</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>index</i></td>
<td valign=top><i>index</i> of the stop to return data for</td></tr>
<tr><td valign=top>double <i>offset</i></td>
<td valign=top>output: Returns the <i>offset</i> of the <i>color</i> stop</td></tr>
<tr><td valign=top>RGBA <i>color</i></td>
<td valign=top>output: Returns the <i>color</i> of the <i>color</i> stop</td></tr>
</table><p></p>
<b>TODO:</b><br>
Array/Range - like interface?<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">class <a name="LinearGradient"></a><span class="ddoc_psymbol">LinearGradient</span>: cairo.cairo.Gradient;
</dt>
<dd>A linear gradient.
<p></p>
Use the <span class="d_inlinecode">this(Point p1, Point p2)</span> constructor to create an
 instance.<p></p>

<dl><dt class="d_decl">this(cairo_pattern_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">LinearGradient</span> from a existing <span class="d_inlinecode">cairo_pattern_t*</span>.
 LinearGradient is a garbage collected class. It will call <span class="d_inlinecode">cairo_pattern_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">this(Point <i>p1</i>, Point <i>p2</i>);
<br>this(double <i>x1</i>, double <i>y1</i>, double <i>x2</i>, double <i>y2</i>);
</dt>
<dd>Create a new linear gradient <span class="d_inlinecode">Pattern</span> along the line defined
 by <i>p1</i> and <i>p2</i>. Before using the gradient pattern, a number of
 color stops should be defined using <span class="d_inlinecode">Gradient.addColorStopRGB()</span>
 or  <span class="d_inlinecode">Gradient.addColorStopRGBA()</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Point <i>p1</i></td>
<td valign=top>the start point</td></tr>
<tr><td valign=top>Point <i>p2</i></td>
<td valign=top>the end point</td></tr>
</table><p></p>
<b>Note:</b><br>
The coordinates here are in pattern space. For a new pattern,
 pattern space is identical to user space, but the relationship
 between the spaces can be changed with <span class="d_inlinecode">Pattern.setMatrix()</span>.<p></p>

</dd>
<dt class="d_decl">Point[2u] <a name="getLinearPoints"></a><span class="ddoc_psymbol">getLinearPoints</span>();
</dt>
<dd>Gets the gradient endpoints for a linear gradient.
<p></p>
<b>Returns:</b><br>Point[0] = the first point
<p></p>

 Point[1] = the second point<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">class <a name="RadialGradient"></a><span class="ddoc_psymbol">RadialGradient</span>: cairo.cairo.Gradient;
</dt>
<dd>A radial gradient.
<p></p>
Use the <span class="d_inlinecode">this(Point c0, double radius0, Point c1, double radius1)</span>
 constructor to create an instance.<p></p>

<dl><dt class="d_decl">this(cairo_pattern_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">RadialGradient</span> from a existing <span class="d_inlinecode">cairo_pattern_t*</span>.
 RadialGradient is a garbage collected class. It will call <span class="d_inlinecode">cairo_pattern_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">this(Point <i>c0</i>, double <i>radius0</i>, Point <i>c1</i>, double <i>radius1</i>);
<br>this(double <i>c0x</i>, double <i>c0y</i>, double <i>radius0</i>, double <i>c1x</i>, double <i>c1y</i>, double <i>radius1</i>);
</dt>
<dd>Creates a new radial gradient <span class="d_inlinecode">pattern</span> between the two
 circles defined by (<i>c0</i>, <i>radius0</i>) and (<i>c1</i>, <i>radius1</i>). Before
 using the gradient pattern, a number of color stops should
 be defined using <span class="d_inlinecode">Pattern.addColorStopRGB()</span> or
 <span class="d_inlinecode">Pattern.addColorStopRGBA()</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Point <i>c0</i></td>
<td valign=top>center of the start circle</td></tr>
<tr><td valign=top>double <i>radius0</i></td>
<td valign=top>radius of the start circle</td></tr>
<tr><td valign=top>Point <i>c1</i></td>
<td valign=top>center of the end circle</td></tr>
<tr><td valign=top>double <i>radius1</i></td>
<td valign=top>radius of the end circle</td></tr>
</table><p></p>
<b>Note:</b><br>
The coordinates here are in pattern space. For a new pattern,
 pattern space is identical to user space, but the relationship
 between the spaces can be changed with <span class="d_inlinecode">Pattern.setMatrix()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="getRadialCircles"></a><span class="ddoc_psymbol">getRadialCircles</span>(out Point <i>c0</i>, out Point <i>c1</i>, out double <i>radius0</i>, out double <i>radius1</i>);
</dt>
<dd>Gets the gradient endpoint circles for a radial gradient,
 each specified as a center coordinate and a radius.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">class <a name="Device"></a><span class="ddoc_psymbol">Device</span>;
</dt>
<dd>Devices are the abstraction Cairo employs for the rendering system used
 by a <span class="d_inlinecode">Surface</span>. You can get the device of a surface using
 <span class="d_inlinecode">Surface.getDevice()</span>.
<p></p>
Devices are created using custom functions specific to the rendering
 system you want to use. See the documentation for the surface types
 for those functions.
<p></p>

 An important function that devices fulfill is sharing access to the
 rendering system between Cairo and your application. If you want to access
 a device directly that you used to draw to with Cairo, you must first
 call <span class="d_inlinecode"><a name="Device"></a><span class="ddoc_psymbol">Device</span>.flush()</span> to ensure that Cairo finishes all operations
 on the device and resets it to a clean state.
<p></p>

 Cairo also provides the functions <span class="d_inlinecode"><a name="Device"></a><span class="ddoc_psymbol">Device</span>.acquire()</span> and
 <span class="d_inlinecode"><a name="Device"></a><span class="ddoc_psymbol">Device</span>.release()</span> to synchronize access to the rendering system
 in a multithreaded environment. This is done internally, but can also
 be used by applications.

<p></p>
<b>Note:</b><br>
Please refer to the documentation of each backend for additional usage
 requirements, guarantees provided, and interactions with existing surface
 API of the device functions for surfaces of that type.

<p></p>
<b>Examples:</b><br><pre class="d_code"> <span class="d_keyword">void</span> my_device_modifying_function(<span class="d_psymbol">Device</span> device)
 {
     <span class="d_comment">// Ensure the device is properly reset
</span>     device.flush();
     <span class="d_keyword">try</span>
     {
         <span class="d_comment">// Try to acquire the device
</span>         device.acquire();
     }
     <span class="d_keyword">catch</span>(CairoException e)
     {
         writeln(<span class="d_string">""</span>);
     }

     <span class="d_comment">// Release the device when done.
</span>     <span class="d_keyword">scope</span>(exit)
         device.release();

     <span class="d_comment">// Do the custom operations on the device here.
</span>     <span class="d_comment">// But do not call any Cairo functions that might acquire devices.
</span>
 }
</pre>
<p></p>

<dl><dt class="d_decl">protected final void <a name="checkError"></a><span class="ddoc_psymbol">checkError</span>();
</dt>
<dd>Method for use in subclasses.
 Calls <span class="d_inlinecode">cairo_device_status(nativePointer)</span> and throws
 an exception if the status isn't CAIRO_STATUS_SUCCESS<p></p>

</dd>
<dt class="d_decl">this(cairo_device_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">Device</span> from a existing <span class="d_inlinecode">cairo_device_t*</span>.
 Device is a garbage collected class. It will call <span class="d_inlinecode">cairo_pattern_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">void <a name="finish"></a><span class="ddoc_psymbol">finish</span>();
</dt>
<dd>This function finishes the device and drops all references to
 external resources. All surfaces, fonts and other objects created
 for this device will be finished, too. Further operations on
 the device will not affect the device but will instead trigger
 a CAIRO_STATUS_DEVICE_FINISHED exception.
<p></p>
When the reference count reaches zero, cairo will call <span class="d_inlinecode"><a name="finish"></a><span class="ddoc_psymbol">finish</span>()</span>
 if it hasn't been called already, before freeing the resources
 associated with the device.
<p></p>

 This function may acquire devices.

<p></p>
<span style="color:red">BUGS:</span><br>How does "All surfaces, fonts and other objects created
 for this device will be finished" interact with the cairoD?<p></p>

</dd>
<dt class="d_decl">void <a name="flush"></a><span class="ddoc_psymbol">flush</span>();
</dt>
<dd>Finish any pending operations for the device and also restore
 any temporary modifications cairo has made to the device's state.
 This function must be called before switching from using the
 device with Cairo to operating on it directly with native APIs.
 If the device doesn't support direct access, then this function does nothing.
<p></p>
This function may acquire devices.<p></p>

</dd>
<dt class="d_decl">DeviceType <a name="getType"></a><span class="ddoc_psymbol">getType</span>();
</dt>
<dd>This function returns the C type of a Device. See <span class="d_inlinecode">DeviceType</span>
 for available types.<p></p>

</dd>
<dt class="d_decl">void <a name="acquire"></a><span class="ddoc_psymbol">acquire</span>();
</dt>
<dd>Acquires the device for the current thread. This function will
 block until no other thread has acquired the device.
<p></p>
If no Exception is thrown, you successfully
 acquired the device. From now on your thread owns the device
 and no other thread will be able to <a name="acquire"></a><span class="ddoc_psymbol">acquire</span> it until a matching
 call to <span class="d_inlinecode">Device.release()</span>. It is allowed to recursively
 <a name="acquire"></a><span class="ddoc_psymbol">acquire</span> the device multiple times from the same thread.

<p></p>
<b>Note:</b><br>
You must never <a name="acquire"></a><span class="ddoc_psymbol">acquire</span> two different devices at the same time
 unless this is explicitly allowed. Otherwise the possibility
 of deadlocks exist.
<p></p>

 As various Cairo functions can <a name="acquire"></a><span class="ddoc_psymbol">acquire</span> devices when called,
 these functions may also cause deadlocks when you call them
 with an acquired device. So you must not have a device acquired
 when calling them. These functions are marked in the documentation.

<p></p>
<b>Throws:</b><br>An exception if the device is in an error state and could not
 be acquired. After a successful call to <a name="acquire"></a><span class="ddoc_psymbol">acquire</span>, a matching call
 to <span class="d_inlinecode">Device.release()</span> is required.<p></p>

</dd>
<dt class="d_decl">void <a name="release"></a><span class="ddoc_psymbol">release</span>();
</dt>
<dd>Releases a device previously acquired using <span class="d_inlinecode">Device.acquire()</span>.
 See that function for details.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">class <a name="Surface"></a><span class="ddoc_psymbol">Surface</span>;
</dt>
<dd><a name="Surface"></a><span class="ddoc_psymbol">Surface</span> is the abstract type representing all different drawing targets
 that cairo can render to. The actual drawings are performed using a cairo context.
<p></p>
A cairo surface is created by using backend-specific classes,
 typically of the form <span class="d_inlinecode">BackendSurface</span>.
<p></p>

 Most surface types allow accessing the surface without using Cairo
 functions. If you do this, keep in mind that it is mandatory that
 you call <span class="d_inlinecode"><a name="Surface"></a><span class="ddoc_psymbol">Surface</span>.flush()</span> before reading from or writing to the
 surface and that you must use <span class="d_inlinecode"><a name="Surface"></a><span class="ddoc_psymbol">Surface</span>.markDirty()</span> after modifying it.<p></p>

<dl><dt class="d_decl">protected final void <a name="checkError"></a><span class="ddoc_psymbol">checkError</span>();
</dt>
<dd>Method for use in subclasses.
 Calls <span class="d_inlinecode">cairo_surface_status(nativePointer)</span> and throws
 an exception if the status isn't CAIRO_STATUS_SUCCESS<p></p>

</dd>
<dt class="d_decl">this(cairo_surface_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">Surface</span> from a existing <span class="d_inlinecode">cairo_surface_t*</span>.
 Surface is a garbage collected class. It will call <span class="d_inlinecode">cairo_surface_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">static Surface <a name="createFromNative"></a><span class="ddoc_psymbol">createFromNative</span>(cairo_surface_t* <i>ptr</i>, bool <i>adjRefCount</i> = true);
</dt>
<dd>The <a name="createFromNative"></a><span class="ddoc_psymbol">createFromNative</span> method for the Surface classes.
 See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative">https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative</a>
 for more information.
<p></p>
<b>Warning:</b><br>
<span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">static Surface <a name="createSimilar"></a><span class="ddoc_psymbol">createSimilar</span>(Surface <i>other</i>, Content <i>content</i>, int <i>width</i>, int <i>height</i>);
</dt>
<dd>Create a new surface that is as compatible as possible with
 an existing surface. For example the new surface will have the
 same fallback resolution and font options as <i>other</i>. Generally,
 the new surface will also use the same backend as <i>other</i>, unless
 that is not possible for some reason. The type of the returned
 surface may be examined with <span class="d_inlinecode">Surface.getType()</span>.
<p></p>
Initially the surface contents are all 0 (transparent if
 contents have transparency, black otherwise.)

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Surface <i>other</i></td>
<td valign=top>an existing surface used to select the backend of the new surface</td></tr>
<tr><td valign=top>Content <i>content</i></td>
<td valign=top>the <i>content</i> for the new surface</td></tr>
<tr><td valign=top>int <i>width</i></td>
<td valign=top><i>width</i> of the new surface, (in device-space units)</td></tr>
<tr><td valign=top>int <i>height</i></td>
<td valign=top><i>height</i> of the new surface (in device-space units)</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">static Surface <a name="createForRectangle"></a><span class="ddoc_psymbol">createForRectangle</span>(Surface <i>target</i>, Rectangle!(double) <i>rect</i>);
</dt>
<dd>Create a new surface that is a rectangle within the <i>target</i> surface.
 All operations drawn to this surface are then clipped and translated
 onto the <i>target</i> surface. Nothing drawn via this sub-surface
 outside of its bounds is drawn onto the <i>target</i> surface,
 making this a useful method for passing constrained child
 surfaces to library routines that draw directly onto the parent
 surface, i.e. with no further backend allocations, double
 buffering or copies.
<p></p>
<b>Note:</b><br>
The semantics of subsurfaces have not been finalized yet unless
 the rectangle is in full device units, is contained within
 the extents of the <i>target</i> surface, and the <i>target</i> or
 subsurface's device transforms are not changed.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Surface <i>target</i></td>
<td valign=top>an existing surface for which the sub-surface will point to</td></tr>
<tr><td valign=top>Rectangle!(double) <i>rect</i></td>
<td valign=top>location of the subsurface</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="finish"></a><span class="ddoc_psymbol">finish</span>();
</dt>
<dd>This function finishes the surface and drops all references
 to external resources. For example, for the Xlib backend it
 means that cairo will no longer access the drawable, which
 can be freed. After calling <span class="d_inlinecode">Surface.<a name="finish"></a><span class="ddoc_psymbol">finish</span>()</span> the only
 valid operations on a surface are getting and setting user,
 referencing and destroying, and flushing and finishing it.
<p></p>
Further drawing to the surface will not affect the surface
 but will instead trigger a CAIRO_STATUS_SURFACE_FINISHED exception.
<p></p>

 When the reference count id decreased to zero, cairo will call
 <span class="d_inlinecode">Surface.<a name="finish"></a><span class="ddoc_psymbol">finish</span>()</span> if it hasn't been called already, before
 freeing the resources associated with the surface.<p></p>

</dd>
<dt class="d_decl">void <a name="flush"></a><span class="ddoc_psymbol">flush</span>();
</dt>
<dd>Do any pending drawing for the surface and also restore any temporary
 modifications cairo has made to the surface's state. This function
 must be called before switching from drawing on the surface
 with cairo to drawing on it directly with native APIs. If the
 surface doesn't support direct access, then this function does
 nothing.<p></p>

</dd>
<dt class="d_decl">Device <a name="getDevice"></a><span class="ddoc_psymbol">getDevice</span>();
</dt>
<dd>This function returns the device for a surface. See <span class="d_inlinecode">Device</span>.<p></p>

</dd>
<dt class="d_decl">FontOptions <a name="getFontOptions"></a><span class="ddoc_psymbol">getFontOptions</span>();
</dt>
<dd>Retrieves the default font rendering options for the surface.
 This allows display surfaces to report the correct subpixel
 order for rendering on them, print surfaces to disable hinting
 of metrics and so forth. The result can then be used with
 .<p></p>

</dd>
<dt class="d_decl">Content <a name="getContent"></a><span class="ddoc_psymbol">getContent</span>();
</dt>
<dd>This function returns the content type of surface which indicates
 whether the surface contains color and/or alpha information.
 See <span class="d_inlinecode">Content</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="markDirty"></a><span class="ddoc_psymbol">markDirty</span>();
</dt>
<dd>Tells cairo that drawing has been done to surface using means
 other than cairo, and that cairo should reread any cached areas.
 Note that you must call <span class="d_inlinecode">Surface.flush()</span> before doing such drawing.<p></p>

</dd>
<dt class="d_decl">void <a name="markDirtyRectangle"></a><span class="ddoc_psymbol">markDirtyRectangle</span>(int <i>x</i>, int <i>y</i>, int <i>width</i>, int <i>height</i>);
<br>void <a name="markDirtyRectangle"></a><span class="ddoc_psymbol">markDirtyRectangle</span>(Rectangle!(int) <i>rect</i>);
</dt>
<dd>Like <span class="d_inlinecode">Surface.markDirty()</span>, but drawing has been done only
 to the specified rectangle, so that cairo can retain cached
 contents for other parts of the surface.
<p></p>
Any cached clip set on the surface will be reset by this function,
 to make sure that future cairo calls have the clip set that they expect.<p></p>

</dd>
<dt class="d_decl">void <a name="setDeviceOffset"></a><span class="ddoc_psymbol">setDeviceOffset</span>(double <i>x_offset</i>, double <i>y_offset</i>);
<br>void <a name="setDeviceOffset"></a><span class="ddoc_psymbol">setDeviceOffset</span>(Point <i>offset</i>);
</dt>
<dd>Sets an offset that is added to the device coordinates determined
 by the CTM when drawing to surface. One use case for this function
 is when we want to create a <span class="d_inlinecode">Surface</span> that redirects drawing
 for a portion of an onscreen surface to an offscreen surface
 in a way that is completely invisible to the user of the cairo API.
 Setting a transformation via <span class="d_inlinecode">Context.translate()</span> isn't sufficient
 to do this, since functions like <span class="d_inlinecode">Context.deviceToUser()</span> will
 expose the hidden offset.
<p></p>
<b>Note:</b><br>
the offset affects drawing to the surface as well as using the
 surface in a source pattern.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>x_offset</i></td>
<td valign=top>the offset in the X direction, in device units</td></tr>
<tr><td valign=top>double <i>y_offset</i></td>
<td valign=top>the offset in the Y direction, in device units</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">Point <a name="getDeviceOffset"></a><span class="ddoc_psymbol">getDeviceOffset</span>();
</dt>
<dd>This function returns the previous device offset set
 by <span class="d_inlinecode">Surface.setDeviceOffset()</span>.
<p></p>
<b>Returns:</b><br>Offset in device units<p></p>

</dd>
<dt class="d_decl">void <a name="setFallbackResolution"></a><span class="ddoc_psymbol">setFallbackResolution</span>(Resolution <i>res</i>);
</dt>
<dd>Set the horizontal and vertical resolution for image fallbacks.
<p></p>
When certain operations aren't supported natively by a backend,
 cairo will fallback by rendering operations to an image and
 then overlaying that image onto the output. For backends that
 are natively vector-oriented, this function can be used to set
 the resolution used for these image fallbacks, (larger values
 will result in more detailed images, but also larger file sizes).
<p></p>

 Some examples of natively vector-oriented backends are the ps,
 pdf, and svg backends.
<p></p>

 For backends that are natively raster-oriented, image fallbacks
 are still possible, but they are always performed at the native
 device resolution. So this function has no effect on those backends.

<p></p>
<b>Note:</b><br>
The fallback resolution only takes effect at the time of
 completing a page (with <span class="d_inlinecode">Context.showPage()</span> or <span class="d_inlinecode">Context.copyPage()</span>)
 so there is currently no way to have more than one fallback
 resolution in effect on a single page.
<p></p>

 The default fallback resoultion is 300 pixels per inch in both
 dimensions.<p></p>

</dd>
<dt class="d_decl">Resolution <a name="getFallbackResolution"></a><span class="ddoc_psymbol">getFallbackResolution</span>();
</dt>
<dd>This function returns the previous fallback resolution set
 by <span class="d_inlinecode">setFallbackResolution()</span>, or default
 fallback resolution if never set.<p></p>

</dd>
<dt class="d_decl">SurfaceType <a name="getType"></a><span class="ddoc_psymbol">getType</span>();
</dt>
<dd>This function returns the C type of a Surface. See <span class="d_inlinecode">SurfaceType</span>
 for available types.<p></p>

</dd>
<dt class="d_decl">void <a name="copyPage"></a><span class="ddoc_psymbol">copyPage</span>();
</dt>
<dd>Emits the current page for backends that support multiple pages,
 but doesn't clear it, so that the contents of the current page
 will be retained for the next page. Use <span class="d_inlinecode">Surface.showPage()</span>
 if you want to get an empty page after the emission.
<p></p>
There is a convenience function for this that can be called on
 a <span class="d_inlinecode">Context</span>, namely <span class="d_inlinecode">Context.<a name="copyPage"></a><span class="ddoc_psymbol">copyPage</span>()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="showPage"></a><span class="ddoc_psymbol">showPage</span>();
</dt>
<dd>Emits and clears the current page for backends that support
 multiple pages. Use <span class="d_inlinecode">Surface.copyPage()</span> if you don't
 want to clear the page.
<p></p>
There is a convenience function for this that can be called on
 a <span class="d_inlinecode">Context</span>, namely <span class="d_inlinecode">Context.<a name="showPage"></a><span class="ddoc_psymbol">showPage</span>()</span>.<p></p>

</dd>
<dt class="d_decl">bool <a name="hasShowTextGlyphs"></a><span class="ddoc_psymbol">hasShowTextGlyphs</span>();
</dt>
<dd>Returns whether the surface supports sophisticated <span class="d_inlinecode">showTextGlyphs()</span>
 operations. That is, whether it actually uses the provided text
 and cluster data to a <span class="d_inlinecode">showTextGlyphs()</span> call.
<p></p>
<b>Note:</b><br>
Even if this function returns <b>false</b>, a <span class="d_inlinecode">showTextGlyphs()</span>
 operation targeted at surface will still succeed. It just will
 act like a <span class="d_inlinecode">showGlyphs()</span> operation. Users can use this
 function to avoid computing UTF-8 text and cluster mapping
 if the target surface does not use it.

<p></p>
<b>Returns:</b><br><b>true</b> if surface supports <span class="d_inlinecode">showTextGlyphs()</span>, <b>false</b> otherwise<p></p>

</dd>
<dt class="d_decl">void <a name="setMimeData"></a><span class="ddoc_psymbol">setMimeData</span>(string <i>type</i>, ubyte* <i>data</i>, ulong <i>length</i>, cairo_destroy_func_t <i>destroy</i>, void* <i>closure</i>);
</dt>
<dd>Attach an image in the format mime_type to surface. To remove
 the <i>data</i> from a surface, call this function with same mime
 <i>type</i> and NULL for <i>data</i>.
<p></p>
The attached image (or filename) <i>data</i> can later be used by
 backends which support it (currently: PDF, PS, SVG and Win32
 Printing surfaces) to emit this <i>data</i> instead of making a snapshot
 of the surface. This approach tends to be faster and requires
 less memory and disk space.
<p></p>

 The recognized MIME types are the following: CAIRO_MIME_TYPE_JPEG,
 CAIRO_MIME_TYPE_PNG, CAIRO_MIME_TYPE_JP2, CAIRO_MIME_TYPE_URI.
<p></p>

 See corresponding backend surface docs for details about which
 MIME types it can handle.

<p></p>
<b>Caution:</b><br>
the associated MIME <i>data</i> will be discarded if you draw
 on the surface afterwards. Use this function with care.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>mime_type</td>
<td valign=top>the MIME <i>type</i> of the image <i>data</i></td></tr>
<tr><td valign=top>ubyte* <i>data</i></td>
<td valign=top>the image <i>data</i> to attach to the surface</td></tr>
<tr><td valign=top>ulong <i>length</i></td>
<td valign=top>the <i>length</i> of the image <i>data</i></td></tr>
<tr><td valign=top>cairo_destroy_func_t <i>destroy</i></td>
<td valign=top>a cairo_destroy_func_t which will be called when the
     surface is destroyed or when new image <i>data</i> is attached using
     the same mime <i>type</i>.</td></tr>
<tr><td valign=top>void* <i>closure</i></td>
<td valign=top>the <i>data</i> to be passed to the <i>destroy</i> notifier</td></tr>
</table><p></p>
<b>Throws:</b><br>OutOfMemoryError if a slot could not be allocated for the user <i>data</i>.

<p></p>
<b>TODO:</b><br>
More D-like API

<p></p>
<b>Note:</b><br>
<span style="color:red">Only use this if you know what your doing! Make sure you get
 memory management of the passed in <i>data</i> right!</span><p></p>

</dd>
<dt class="d_decl">void <a name="getMimeData"></a><span class="ddoc_psymbol">getMimeData</span>(string <i>type</i>, out ubyte* <i>data</i>, out ulong <i>length</i>);
</dt>
<dd>Return mime <i>data</i> previously attached to surface using the
 specified mime <i>type</i>. If no <i>data</i> has been attached with the given
 mime <i>type</i>, <i>data</i> is set <b>null</b>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>type</i></td>
<td valign=top>the mime <i>type</i> of the image <i>data</i></td></tr>
</table><p></p>
<b>TODO:</b><br>
More D-like API

<p></p>
<b>Note:</b><br>
<span style="color:red">Only use this if you know what your doing! Make sure you get
 memory management of the <i>data</i> right!</span><p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">int <a name="formatStrideForWidth"></a><span class="ddoc_psymbol">formatStrideForWidth</span>(Format <i>format</i>, int <i>width</i>);
</dt>
<dd>This function provides a stride value that will respect all alignment
 requirements of the accelerated image-rendering code within cairo.
<p></p>
<b>Examples:</b><br><pre class="d_code"> <span class="d_keyword">int</span> stride;
 <span class="d_keyword">ubyte</span>[] data;
 Surface surface;

 stride = <span class="d_psymbol">formatStrideForWidth</span>(<span class="d_param">format</span>, <span class="d_param">width</span>);
 data = <span class="d_keyword">new</span> <span class="d_keyword">ubyte</span>[](stride * height); <span class="d_comment">//could also use malloc
</span> surface = <span class="d_keyword">new</span> ImageSurface(data, <span class="d_param">format</span>, <span class="d_param">width</span>, height, stride);
</pre>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Format <i>format</i></td>
<td valign=top>The desired Format of an image surface to be created</td></tr>
<tr><td valign=top>int <i>width</i></td>
<td valign=top>The desired <i>width</i> of an image surface to be created</td></tr>
</table><p></p>
<b>Returns:</b><br>the appropriate stride to use given the desired <i>format</i> and <i>width</i>, or
 -1 if either the <i>format</i> is invalid or the <i>width</i> too large.<p></p>

</dd>
<dt class="d_decl">class <a name="ImageSurface"></a><span class="ddoc_psymbol">ImageSurface</span>: cairo.cairo.Surface;
</dt>
<dd>Image Surfaces — Rendering to memory buffers
<p></p>
Image surfaces provide the ability to render to memory buffers either
 allocated by cairo or by the calling code. The supported image
 formats are those defined in <span class="d_inlinecode">Format</span>.<p></p>

<dl><dt class="d_decl">this(cairo_surface_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">ImageSurface</span> from a existing <span class="d_inlinecode">cairo_surface_t*</span>.
 ImageSurface is a garbage collected class. It will call <span class="d_inlinecode">cairo_surface_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">this(Format <i>format</i>, int <i>width</i>, int <i>height</i>);
</dt>
<dd>Creates an image surface of the specified <i>format</i> and dimensions.
 Initially the surface contents are all 0. (Specifically, within
 each pixel, each color or alpha channel belonging to <i>format</i> will
 be 0. The contents of bits within a pixel, but not belonging
 to the given <i>format</i> are undefined).
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Format <i>format</i></td>
<td valign=top><i>format</i> of pixels in the surface to create</td></tr>
<tr><td valign=top>int <i>width</i></td>
<td valign=top><i>width</i> of the surface, in pixels</td></tr>
<tr><td valign=top>int <i>height</i></td>
<td valign=top><i>height</i> of the surface, in pixels</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">this(ubyte[] <i>data</i>, Format <i>format</i>, int <i>width</i>, int <i>height</i>, int <i>stride</i>);
</dt>
<dd>Creates an image surface for the provided pixel <i>data</i>.
 <span style="color:red">The output buffer must be kept around until the <span class="d_inlinecode">Surface</span>
 is destroyed or <span class="d_inlinecode">Surface.finish()</span> is called on the surface.</span>
 The initial contents of <i>data</i> will be used as the initial image
 contents; you must explicitly clear the buffer, using, for
 example, <span class="d_inlinecode">Context.rectangle()</span> and <span class="d_inlinecode">Context.fill()</span> if you
 want it cleared.
<p></p>
Note that the <i>stride</i> may be larger than <i>width</i>*bytes_per_pixel
 to provide proper alignment for each pixel and row.
 This alignment is required to allow high-performance rendering
 within cairo. The correct way to obtain a legal <i>stride</i> value is
 to call <span class="d_inlinecode">formatStrideForWidth</span> with the desired <i>format</i> and
 maximum image <i>width</i> value, and then use the resulting <i>stride</i>
 value to allocate the <i>data</i> and to create the image surface.
 See <span class="d_inlinecode">formatStrideForWidth</span> for example code.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>ubyte[] <i>data</i></td>
<td valign=top>a pointer to a buffer supplied by the application in
     which to write contents. This pointer must be suitably aligned
     for any kind of variable, (for example, a pointer returned by malloc).</td></tr>
<tr><td valign=top>Format <i>format</i></td>
<td valign=top>the <i>format</i> of pixels in the buffer</td></tr>
<tr><td valign=top>int <i>width</i></td>
<td valign=top>the <i>width</i> of the image to be stored in the buffer</td></tr>
<tr><td valign=top>int <i>height</i></td>
<td valign=top>the <i>height</i> of the image to be stored in the buffer</td></tr>
<tr><td valign=top>int <i>stride</i></td>
<td valign=top>the number of bytes between the start of rows in the
     buffer as allocated. This value should always be computed
     by <span class="d_inlinecode">formatStrideForWidth</span> before allocating
     the <i>data</i> buffer.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">ubyte* <a name="getData"></a><span class="ddoc_psymbol">getData</span>();
</dt>
<dd>Get a pointer to the data of the image surface,
 for direct inspection or modification.
<p></p>
<b>Warning:</b><br>
There's no way to get the size of the buffer from
 cairo, so you'll only get a <span class="d_inlinecode">ubyte*</span>. Be careful!<p></p>

</dd>
<dt class="d_decl">Format <a name="getFormat"></a><span class="ddoc_psymbol">getFormat</span>();
</dt>
<dd>Get the format of the surface.<p></p>

</dd>
<dt class="d_decl">int <a name="getWidth"></a><span class="ddoc_psymbol">getWidth</span>();
</dt>
<dd>Get the width of the image surface in pixels.<p></p>

</dd>
<dt class="d_decl">int <a name="getHeight"></a><span class="ddoc_psymbol">getHeight</span>();
</dt>
<dd>Get the height of the image surface in pixels.<p></p>

</dd>
<dt class="d_decl">int <a name="getStride"></a><span class="ddoc_psymbol">getStride</span>();
</dt>
<dd>Get the stride of the image surface in bytes.<p></p>

</dd>
<dt class="d_decl">static ImageSurface <a name="fromPng"></a><span class="ddoc_psymbol">fromPng</span>(string <i>file</i>);
</dt>
<dd>Creates a new image surface and initializes the contents to the given PNG <i>file</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>file</i></td>
<td valign=top>name of PNG <i>file</i> to load</td></tr>
</table><p></p>
<b>Note:</b><br>
Only available if cairo, cairoD and the cairoD user
 code were compiled with "version=CAIRO_HAS_PNG_FUNCTIONS"<p></p>

</dd>
<dt class="d_decl">void <a name="writeToPNG"></a><span class="ddoc_psymbol">writeToPNG</span>(string <i>file</i>);
</dt>
<dd>Writes the contents of surface to a new <i>file</i> filename as a PNG image.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>file</i></td>
<td valign=top>the name of a <i>file</i> to write to</td></tr>
</table><p></p>
<b>Note:</b><br>
Only available if cairo, cairoD and the cairoD user
 code were compiled with "version=CAIRO_HAS_PNG_FUNCTIONS"<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="Context"></a><span class="ddoc_psymbol">Context</span>;
</dt>
<dd>The cairo drawing context
<p></p>
<span class="d_inlinecode"><a name="Context"></a><span class="ddoc_psymbol">Context</span></span> is the main object used when drawing with cairo. To draw
 with cairo, you create a <span class="d_inlinecode"><a name="Context"></a><span class="ddoc_psymbol">Context</span></span>, set the target surface, and drawing
 options for the <span class="d_inlinecode"><a name="Context"></a><span class="ddoc_psymbol">Context</span></span>, create shapes with functions like <span class="d_inlinecode"><a name="Context"></a><span class="ddoc_psymbol">Context</span>.moveTo()</span>
 and <span class="d_inlinecode"><a name="Context"></a><span class="ddoc_psymbol">Context</span>.lineTo()</span>, and then draw shapes with <span class="d_inlinecode"><a name="Context"></a><span class="ddoc_psymbol">Context</span>.stroke()</span>
 or <span class="d_inlinecode"><a name="Context"></a><span class="ddoc_psymbol">Context</span>.fill()</span>.
<p></p>

 <span class="d_inlinecode"><a name="Context"></a><span class="ddoc_psymbol">Context</span></span>'s can be pushed to a stack via <span class="d_inlinecode"><a name="Context"></a><span class="ddoc_psymbol">Context</span>.save()</span>.
 They may then safely be changed, without loosing the current state.
 Use <span class="d_inlinecode"><a name="Context"></a><span class="ddoc_psymbol">Context</span>.restore()</span> to restore to the saved state.<p></p>

<dl><dt class="d_decl">cairo_t* <a name="nativePointer"></a><span class="ddoc_psymbol">nativePointer</span>;
</dt>
<dd>The underlying <span class="d_inlinecode">cairo_t*</span> handle<p></p>

</dd>
<dt class="d_decl">bool <a name="debugging"></a><span class="ddoc_psymbol">debugging</span>;
</dt>
<dd>Enable / disable memory management <a name="debugging"></a><span class="ddoc_psymbol">debugging</span> for this Context
 instance. Only available if both cairoD and the cairoD user
 code were compiled with "debug=RefCounted"
<p></p>
Output is written to stdout, see
 <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging">https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging</a>
 for more information<p></p>

</dd>
<dt class="d_decl">void <a name="dispose"></a><span class="ddoc_psymbol">dispose</span>();
</dt>
<dd>Explicitly drecrease the reference count.
<p></p>
See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#2.1-structs">https://github.com/jpf91/cairoD/wiki/Memory-Management#2.1-structs</a>
 for more information.<p></p>

</dd>
<dt class="d_decl">void <a name="opAssign"></a><span class="ddoc_psymbol">opAssign</span>(typeof(this) <i>rhs</i>);
</dt>
<dd>Assignment operator<p></p>

</dd>
<dt class="d_decl">this(Surface <i>target</i>);
</dt>
<dd>Creates a new <span class="d_inlinecode">Context</span> with all graphics state parameters set
 to default values and with <i>target</i> as a <i>target</i> surface. The
 <i>target</i> surface should be constructed with a backend-specific
 function such as <span class="d_inlinecode">new ImageSurface()</span>.
<p></p>
This function references <i>target</i>, so you can immediately call
 <span class="d_inlinecode">Surface.dispose()</span> on it if you don't need to maintain
 a separate reference to it.<p></p>

</dd>
<dt class="d_decl">this(cairo_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">Context</span> from a existing <span class="d_inlinecode">cairo_t*</span>.
 Context is a garbage collected class. It will call <span class="d_inlinecode">cairo_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">void <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd>Makes a copy of the current state of cr and saves it on an
 internal stack of saved states for cr. When <span class="d_inlinecode">Context.restore()</span>
 is called, cr will be restored to the saved state. Multiple
 calls to <span class="d_inlinecode">Context.<a name="save"></a><span class="ddoc_psymbol">save</span>()</span> and  <span class="d_inlinecode">Context.restore()</span> can be nested; each
 call to  <span class="d_inlinecode">Context.restore()</span> restores the state from the matching
 paired <span class="d_inlinecode">Context.<a name="save"></a><span class="ddoc_psymbol">save</span>()</span>.
<p></p>
It isn't necessary to clear all saved states before a <span class="d_inlinecode">Context</span>
 is freed. If the reference count of a <span class="d_inlinecode">Context</span> drops to zero
 , any saved states will be freed along with the <span class="d_inlinecode">Context</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="restore"></a><span class="ddoc_psymbol">restore</span>();
</dt>
<dd>Restores cr to the state saved by a preceding call to
 <span class="d_inlinecode">Context.save()</span> and removes that state from the stack of
 saved states.<p></p>

</dd>
<dt class="d_decl">Surface <a name="getTarget"></a><span class="ddoc_psymbol">getTarget</span>();
</dt>
<dd>Gets the target surface for the cairo context as passed to
 the constructor.<p></p>

</dd>
<dt class="d_decl">void <a name="pushGroup"></a><span class="ddoc_psymbol">pushGroup</span>();
</dt>
<dd>Temporarily redirects drawing to an intermediate surface known
 as a group. The redirection lasts until the group is completed
 by a call to <span class="d_inlinecode">Context.popGroup()</span> or <span class="d_inlinecode">Context.popGroupToSource()</span>.
 These calls provide the result of any drawing to the group
 as a pattern, (either as an explicit object, or set as the
 source pattern).
<p></p>
This group functionality can be convenient for performing
 intermediate compositing. One common use of a group is to render
 objects as opaque within the group, (so that they occlude each other),
 and then blend the result with translucence onto the destination.
<p></p>

 Groups can be nested arbitrarily deep by making balanced calls
 to <span class="d_inlinecode">Context.pushGgroup()</span>/<span class="d_inlinecode">Context.popGroup()</span>. Each call pushes/pops
 the new target group onto/from a stack.
<p></p>

 The <span class="d_inlinecode">Context.<a name="pushGroup"></a><span class="ddoc_psymbol">pushGroup</span>()</span> function calls <span class="d_inlinecode">Context.save()</span> so that any
 changes to the graphics state will not be visible outside the
 group, (the <span class="d_inlinecode">Context.popGroup</span> functions call <span class="d_inlinecode">Context.restore()</span>).
<p></p>

 By default the intermediate group will have a content type of
 CAIRO_CONTENT_COLOR_ALPHA. Other content types can be chosen
 for the group by using <span class="d_inlinecode">Context.<a name="pushGroup"></a><span class="ddoc_psymbol">pushGroup</span>(Content)</span> instead.
<p></p>

 As an example, here is how one might fill and stroke a path with
 translucence, but without any portion of the fill being visible
 under the stroke:
<pre class="d_code"> cr.<span class="d_psymbol">pushGroup</span>();
 cr.setSource(fill_pattern);
 cr.fillPreserve();
 cr.setSource(stroke_pattern);
 cr.stroke();
 cr.popGroupToSource();
 cr.paintWithAlpha(alpha);
</pre>
<p></p>

</dd>
<dt class="d_decl">void <a name="pushGroup"></a><span class="ddoc_psymbol">pushGroup</span>(Content <i>cont</i>);
</dt>
<dd>Temporarily redirects drawing to an intermediate surface known
 as a group. The redirection lasts until the group is completed
 by a call to <span class="d_inlinecode">Context.popGroup()</span> or <span class="d_inlinecode">Context.popGroupToSource()</span>.
 These calls provide the result of any drawing to the group as
 a pattern, (either as an explicit object, or set as the source
 pattern).
<p></p>
The group will have a content type of content. The ability to
 control this content type is the only distinction between this
 function and <span class="d_inlinecode">Context.<a name="pushGroup"></a><span class="ddoc_psymbol">pushGroup</span>()</span> which you should see for a more
 detailed description of group rendering.<p></p>

</dd>
<dt class="d_decl">Pattern <a name="popGroup"></a><span class="ddoc_psymbol">popGroup</span>();
</dt>
<dd>Terminates the redirection begun by a call to <span class="d_inlinecode">Context.pushGroup()</span>
 or <span class="d_inlinecode">Context.pushGroup(Content)</span> and returns a new pattern
 containing the results of all drawing operations performed to
 the group.
<p></p>
The <span class="d_inlinecode">Context.<a name="popGroup"></a><span class="ddoc_psymbol">popGroup</span>()</span> function calls <span class="d_inlinecode">Context.restore()</span>, (balancing
 a call to <span class="d_inlinecode">Context.save()</span> by the <span class="d_inlinecode">Context.pushGroup()</span> function), so that any
 changes to the graphics state will not be visible outside the group.<p></p>

</dd>
<dt class="d_decl">void <a name="popGroupToSource"></a><span class="ddoc_psymbol">popGroupToSource</span>();
</dt>
<dd>Terminates the redirection begun by a call to <span class="d_inlinecode">Context.pushGroup()</span>
 or <span class="d_inlinecode">Context.pushGroup(Content)</span> and installs the resulting
 pattern as the source pattern in the given cairo context.
<p></p>
The behavior of this function is equivalent to the sequence
 of operations:
<pre class="d_code"> Pattern group = cr.popGroup();
 cr.setSource(group);
 group.dispose();
</pre>
 but is more convenient as their is no need for a variable to
 store the short-lived pointer to the pattern.
<p></p>

 The <span class="d_inlinecode">Context.popGroup()</span> function calls <span class="d_inlinecode">Context.restore()</span>,
 (balancing a call to <span class="d_inlinecode">Context.save()</span> by the <span class="d_inlinecode">Context.pushGroup()</span> function),
 so that any changes to the graphics state will not be
 visible outside the group.<p></p>

</dd>
<dt class="d_decl">Surface <a name="getGroupTarget"></a><span class="ddoc_psymbol">getGroupTarget</span>();
</dt>
<dd>Gets the current destination surface for the context.
 This is either the original target surface as passed to
 the Context constructor or the target surface for the current
 group as started by the most recent call to
  <span class="d_inlinecode">Context.pushGroup()</span> or  <span class="d_inlinecode">Context.pushGroup(Content)</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="setSourceRGB"></a><span class="ddoc_psymbol">setSourceRGB</span>(double <i>red</i>, double <i>green</i>, double <i>blue</i>);
<br>void <a name="setSourceRGB"></a><span class="ddoc_psymbol">setSourceRGB</span>(RGB <i>rgb</i>);
</dt>
<dd>Sets the source pattern within cr to an opaque color.
 This opaque color will then be used for any subsequent
 drawing operation until a new source pattern is set.
<p></p>
The color components are floating point numbers in the range
 0 to 1. If the values passed in are outside that range,
 they will be clamped.
<p></p>

 The default source pattern is opaque black,
 (that is, it is equivalent to <a name="setSourceRGB"></a><span class="ddoc_psymbol">setSourceRGB</span>(0.0, 0.0, 0.0)).<p></p>

</dd>
<dt class="d_decl">void <a name="setSourceRGBA"></a><span class="ddoc_psymbol">setSourceRGBA</span>(double <i>red</i>, double <i>green</i>, double <i>blue</i>, double <i>alpha</i>);
<br>void <a name="setSourceRGBA"></a><span class="ddoc_psymbol">setSourceRGBA</span>(RGBA <i>rgba</i>);
</dt>
<dd>Sets the source pattern within cr to a translucent color.
 This color will then be used for any subsequent drawing
 operation until a new source pattern is set.
<p></p>
The color and <i>alpha</i> components are floating point numbers in
 the range 0 to 1. If the values passed in are outside that
 range, they will be clamped.
<p></p>

 The default source pattern is opaque black, (that is, it is
 equivalent to <a name="setSourceRGBA"></a><span class="ddoc_psymbol">setSourceRGBA</span>(0.0, 0.0, 0.0, 1.0)).<p></p>

</dd>
<dt class="d_decl">void <a name="setSource"></a><span class="ddoc_psymbol">setSource</span>(Pattern <i>pat</i>);
</dt>
<dd>Sets the source pattern within cr to source. This pattern will
 then be used for any subsequent drawing operation until
 a new source pattern is set.
<p></p>
<b>Note:</b><br>
The pattern's transformation matrix will be locked to
 the user space in effect at the time of <a name="setSource"></a><span class="ddoc_psymbol">setSource</span>(). This
 means that further modifications of the current transformation
 matrix will not affect the source pattern.
 See <span class="d_inlinecode">Pattern.setMatrix()</span>.
<p></p>

 The default source pattern is a solid pattern that is opaque
 black, (that is, it is equivalent
 to setSourceRGB(0.0, 0.0, 0.0)).<p></p>

</dd>
<dt class="d_decl">void <a name="setSourceSurface"></a><span class="ddoc_psymbol">setSourceSurface</span>(Surface <i>sur</i>, double <i>x</i>, double <i>y</i>);
<br>void <a name="setSourceSurface"></a><span class="ddoc_psymbol">setSourceSurface</span>(Surface <i>sur</i>, Point <i>p1</i>);
</dt>
<dd>This is a convenience function for creating a pattern from
 surface and setting it as the source in cr with <span class="d_inlinecode">Context.setSource()</span>.
<p></p>
The <i>x</i> and <i>y</i> parameters give the user-space coordinate at
 which the surface origin should appear. (The surface origin
 is its upper-left corner before any transformation has been
 applied.) The <i>x</i> and <i>y</i> parameters are negated and then set
 as translation values in the pattern matrix.
<p></p>

 Other than the initial translation pattern matrix,
 as described above, all other pattern attributes,
 (such as its extend mode), are set to the default values as
 in <span class="d_inlinecode">new SurfacePattern()</span>. The resulting pattern can be
 queried with <span class="d_inlinecode">Context.getSource()</span> so that these
 attributes can be modified if desired, (eg. to create a
 repeating pattern with <span class="d_inlinecode">Pattern.setExtend()</span>).

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>x</i></td>
<td valign=top>User-space X coordinate for surface origin</td></tr>
<tr><td valign=top>double <i>y</i></td>
<td valign=top>User-space Y coordinate for surface origin</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">Pattern <a name="getSource"></a><span class="ddoc_psymbol">getSource</span>();
</dt>
<dd>Gets the current source pattern for cr.<p></p>

</dd>
<dt class="d_decl">void <a name="setAntiAlias"></a><span class="ddoc_psymbol">setAntiAlias</span>(AntiAlias <i>antialias</i>);
</dt>
<dd>Set the antialiasing mode of the rasterizer used for
 drawing shapes. This value is a hint, and a particular
 backend may or may not support a particular value. At
 the current time, no backend supports CAIRO_ANTIALIAS_SUBPIXEL
 when drawing shapes.
<p></p>
Note that this option does not affect text rendering,
 instead see <span class="d_inlinecode">FontOptions.setAntialias()</span>.<p></p>

</dd>
<dt class="d_decl">AntiAlias <a name="getAntiAlias"></a><span class="ddoc_psymbol">getAntiAlias</span>();
</dt>
<dd>Gets the current shape antialiasing mode, as set by <span class="d_inlinecode">setAntiAlias</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="setDash"></a><span class="ddoc_psymbol">setDash</span>(const(double[]) <i>dashes</i>, double <i>offset</i>);
</dt>
<dd>Sets the dash pattern to be used by <span class="d_inlinecode">stroke()</span>. A dash
 pattern is specified by <i>dashes</i>, an array of positive values.
 Each value provides the length of alternate "on" and
 "off" portions of the stroke. The <i>offset</i> specifies an <i>offset</i>
 into the pattern at which the stroke begins.
<p></p>
Each "on" segment will have caps applied as if the segment
 were a separate sub-path. In particular, it is valid to use
 an "on" length of 0.0 with CAIRO_LINE_CAP_ROUND or
 CAIRO_LINE_CAP_SQUARE in order to distributed dots
 or squares along a path.

<p></p>
<b>Note:</b><br>
The length values are in user-space units as
 evaluated at the time of stroking. This is not necessarily
 the same as the user space at the time of <span class="d_inlinecode"><a name="setDash"></a><span class="ddoc_psymbol">setDash</span>()</span>.
<p></p>

 If <i>dashes</i> is empty dashing is disabled.
<p></p>

 If <i>dashes</i>.length is 1 a symmetric pattern is assumed with alternating
 on and off portions of the size specified by the single value
 in <i>dashes</i>.
<p></p>

 If any value in <i>dashes</i> is negative, or if all values are 0, then
 cr will be put into an error state with a
 status of CAIRO_STATUS_INVALID_DASH.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>const(double[]) <i>dashes</i></td>
<td valign=top>an array specifying alternate lengths of on and off stroke portions</td></tr>
<tr><td valign=top>double <i>offset</i></td>
<td valign=top>an <i>offset</i> into the dash pattern at which the stroke should start</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">int <a name="getDashCount"></a><span class="ddoc_psymbol">getDashCount</span>();
</dt>
<dd>This function returns the length of the dash array in cr
 (0 if dashing is not currently in effect).<p></p>

</dd>
<dt class="d_decl">double[] <a name="getDash"></a><span class="ddoc_psymbol">getDash</span>(out double <i>offset</i>);
</dt>
<dd>Gets the current dash array.<p></p>

</dd>
<dt class="d_decl">void <a name="setFillRule"></a><span class="ddoc_psymbol">setFillRule</span>(FillRule <i>rule</i>);
</dt>
<dd>Set the current fill <i>rule</i> within the cairo context. The fill
 <i>rule</i> is used to determine which regions are inside or outside
 a complex (potentially self-intersecting) path. The current
 fill <i>rule</i> affects both <span class="d_inlinecode">fill()</span> and <span class="d_inlinecode">clip()</span>. See
 <span class="d_inlinecode">FillRule</span> for details on the semantics of each
 available fill <i>rule</i>.
<p></p>
The default fill <i>rule</i> is CAIRO_FILL_RULE_WINDING.<p></p>

</dd>
<dt class="d_decl">FillRule <a name="getFillRule"></a><span class="ddoc_psymbol">getFillRule</span>();
</dt>
<dd>Gets the current fill rule, as set by <span class="d_inlinecode">setFillRule</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="setLineCap"></a><span class="ddoc_psymbol">setLineCap</span>(LineCap <i>cap</i>);
</dt>
<dd>Sets the current line <i>cap</i> style within the cairo context.
 See <span class="d_inlinecode">LineCap</span> for details about how the available
 line <i>cap</i> styles are drawn.
<p></p>
As with the other stroke parameters, the current line <i>cap</i>
 style is examined by <span class="d_inlinecode">stroke()</span>, <span class="d_inlinecode">strokeExtents()</span>
 and <span class="d_inlinecode">strokeToPath()</span>, but does not have any
 effect during path construction.
<p></p>

 The default line <i>cap</i> style is CAIRO_LINE_CAP_BUTT.<p></p>

</dd>
<dt class="d_decl">LineCap <a name="getLineCap"></a><span class="ddoc_psymbol">getLineCap</span>();
</dt>
<dd>Gets the current line cap style, as set by <span class="d_inlinecode">setLineCap()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="setLineJoin"></a><span class="ddoc_psymbol">setLineJoin</span>(LineJoin <i>join</i>);
</dt>
<dd>Sets the current line <i>join</i> style within the cairo context.
 See <span class="d_inlinecode">LineJoin</span> for details about how the available
 line <i>join</i> styles are drawn.
<p></p>
As with the other stroke parametes, the current line <i>join</i>
 style is examined by <span class="d_inlinecode">stroke()</span>, <span class="d_inlinecode">strokeExtents()</span>
 and <span class="d_inlinecode">strokeToPath()</span>, but does not have any effect
 during path construction.
<p></p>

 The default line <i>join</i> style is CAIRO_LINE_JOIN_MITER.<p></p>

</dd>
<dt class="d_decl">LineJoin <a name="getLineJoin"></a><span class="ddoc_psymbol">getLineJoin</span>();
</dt>
<dd>Gets the current line join style, as set by <span class="d_inlinecode">setLineJoin</span><p></p>

</dd>
<dt class="d_decl">void <a name="setLineWidth"></a><span class="ddoc_psymbol">setLineWidth</span>(double <i>width</i>);
</dt>
<dd>Sets the current line <i>width</i> within the cairo context. The line
 <i>width</i> value specifies the diameter of a pen that is circular
 in user space, (though device-space pen may be an ellipse
 in general due to scaling/shear/rotation of the CTM).
<p></p>
<b>Note:</b><br>
When the description above refers to user space and CTM
 it refers to the user space and CTM in effect at the time
 of the stroking operation, not the user space and CTM in
 effect at the time of the call to <span class="d_inlinecode"><a name="setLineWidth"></a><span class="ddoc_psymbol">setLineWidth</span>()</span>.
 The simplest usage makes both of these spaces identical.
 That is, if there is no change to the CTM between a call to
 <span class="d_inlinecode"><a name="setLineWidth"></a><span class="ddoc_psymbol">setLineWidth</span>()</span> and the stroking operation, then one
 can just pass user-space values to <span class="d_inlinecode"><a name="setLineWidth"></a><span class="ddoc_psymbol">setLineWidth</span>()</span> and
 ignore this note.
<p></p>

 As with the other stroke parameters, the current line <i>width</i> is
 examined by <span class="d_inlinecode">stroke()</span>, <span class="d_inlinecode">strokeExtents()</span>
 and <span class="d_inlinecode">strokeToPath()</span>, but does not have any effect during
 path construction.
<p></p>

 The default line <i>width</i> value is 2.0.<p></p>

</dd>
<dt class="d_decl">double <a name="getLineWidth"></a><span class="ddoc_psymbol">getLineWidth</span>();
</dt>
<dd>This function returns the current line width value exactly
 as set by cairo_set_line_width(). Note that the value is
 unchanged even if the CTM has changed between the calls
 to <span class="d_inlinecode">setLineWidth()</span> and <span class="d_inlinecode"><a name="getLineWidth"></a><span class="ddoc_psymbol">getLineWidth</span>()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="setMiterLimit"></a><span class="ddoc_psymbol">setMiterLimit</span>(double <i>limit</i>);
</dt>
<dd>Sets the current miter <i>limit</i> within the cairo context.
<p></p>
If the current line join style is set to
 CAIRO_LINE_JOIN_MITER (see cairo_set_line_join()), the miter
 <i>limit</i> is used to determine whether the lines should be joined
 with a bevel instead of a miter. Cairo divides the length of
 the miter by the line width. If the result is greater than the
 miter <i>limit</i>, the style is converted to a bevel.
<p></p>

 As with the other stroke parameters, the current line miter
 <i>limit</i> is examined by <span class="d_inlinecode">stroke()</span>, <span class="d_inlinecode">strokeExtents()</span>
 and <span class="d_inlinecode">strokeToPath()</span>, but does not have any effect
 during path construction.
<p></p>

 The default miter <i>limit</i> value is 10.0, which will convert
 joins with interior angles less than 11 degrees to bevels
 instead of miters. For reference, a miter <i>limit</i> of 2.0 makes
 the miter cutoff at 60 degrees, and a miter <i>limit</i> of 1.414
 makes the cutoff at 90 degrees.
<p></p>

 A miter <i>limit</i> for a desired angle can be computed as: miter
 <i>limit</i> = 1/sin(angle/2)<p></p>

</dd>
<dt class="d_decl">double <a name="getMiterLimit"></a><span class="ddoc_psymbol">getMiterLimit</span>();
</dt>
<dd>Gets the current miter limit, as set by <span class="d_inlinecode">setMiterLimit</span><p></p>

</dd>
<dt class="d_decl">void <a name="setOperator"></a><span class="ddoc_psymbol">setOperator</span>(Operator <i>op</i>);
</dt>
<dd>Sets the compositing operator to be used for all
 drawing operations. See <span class="d_inlinecode">Operator</span> for details on
 the semantics of each available compositing operator.
<p></p>
The default operator is CAIRO_OPERATOR_OVER.<p></p>

</dd>
<dt class="d_decl">Operator <a name="getOperator"></a><span class="ddoc_psymbol">getOperator</span>();
</dt>
<dd>Gets the current compositing operator for a cairo context.<p></p>

</dd>
<dt class="d_decl">void <a name="setTolerance"></a><span class="ddoc_psymbol">setTolerance</span>(double <i>tolerance</i>);
</dt>
<dd>Sets the <i>tolerance</i> used when converting paths into trapezoids.
 Curved segments of the path will be subdivided until the maximum
 deviation between the original path and the polygonal
 approximation is less than <i>tolerance</i>. The default value
 is 0.1. A larger value will give better performance, a smaller
 value, better appearance. (Reducing the value from the
 default value of 0.1 is unlikely to improve appearance
 significantly.) The accuracy of paths within Cairo is limited
 by the precision of its internal arithmetic, and the prescribed
 <i>tolerance</i> is restricted to the smallest representable
 internal value.<p></p>

</dd>
<dt class="d_decl">double <a name="getTolerance"></a><span class="ddoc_psymbol">getTolerance</span>();
</dt>
<dd>Gets the current tolerance value, as set by <span class="d_inlinecode">setTolerance</span><p></p>

</dd>
<dt class="d_decl">void <a name="clip"></a><span class="ddoc_psymbol">clip</span>();
</dt>
<dd>Establishes a new <a name="clip"></a><span class="ddoc_psymbol">clip</span> region by intersecting the current
 <a name="clip"></a><span class="ddoc_psymbol">clip</span> region with the current path as it would be filled by
 <span class="d_inlinecode">fill()</span> and according to the current
 fill rule (see <span class="d_inlinecode">setFillRule()</span>).
<p></p>
After <span class="d_inlinecode"><a name="clip"></a><span class="ddoc_psymbol">clip</span>()</span>, the current path will be cleared from the
 cairo context.
<p></p>

 The current <a name="clip"></a><span class="ddoc_psymbol">clip</span> region affects all drawing operations by
 effectively masking out any changes to the surface that are
 outside the current <a name="clip"></a><span class="ddoc_psymbol">clip</span> region.
<p></p>

 Calling <span class="d_inlinecode"><a name="clip"></a><span class="ddoc_psymbol">clip</span>()</span> can only make the <a name="clip"></a><span class="ddoc_psymbol">clip</span> region smaller,
 never larger. But the current <a name="clip"></a><span class="ddoc_psymbol">clip</span> is part of the graphics state,
 so a temporary restriction of the <a name="clip"></a><span class="ddoc_psymbol">clip</span> region can be achieved
 by calling <span class="d_inlinecode"><a name="clip"></a><span class="ddoc_psymbol">clip</span>()</span> within a <span class="d_inlinecode">save()</span>/<span class="d_inlinecode">restore()</span>
 pair. The only other means of increasing the size of the <a name="clip"></a><span class="ddoc_psymbol">clip</span>
 region is <span class="d_inlinecode">resetClip()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="clipPreserve"></a><span class="ddoc_psymbol">clipPreserve</span>();
</dt>
<dd>Establishes a new clip region by intersecting the current clip
 region with the current path as it would be filled by
 <span class="d_inlinecode">fill()</span> and according to the current fill rule
 (see <span class="d_inlinecode">setFillRule()</span>).
<p></p>
Unlike <span class="d_inlinecode">clip()</span>, <span class="d_inlinecode"><a name="clipPreserve"></a><span class="ddoc_psymbol">clipPreserve</span>()</span> preserves the
 path within the cairo context.
<p></p>

 The current clip region affects all drawing operations by
 effectively masking out any changes to the surface that are
 outside the current clip region.
<p></p>

 Calling <span class="d_inlinecode"><a name="clipPreserve"></a><span class="ddoc_psymbol">clipPreserve</span>()</span> can only make the clip region
 smaller, never larger. But the current clip is part of the
 graphics state, so a temporary restriction of the clip region
 can be achieved by calling <span class="d_inlinecode">clip()</span> within a <span class="d_inlinecode">save()</span>/<span class="d_inlinecode">restore()</span>
 pair. The only other means of increasing the size of the clip
 region is <span class="d_inlinecode">resetClip()</span>.<p></p>

</dd>
<dt class="d_decl">Box <a name="clipExtents"></a><span class="ddoc_psymbol">clipExtents</span>();
</dt>
<dd>Computes a bounding box in user coordinates covering the area
 inside the current clip.<p></p>

</dd>
<dt class="d_decl">bool <a name="inClip"></a><span class="ddoc_psymbol">inClip</span>(Point <i>point</i>);
</dt>
<dd>Tests whether the given <i>point</i> is inside the area that would
 be visible through the current clip, i.e. the area that
 would be filled by a cairo_paint() operation.
<p></p>
See <span class="d_inlinecode">clip()</span>, and <span class="d_inlinecode">clipPreserve()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="resetClip"></a><span class="ddoc_psymbol">resetClip</span>();
</dt>
<dd>Reset the current clip region to its original, unrestricted
 state. That is, set the clip region to an infinitely
 large shape containing the target surface. Equivalently,
 if infinity is too hard to grasp, one can imagine the clip
 region being reset to the exact bounds of the target surface.
<p></p>
Note that code meant to be reusable should not call
 <span class="d_inlinecode"><a name="resetClip"></a><span class="ddoc_psymbol">resetClip</span>()</span> as it will cause results unexpected by
 higher-level code which calls <span class="d_inlinecode">clip()</span>. Consider using
 <span class="d_inlinecode">save()</span> and <span class="d_inlinecode">restore()</span> around <span class="d_inlinecode">clip()</span> as a
 more robust means of temporarily restricting the clip region.<p></p>

</dd>
<dt class="d_decl">Rectangle!(double)[] <a name="copyClipRectangles"></a><span class="ddoc_psymbol">copyClipRectangles</span>();
</dt>
<dd>Gets the current clip region as a list of rectangles in user
 coordinates.<p></p>

</dd>
<dt class="d_decl">void <a name="fill"></a><span class="ddoc_psymbol">fill</span>();
</dt>
<dd>A drawing operator that fills the current path according to
 the current <a name="fill"></a><span class="ddoc_psymbol">fill</span> rule, (each sub-path is implicitly closed
 before being filled). After c<span class="d_inlinecode"><a name="fill"></a><span class="ddoc_psymbol">fill</span>()</span>, the current
 path will be cleared from the cairo context. See
 <span class="d_inlinecode">setFillRule()</span> and <span class="d_inlinecode">fillPreserve()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="fillPreserve"></a><span class="ddoc_psymbol">fillPreserve</span>();
</dt>
<dd>A drawing operator that fills the current path according to
 the current fill rule, (each sub-path is implicitly closed
 before being filled). Unlike <span class="d_inlinecode">fill()</span>, <span class="d_inlinecode"><a name="fillPreserve"></a><span class="ddoc_psymbol">fillPreserve</span>()</span>
 preserves the path within the cairo context.<p></p>

</dd>
<dt class="d_decl">Box <a name="fillExtends"></a><span class="ddoc_psymbol">fillExtends</span>();
</dt>
<dd>Computes a bounding box in user coordinates covering the area
 that would be affected, (the "inked" area), by a
 <span class="d_inlinecode">fill()</span> operation given the current path and fill parameters.
 If the current path is empty, returns an empty rectangle
 ((0,0), (0,0)). Surface dimensions and clipping are not
 taken into account.
<p></p>
Contrast with <span class="d_inlinecode">pathExtents()</span>, which is similar, but
 returns non-zero extents for some paths with no inked area,
 (such as a simple line segment).
<p></p>

 Note that <span class="d_inlinecode">fillExtents()</span> must necessarily do more work
 to compute the precise inked areas in light of the fill rule,
 so <span class="d_inlinecode">pathExtents()</span> may be more desirable for sake of
 performance if the non-inked path extents are desired.
<p></p>

 See <span class="d_inlinecode">fill()</span>, <span class="d_inlinecode">setFillRule()</span> and <span class="d_inlinecode">fillPreserve()</span>.<p></p>

</dd>
<dt class="d_decl">bool <a name="inFill"></a><span class="ddoc_psymbol">inFill</span>(Point <i>point</i>);
</dt>
<dd>Tests whether the given <i>point</i> is inside the area that would
 be affected by a cairo_fill() operation given the current path
 and filling parameters. Surface dimensions and clipping are not
 taken into account.
<p></p>
See <span class="d_inlinecode">fill()</span>, <span class="d_inlinecode">setFillRule()</span> and <span class="d_inlinecode">fillPreserve()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="mask"></a><span class="ddoc_psymbol">mask</span>(Pattern <i>pattern</i>);
</dt>
<dd>A drawing operator that paints the current source using the
 alpha channel of <i>pattern</i> as a <a name="mask"></a><span class="ddoc_psymbol">mask</span>. (Opaque areas of <i>pattern</i>
 are painted with the source, transparent areas are not painted.)<p></p>

</dd>
<dt class="d_decl">void <a name="maskSurface"></a><span class="ddoc_psymbol">maskSurface</span>(Surface <i>surface</i>, Point <i>location</i>);
<br>void <a name="maskSurface"></a><span class="ddoc_psymbol">maskSurface</span>(Surface <i>surface</i>, double <i>x</i>, double <i>y</i>);
</dt>
<dd>A drawing operator that paints the current source using
 the alpha channel of <i>surface</i> as a mask. (Opaque areas of
 <i>surface</i> are painted with the source, transparent areas
 are not painted.)
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Point <i>location</i></td>
<td valign=top>coordinates at which to place the origin of <i>surface</i></td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="paint"></a><span class="ddoc_psymbol">paint</span>();
</dt>
<dd>A drawing operator that paints the current source everywhere
 within the current clip region.<p></p>

</dd>
<dt class="d_decl">void <a name="paintWithAlpha"></a><span class="ddoc_psymbol">paintWithAlpha</span>(double <i>alpha</i>);
</dt>
<dd>A drawing operator that paints the current source everywhere
 within the current clip region using a mask of constant <i>alpha</i>
 value <i>alpha</i>. The effect is similar to <span class="d_inlinecode">paint()</span>, but
 the drawing is faded out using the <i>alpha</i> value.<p></p>

</dd>
<dt class="d_decl">void <a name="stroke"></a><span class="ddoc_psymbol">stroke</span>();
</dt>
<dd>A drawing operator that strokes the current path according to
 the current line width, line join, line cap, and dash settings.
 After <span class="d_inlinecode"><a name="stroke"></a><span class="ddoc_psymbol">stroke</span>()</span>, the current path will be cleared from
 the cairo context. See <span class="d_inlinecode">setLineWidth()</span>,
 <span class="d_inlinecode">setLineJoin()</span>, <span class="d_inlinecode">setLineCap()</span>, <span class="d_inlinecode">setDash()</span>,
 and <span class="d_inlinecode">strokePreserve()</span>.
<p></p>
<b>Note:</b><br>
Degenerate segments and sub-paths are treated specially
 and provide a useful result. These can result in two
 different situations:
<p></p>

 1. Zero-length "on" segments set in cairo_set_dash(). If the
 cap style is CAIRO_LINE_CAP_ROUND or CAIRO_LINE_CAP_SQUARE
 then these segments will be drawn as circular dots or squares
 respectively. In the case of CAIRO_LINE_CAP_SQUARE, the
 orientation of the squares is determined by the direction
 of the underlying path.
<p></p>

 2. A sub-path created by <span class="d_inlinecode">moveTo()</span> followed by either a
 <span class="d_inlinecode">closePath()</span> or one or more calls to <span class="d_inlinecode">lineTo()</span> to
 the same coordinate as the <span class="d_inlinecode">moveTo()</span>. If the cap style
 is CAIRO_LINE_CAP_ROUND then these sub-paths will be drawn as
 circular dots. Note that in the case of CAIRO_LINE_CAP_SQUARE
 a degenerate sub-path will not be drawn at all, (since the
 correct orientation is indeterminate).
<p></p>

 In no case will a cap style of CAIRO_LINE_CAP_BUTT cause
 anything to be drawn in the case of either degenerate
 segments or sub-paths.<p></p>

</dd>
<dt class="d_decl">void <a name="strokePreserve"></a><span class="ddoc_psymbol">strokePreserve</span>();
</dt>
<dd>A drawing operator that strokes the current path according to
 the current line width, line join, line cap, and dash settings.
 Unlike <span class="d_inlinecode">stroke()</span>, <span class="d_inlinecode"><a name="strokePreserve"></a><span class="ddoc_psymbol">strokePreserve</span>()</span> preserves
 the path within the cairo context.
<p></p>
See <span class="d_inlinecode">setLineWidth()</span>, <span class="d_inlinecode">setLineJoin()</span>,
 <span class="d_inlinecode">setLineCap()</span>, <span class="d_inlinecode">set_dash()</span>, and <span class="d_inlinecode"><a name="strokePreserve"></a><span class="ddoc_psymbol">strokePreserve</span>()</span>.<p></p>

</dd>
<dt class="d_decl">Box <a name="strokeExtends"></a><span class="ddoc_psymbol">strokeExtends</span>();
</dt>
<dd>Computes a bounding box in user coordinates covering the area
 that would be affected, (the "inked" area), by a <span class="d_inlinecode">stroke()</span>
 operation given the current path and stroke parameters. If the
 current path is empty, returns an empty rectangle ((0,0), (0,0)).
 Surface dimensions and clipping are not taken into account.
<p></p>
Note that if the line width is set to exactly zero, then
 <span class="d_inlinecode">strokeExtents()</span> will return an empty rectangle.
 Contrast with <span class="d_inlinecode">pathExtents()</span> which can be used to
 compute the non-empty bounds as the line width approaches zero.
<p></p>

 Note that <span class="d_inlinecode">strokeExtents()</span> must necessarily do more
 work to compute the precise inked areas in light of the
 stroke parameters, so <span class="d_inlinecode">pathExtents()</span> may be more
 desirable for sake of performance if non-inked path extents
 are desired.
<p></p>

 See <span class="d_inlinecode">stroke()</span>, <span class="d_inlinecode">setLineWidth()</span>, <span class="d_inlinecode">setLineJoin()</span>,
 <span class="d_inlinecode">setLineCap()</span>, <span class="d_inlinecode">set_dash()</span>, and <span class="d_inlinecode">strokePreserve()</span>.<p></p>

</dd>
<dt class="d_decl">bool <a name="inStroke"></a><span class="ddoc_psymbol">inStroke</span>(Point <i>point</i>);
<br>bool <a name="inStroke"></a><span class="ddoc_psymbol">inStroke</span>(double <i>x</i>, double <i>y</i>);
</dt>
<dd>Tests whether the given <i>point</i> is inside the area that would be
 affected by a cairo_stroke() operation given the current path
 and stroking parameters. Surface dimensions and clipping are
 not taken into account.
<p></p>
See <span class="d_inlinecode">stroke()</span>, <span class="d_inlinecode">setLineWidth()</span>, <span class="d_inlinecode">setLineJoin()</span>,
 <span class="d_inlinecode">setLineCap()</span>, <span class="d_inlinecode">set_dash()</span>, and <span class="d_inlinecode">strokePreserve()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="copyPage"></a><span class="ddoc_psymbol">copyPage</span>();
</dt>
<dd>Emits the current page for backends that support multiple
 pages, but doesn't clear it, so, the contents of the current
 page will be retained for the next page too.
 Use <span class="d_inlinecode">showPage()</span> if you want to get an empty page after
 the emission.
<p></p>
This is a convenience function that simply calls <span class="d_inlinecode">Surface.<a name="copyPage"></a><span class="ddoc_psymbol">copyPage</span>()</span>
 on this's target.<p></p>

</dd>
<dt class="d_decl">void <a name="showPage"></a><span class="ddoc_psymbol">showPage</span>();
</dt>
<dd>Emits and clears the current page for backends that support
 multiple pages. Use <span class="d_inlinecode">copyPage()</span> if you don't want to
 clear the page.
<p></p>
This is a convenience function that simply calls
 <span class="d_inlinecode">Surface.<a name="showPage"></a><span class="ddoc_psymbol">showPage</span>()</span> on this's target.<p></p>

</dd>
<dt class="d_decl">Path <a name="copyPath"></a><span class="ddoc_psymbol">copyPath</span>();
</dt>
<dd>Creates a copy of the current path and returns it to the user
 as a <span class="d_inlinecode">Path</span>. See <span class="d_inlinecode">PathRange</span> for hints on how to
 iterate over the returned data structure.<p></p>

</dd>
<dt class="d_decl">Path <a name="copyPathFlat"></a><span class="ddoc_psymbol">copyPathFlat</span>();
</dt>
<dd>Gets a flattened copy of the current path and returns it to
 the user as a <span class="d_inlinecode">Path</span>. See <span class="d_inlinecode">PathRange</span> for hints
 on how to iterate over the returned data structure.
<p></p>
This function is like <span class="d_inlinecode">copyPath()</span> except that any
 curves in the path will be approximated with piecewise-linear
 approximations, (accurate to within the current tolerance value).
 That is, the result is guaranteed to not have any elements of
 type CAIRO_PATH_CURVE_TO which will instead be replaced by
 a series of CAIRO_PATH_LINE_TO elements.<p></p>

</dd>
<dt class="d_decl">void <a name="appendPath"></a><span class="ddoc_psymbol">appendPath</span>(Path <i>p</i>);
</dt>
<dd>Append the path onto the current path. The path may be
 the return value from one of <span class="d_inlinecode">copyPath()</span> or <span class="d_inlinecode">copyPathFlat()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="appendPath"></a><span class="ddoc_psymbol">appendPath</span>(cairo_path_t* <i>path</i>);
</dt>
<dd><a name="appendPath"></a><span class="ddoc_psymbol">appendPath</span> for user created paths. There is no high level API
 for user defined paths. Use <span class="d_inlinecode"><a name="appendPath"></a><span class="ddoc_psymbol">appendPath</span>(Path p)</span> for paths
 which were obtained from cairo.
<p></p>
See <span class="d_inlinecode">cairo_path_t</span> for details
 on how the <i>path</i> data structure should be initialized,
 and note that <i>path</i>.status must be initialized to CAIRO_STATUS_SUCCESS.

<p></p>
<b>Warning:</b><br>
<span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">bool <a name="hasCurrentPoint"></a><span class="ddoc_psymbol">hasCurrentPoint</span>();
</dt>
<dd>Returns whether a current point is defined on the current path.
 See <span class="d_inlinecode">getCurrentPoint()</span> for details on the current point.<p></p>

</dd>
<dt class="d_decl">Point <a name="getCurrentPoint"></a><span class="ddoc_psymbol">getCurrentPoint</span>();
</dt>
<dd>Gets the current point of the current path, which is conceptually
 the final point reached by the path so far.
<p></p>
The current point is returned in the user-space coordinate system.
 If there is no defined current point or if cr is in an error status,
 x and y will both be set to 0.0. It is possible to check
 this in advance with <span class="d_inlinecode">hasCurrentPoint()</span>.
<p></p>

 Most path construction functions alter the current point. See
 the following for details on how they affect the current point:
 <span class="d_inlinecode">newPath()</span>, <span class="d_inlinecode">newSubPath()</span>, <span class="d_inlinecode">appendPath()</span>,
 <span class="d_inlinecode">closePath()</span>, <span class="d_inlinecode">moveTo()</span>, <span class="d_inlinecode">lineTo()</span>,
 <span class="d_inlinecode">curveTo()</span>, <span class="d_inlinecode">relMoveTo()</span>, <span class="d_inlinecode">relLineTo()</span>,
 <span class="d_inlinecode">relCurveTo()</span>, <span class="d_inlinecode">arc()</span>, <span class="d_inlinecode">arcNegative()</span>,
 <span class="d_inlinecode">rectangle()</span>, <span class="d_inlinecode">textPath()</span>, <span class="d_inlinecode">glyphPath()</span>,
 <span class="d_inlinecode">strokeToPath()</span>.
<p></p>

 Some functions use and alter the current point but do not
 otherwise change current path: <span class="d_inlinecode">showText()</span>.
<p></p>

 Some functions unset the current path and as a result,
 current point: <span class="d_inlinecode">fill()</span>, <span class="d_inlinecode">stroke()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="newPath"></a><span class="ddoc_psymbol">newPath</span>();
</dt>
<dd>Clears the current path. After this call there will be no path
 and no current point.<p></p>

</dd>
<dt class="d_decl">void <a name="newSubPath"></a><span class="ddoc_psymbol">newSubPath</span>();
</dt>
<dd>Begin a new sub-path. Note that the existing path is not affected.
 After this call there will be no current point.
<p></p>
In many cases, this call is not needed since new sub-paths are
 frequently started with cairo_move_to().
<p></p>

 A call to <span class="d_inlinecode"><a name="newSubPath"></a><span class="ddoc_psymbol">newSubPath</span>()</span> is particularly useful when
 beginning a new sub-path with one of the <span class="d_inlinecode">arc()</span> calls.
 This makes things easier as it is no longer necessary to
 manually compute the arc's initial coordinates for a call
 to <span class="d_inlinecode">moveTo()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="closePath"></a><span class="ddoc_psymbol">closePath</span>();
</dt>
<dd>Adds a line segment to the path from the current point to
 the beginning of the current sub-path, (the most recent
 point passed to <span class="d_inlinecode">moveTo()</span>), and closes this sub-path.
 After this call the current point will be at the joined
 endpoint of the sub-path.
<p></p>
The behavior of <span class="d_inlinecode"><a name="closePath"></a><span class="ddoc_psymbol">closePath</span>()</span> is distinct from simply
 calling <span class="d_inlinecode">lineTo()</span> with the equivalent coordinate in
 the case of stroking. When a closed sub-path is stroked,
 there are no caps on the ends of the sub-path. Instead,
 there is a line join connecting the final and initial
 segments of the sub-path.
<p></p>

 If there is no current point before the call to <span class="d_inlinecode"><a name="closePath"></a><span class="ddoc_psymbol">closePath</span>()</span>,
 this function will have no effect.

<p></p>
<b>Note:</b><br>
As of cairo version 1.2.4 any call to <span class="d_inlinecode"><a name="closePath"></a><span class="ddoc_psymbol">closePath</span>()</span>
 will place an explicit MOVE_TO element into the path immediately
 after the CLOSE_PATH element, (which can be seen in
 <span class="d_inlinecode">copyPath()</span> for example). This can simplify path processing
 in some cases as it may not be necessary to save the "last
 move_to point" during processing as the MOVE_TO immediately
 after the CLOSE_PATH will provide that point.<p></p>

</dd>
<dt class="d_decl">void <a name="arc"></a><span class="ddoc_psymbol">arc</span>(Point <i>center</i>, double <i>radius</i>, double <i>angle1</i>, double <i>angle2</i>);
<br>void <a name="arc"></a><span class="ddoc_psymbol">arc</span>(double <i>centerX</i>, double <i>centerY</i>, double <i>radius</i>, double <i>angle1</i>, double <i>angle2</i>);
</dt>
<dd>Adds a circular <a name="arc"></a><span class="ddoc_psymbol">arc</span> of the given <i>radius</i> to the current path.
 The <a name="arc"></a><span class="ddoc_psymbol">arc</span> is centered at <i>center</i>, begins at <i>angle1</i> and proceeds in
 the direction of increasing angles to end at <i>angle2</i>.
 If <i>angle2</i> is less than <i>angle1</i> it will be progressively
 increased by 2*PI until it is greater than <i>angle1</i>.
<p></p>
If there is a current point, an initial line segment will be
 added to the path to connect the current point to the beginning
 of the <a name="arc"></a><span class="ddoc_psymbol">arc</span>. If this initial line is undesired, it can be
 avoided by calling <span class="d_inlinecode">newSubPath()</span> before calling <span class="d_inlinecode"><a name="arc"></a><span class="ddoc_psymbol">arc</span>()</span>.
<p></p>

 Angles are measured in radians. An angle of 0.0 is in the
 direction of the positive X axis (in user space). An angle
 of PI/2.0 radians (90 degrees) is in the direction of the
 positive Y axis (in user space). Angles increase in the
 direction from the positive X axis toward the positive Y
 axis. So with the default transformation matrix, angles
 increase in a clockwise direction.
<p></p>

 (To convert from degrees to radians, use degrees * (PI / 180))
<p></p>

 This function gives the <a name="arc"></a><span class="ddoc_psymbol">arc</span> in the direction of increasing angles;
 see <span class="d_inlinecode">arcNegative()</span> to get the <a name="arc"></a><span class="ddoc_psymbol">arc</span> in the direction of decreasing angles.
<p></p>

 The <a name="arc"></a><span class="ddoc_psymbol">arc</span> is circular in user space. To achieve an elliptical <a name="arc"></a><span class="ddoc_psymbol">arc</span>,
 you can scale the current transformation matrix by different
 amounts in the X and Y directions. For example, to draw an
 ellipse in the box given by x, y, width, height:
<pre class="d_code"> cr.save();
 cr.translate(x + width / 2, y + height / 2);
 cr.scale(width / 2, height / 2);
 cr.<span class="d_psymbol">arc</span>(Point(0, 0), 1, 0, 2 * PI);
 cr.restore();
</pre>
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>radius</i></td>
<td valign=top>the <i>radius</i> of the <a name="arc"></a><span class="ddoc_psymbol">arc</span></td></tr>
<tr><td valign=top>double <i>angle1</i></td>
<td valign=top>the start angle, in radians</td></tr>
<tr><td valign=top>double <i>angle2</i></td>
<td valign=top>the end angle, in radians</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="arcNegative"></a><span class="ddoc_psymbol">arcNegative</span>(Point <i>center</i>, double <i>radius</i>, double <i>angle1</i>, double <i>angle2</i>);
<br>void <a name="arcNegative"></a><span class="ddoc_psymbol">arcNegative</span>(double <i>centerX</i>, double <i>centerY</i>, double <i>radius</i>, double <i>angle1</i>, double <i>angle2</i>);
</dt>
<dd>Adds a circular arc of the given <i>radius</i> to the current path.
 The arc is centered at <i>center</i>, begins at <i>angle1</i> and proceeds
 in the direction of decreasing angles to end at <i>angle2</i>.
 If <i>angle2</i> is greater than <i>angle1</i> it will be progressively
 decreased by 2*PI until it is less than <i>angle1</i>.
<p></p>
See <span class="d_inlinecode">arc()</span> for more details. This function differs only
 in the direction of the arc between the two angles.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>radius</i></td>
<td valign=top>the <i>radius</i> of the arc</td></tr>
<tr><td valign=top>double <i>angle1</i></td>
<td valign=top>the start angle, in radians</td></tr>
<tr><td valign=top>double <i>angle2</i></td>
<td valign=top>the end angle, in radians</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="curveTo"></a><span class="ddoc_psymbol">curveTo</span>(Point <i>p1</i>, Point <i>p2</i>, Point <i>p3</i>);
<br>void <a name="curveTo"></a><span class="ddoc_psymbol">curveTo</span>(double <i>p1x</i>, double <i>p1y</i>, double <i>p2x</i>, double <i>p2y</i>, double <i>p3x</i>, double <i>p3y</i>);
</dt>
<dd>Adds a cubic Bézier spline to the path from the current
 point to position <i>p3</i> in user-space coordinates, using <i>p1</i> and <i>p2</i>
 as the control points. After this call the current point will be <i>p3</i>.
<p></p>
If there is no current point before the call to <span class="d_inlinecode"><a name="curveTo"></a><span class="ddoc_psymbol">curveTo</span>()</span>
 this function will behave as if preceded by a call to
 <span class="d_inlinecode">moveTo(<i>p1</i>)</span>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Point <i>p1</i></td>
<td valign=top>First control point</td></tr>
<tr><td valign=top>Point <i>p2</i></td>
<td valign=top>Second control point</td></tr>
<tr><td valign=top>Point <i>p3</i></td>
<td valign=top>End of the curve</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="lineTo"></a><span class="ddoc_psymbol">lineTo</span>(Point <i>p1</i>);
<br>void <a name="lineTo"></a><span class="ddoc_psymbol">lineTo</span>(double <i>x</i>, double <i>y</i>);
</dt>
<dd>Adds a line to the path from the current point to position <i>p1</i>
 in user-space coordinates. After this call the current point
 will be <i>p1</i>.
<p></p>
If there is no current point before the call to <span class="d_inlinecode"><a name="lineTo"></a><span class="ddoc_psymbol">lineTo</span>()</span>
 this function will behave as <span class="d_inlinecode">moveTo(<i>p1</i>)</span>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Point <i>p1</i></td>
<td valign=top>End of the line</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="moveTo"></a><span class="ddoc_psymbol">moveTo</span>(Point <i>p1</i>);
<br>void <a name="moveTo"></a><span class="ddoc_psymbol">moveTo</span>(double <i>x</i>, double <i>y</i>);
</dt>
<dd>Begin a new sub-path. After this call the current point will be <i>p1</i>.<p></p>

</dd>
<dt class="d_decl">void <a name="rectangle"></a><span class="ddoc_psymbol">rectangle</span>(Rectangle!(double) <i>r</i>);
<br>void <a name="rectangle"></a><span class="ddoc_psymbol">rectangle</span>(double <i>x</i>, double <i>y</i>, double <i>width</i>, double <i>height</i>);
</dt>
<dd>Adds a closed sub-path <a name="rectangle"></a><span class="ddoc_psymbol">rectangle</span> of the given size to the
 current path at position <i>r</i>.point in user-space coordinates.
 This function is logically equivalent to:
<pre class="d_code"> cr.moveTo(<span class="d_param">r</span>.point);
 cr.relLineTo(<span class="d_param">r</span>.width, 0);
 cr.relLineTo(0, <span class="d_param">r</span>.height);
 cr.relLineTo(-<span class="d_param">r</span>.width, 0);
 cr.closePath();
</pre>
<p></p>

</dd>
<dt class="d_decl">void <a name="glyphPath"></a><span class="ddoc_psymbol">glyphPath</span>(cairo_glyph_t[] <i>glyphs</i>);
</dt>
<dd>Adds closed paths for the <i>glyphs</i> to the current path.
 The generated path if filled, achieves an effect
 similar to that of <span class="d_inlinecode">showGlyphs()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="textPath"></a><span class="ddoc_psymbol">textPath</span>(string <i>text</i>);
</dt>
<dd>Adds closed paths for <i>text</i> to the current path. The generated
 path if filled, achieves an effect similar to that of
 <span class="d_inlinecode">showText()</span>.
<p></p>
Text conversion and positioning is done similar to <span class="d_inlinecode">showText()</span>.
<p></p>

 Like <span class="d_inlinecode">showText()</span>, After this call the current point is moved
 to the origin of where the next glyph would be placed in this
 same progression. That is, the current point will be at the
 origin of the final glyph offset by its advance values. This
 allows for chaining multiple calls to to <span class="d_inlinecode"><a name="textPath"></a><span class="ddoc_psymbol">textPath</span>()</span>
 without having to set current point in between.

<p></p>
<b>Note:</b><br>
The <span class="d_inlinecode"><a name="textPath"></a><span class="ddoc_psymbol">textPath</span>()</span> function call is part of what the
 cairo designers call the "toy" <i>text</i> API. It is convenient for
 short demos and simple programs, but it is not expected
 to be adequate for serious <i>text</i>-using applications. See
 <span class="d_inlinecode">glyphPath()</span> for the "real" <i>text</i> path API in cairo.<p></p>

</dd>
<dt class="d_decl">void <a name="relCurveTo"></a><span class="ddoc_psymbol">relCurveTo</span>(Point <i>rp1</i>, Point <i>rp2</i>, Point <i>rp3</i>);
<br>void <a name="relCurveTo"></a><span class="ddoc_psymbol">relCurveTo</span>(double <i>rp1x</i>, double <i>rp1y</i>, double <i>rp2x</i>, double <i>rp2y</i>, double <i>rp3x</i>, double <i>rp3y</i>);
</dt>
<dd>Relative-coordinate version of <span class="d_inlinecode">curveTo()</span>.
 All offsets are relative to the current point. Adds a
 cubic Bézier spline to the path from the current point
 to a point offset from the current point by <i>rp3</i>,
 using points offset by <i>rp1</i> and <i>rp2</i> as the
 control points. After this call the current point will
 be offset by <i>rp3</i>.
<p></p>
Given a current point of (x, y),
 cairo_rel_curve_to(cr, dx1, dy1, dx2, dy2, dx3, dy3) is logically
 equivalent to
 cairo_curve_to(cr, x+dx1, y+dy1, x+dx2, y+dy2, x+dx3, y+dy3).
<p></p>

 It is an error to call this function with no current point.
 Doing so will cause an CairoException with a
 status of CAIRO_STATUS_NO_CURRENT_POINT.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Point <i>rp1</i></td>
<td valign=top>First control point</td></tr>
<tr><td valign=top>Point <i>rp2</i></td>
<td valign=top>Second control point</td></tr>
<tr><td valign=top>Point <i>rp3</i></td>
<td valign=top>offset to the end of the curve</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="relLineTo"></a><span class="ddoc_psymbol">relLineTo</span>(Point <i>rp1</i>);
<br>void <a name="relLineTo"></a><span class="ddoc_psymbol">relLineTo</span>(double <i>x</i>, double <i>y</i>);
</dt>
<dd>Relative-coordinate version of <span class="d_inlinecode">lineTo()</span>. Adds a line
 to the path from the current point to a point that is
 offset from the current point by <i>rp1</i> in user space.
 After this call the current point will be offset by <i>rp1</i>.
<p></p>
Given a current point of (x, y), cairo_rel_line_to(cr, dx, dy)
 is logically equivalent to cairo_line_to(cr, x + dx, y + dy).
<p></p>

 It is an error to call this function with no current point.
 Doing so will cause an CairoException with a
 status of CAIRO_STATUS_NO_CURRENT_POINT.<p></p>

</dd>
<dt class="d_decl">void <a name="relMoveTo"></a><span class="ddoc_psymbol">relMoveTo</span>(Point <i>rp1</i>);
<br>void <a name="relMoveTo"></a><span class="ddoc_psymbol">relMoveTo</span>(double <i>x</i>, double <i>y</i>);
</dt>
<dd>Begin a new sub-path. After this call the current point will
 offset by <i>rp1</i>.
<p></p>
Given a current point of (x, y), cairo_rel_move_to(cr, dx, dy)
 is logically equivalent to cairo_move_to(cr, x + dx, y + dy).
<p></p>

 It is an error to call this function with no current point.
 Doing so will cause an CairoException with a status of
 CAIRO_STATUS_NO_CURRENT_POINT.<p></p>

</dd>
<dt class="d_decl">Box <a name="pathExtends"></a><span class="ddoc_psymbol">pathExtends</span>();
</dt>
<dd>Computes a bounding box in user-space coordinates covering
 the points on the current path. If the current path is empty,
 returns an empty Box ((0,0), (0,0)). Stroke parameters,
 fill rule, surface dimensions and clipping are not taken
 into account.
<p></p>
Contrast with <span class="d_inlinecode">fillExtents()</span> and <span class="d_inlinecode">strokeExtents()</span>
 which return the extents of only the area that would be "inked"
 by the corresponding drawing operations.
<p></p>

 The result of <span class="d_inlinecode">pathExtents()</span> is defined as equivalent
 to the limit of <span class="d_inlinecode">strokeExtents()</span> with CAIRO_LINE_CAP_ROUND
 as the line width approaches 0.0, (but never reaching the
 empty-rectangle returned by <span class="d_inlinecode">strokeExtents()</span> for a
 line width of 0.0).
<p></p>

 Specifically, this means that zero-area sub-paths such as
 <span class="d_inlinecode">moveTo()</span>;<span class="d_inlinecode">lineTo()</span> segments, (even degenerate
 cases where the coordinates to both calls are identical),
 will be considered as contributing to the extents. However,
 a lone <span class="d_inlinecode">moveTo()</span> will not contribute to the
 results of <span class="d_inlinecode">pathExtents()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="translate"></a><span class="ddoc_psymbol">translate</span>(double <i>tx</i>, double <i>ty</i>);
</dt>
<dd>Modifies the current transformation matrix (CTM) by translating
 the user-space origin by (<i>tx</i>, <i>ty</i>). This offset is interpreted
 as a user-space coordinate according to the CTM in place
 before the new call to <span class="d_inlinecode"><a name="translate"></a><span class="ddoc_psymbol">translate</span>()</span>. In other words,
 the translation of the user-space origin takes place
 after any existing transformation.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>tx</i></td>
<td valign=top>amount to <a name="translate"></a><span class="ddoc_psymbol">translate</span> in the X direction</td></tr>
<tr><td valign=top>double <i>ty</i></td>
<td valign=top>amount to <a name="translate"></a><span class="ddoc_psymbol">translate</span> in the Y direction</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="scale"></a><span class="ddoc_psymbol">scale</span>(double <i>sx</i>, double <i>sy</i>);
<br>void <a name="scale"></a><span class="ddoc_psymbol">scale</span>(Point <i>point</i>);
</dt>
<dd>Modifies the current transformation matrix (CTM) by scaling
 the X and Y user-space axes by <i>sx</i> and <i>sy</i> respectively.
 The scaling of the axes takes place after any existing
 transformation of user space.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>sx</i></td>
<td valign=top><a name="scale"></a><span class="ddoc_psymbol">scale</span> factor for the X dimension</td></tr>
<tr><td valign=top>double <i>sy</i></td>
<td valign=top><a name="scale"></a><span class="ddoc_psymbol">scale</span> factor for the Y dimension</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="rotate"></a><span class="ddoc_psymbol">rotate</span>(double <i>angle</i>);
</dt>
<dd>Modifies the current transformation matrix (CTM) by rotating
 the user-space axes by <i>angle</i> radians. The rotation of the
 axes takes places after any existing transformation of user
 space. The rotation direction for positive angles is from
 the positive X axis toward the positive Y axis.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>angle</i></td>
<td valign=top><i>angle</i> (in radians) by which the user-space axes will be rotated</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="transform"></a><span class="ddoc_psymbol">transform</span>(const Matrix <i>matrix</i>);
</dt>
<dd>Modifies the current transformation <i>matrix</i> (CTM) by applying
 <i>matrix</i> as an additional transformation. The new
 transformation of user space takes place after any
 existing transformation.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Matrix <i>matrix</i></td>
<td valign=top>a transformation to be applied to the user-space axes</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="setMatrix"></a><span class="ddoc_psymbol">setMatrix</span>(const Matrix <i>matrix</i>);
</dt>
<dd>Modifies the current transformation <i>matrix</i> (CTM) by setting it
 equal to <i>matrix</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Matrix</td>
<td valign=top>a transformation <i>matrix</i> from user space to device space</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">Matrix <a name="getMatrix"></a><span class="ddoc_psymbol">getMatrix</span>();
</dt>
<dd>Returns the current transformation matrix (CTM)<p></p>

</dd>
<dt class="d_decl">void <a name="identityMatrix"></a><span class="ddoc_psymbol">identityMatrix</span>();
</dt>
<dd>Resets the current transformation matrix (CTM) by setting it
 equal to the identity matrix. That is, the user-space and
 device-space axes will be aligned and one user-space unit
 will transform to one device-space unit.<p></p>

</dd>
<dt class="d_decl">Point <a name="userToDevice"></a><span class="ddoc_psymbol">userToDevice</span>(Point <i>inp</i>);
</dt>
<dd>Transform a coordinate from user space to device space by
 multiplying the given point by the current
 transformation matrix (CTM).<p></p>

</dd>
<dt class="d_decl">Point <a name="userToDeviceDistance"></a><span class="ddoc_psymbol">userToDeviceDistance</span>(Point <i>inp</i>);
</dt>
<dd>Transform a distance vector from user space to device space.
 This function is similar to <span class="d_inlinecode">userToDevice()</span> except that
 the translation components of the CTM will be ignored when
 transforming <i>inp</i>.<p></p>

</dd>
<dt class="d_decl">Point <a name="deviceToUser"></a><span class="ddoc_psymbol">deviceToUser</span>(Point <i>inp</i>);
</dt>
<dd>Transform a coordinate from device space to user space by
 multiplying the given point by the inverse of the current
 transformation matrix (CTM).<p></p>

</dd>
<dt class="d_decl">Point <a name="deviceToUserDistance"></a><span class="ddoc_psymbol">deviceToUserDistance</span>(Point <i>inp</i>);
</dt>
<dd>Transform a distance vector from device space to user space.
 This function is similar to <span class="d_inlinecode">deviceToUser()</span> except that
 the translation components of the inverse CTM will be ignored
 when transforming <i>inp</i>.<p></p>

</dd>
<dt class="d_decl">void <a name="selectFontFace"></a><span class="ddoc_psymbol">selectFontFace</span>(string <i>family</i>, FontSlant <i>slant</i>, FontWeight <i>weight</i>);
</dt>
<dd><b>Note:</b><br>
The <span class="d_inlinecode"><a name="selectFontFace"></a><span class="ddoc_psymbol">selectFontFace</span>()</span> function call is part of
 what the cairo designers call the "toy" text API. It
 is convenient for short demos and simple programs, but
 it is not expected to be adequate for serious text-using
 applications.
<p></p>

 Selects a <i>family</i> and style of font from a simplified description
 as a <i>family</i> name, <i>slant</i> and <i>weight</i>. Cairo provides no
 operation to list available <i>family</i> names on the system
 (this is a "toy", remember), but the standard CSS2 generic
 <i>family</i> names, ("serif", "sans-serif", "cursive", "fantasy",
 "monospace"), are likely to work as expected.
<p></p>

 If <i>family</i> starts with the string "cairo:", or if no native
 font backends are compiled in, cairo will use an internal
 font <i>family</i>. The internal font <i>family</i> recognizes many
 modifiers in the <i>family</i> string, most notably, it recognizes
 the string "monospace". That is, the <i>family</i> name
 "cairo:monospace" will use the monospace version of the
 internal font <i>family</i>.
<p></p>

 For "real" font selection, see the font-backend-specific
 <span class="d_inlinecode">FontFace</span> classes for the font backend you are using.
 (For example, if you are using the freetype-based cairo-ft
 font backend, see <span class="d_inlinecode">FTFontFace</span>)
<p></p>

 The resulting font face could then be used
 with <span class="d_inlinecode">ScaledFont</span> and <span class="d_inlinecode">Context.setScaledFont()</span>.
<p></p>

 Similarly, when using the "real" font support, you can call
 directly into the underlying font system, (such as
 fontconfig or freetype), for operations such as listing
 available fonts, etc.
<p></p>

 It is expected that most applications will need to use a more
 comprehensive font handling and text layout library,
 (for example, pango), in conjunction with cairo.
<p></p>

 If text is drawn without a call to <span class="d_inlinecode"><a name="selectFontFace"></a><span class="ddoc_psymbol">selectFontFace</span>()</span>,
 (nor <span class="d_inlinecode">setFontFace()</span> nor <span class="d_inlinecode">setScaledFont()</span>),
 the default <i>family</i> is platform-specific, but is essentially
 "sans-serif". Default <i>slant</i> is CAIRO_FONT_SLANT_NORMAL,
 and default <i>weight</i> is CAIRO_FONT_WEIGHT_NORMAL.
<p></p>

 This function is equivalent to a call to
 <span class="d_inlinecode">toyFontFaceCreate()</span> followed by <span class="d_inlinecode">setFontFace()</span>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>family</i></td>
<td valign=top>a font <i>family</i> name, encoded in UTF-8</td></tr>
<tr><td valign=top>FontSlant <i>slant</i></td>
<td valign=top>the <i>slant</i> for the font</td></tr>
<tr><td valign=top>FontWeight <i>weight</i></td>
<td valign=top>the <i>weight</i> for the font</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="setFontSize"></a><span class="ddoc_psymbol">setFontSize</span>(double <i>size</i>);
</dt>
<dd>Sets the current font matrix to a scale by a factor of <i>size</i>,
 replacing any font matrix previously set with <span class="d_inlinecode"><a name="setFontSize"></a><span class="ddoc_psymbol">setFontSize</span>()</span>
 or <span class="d_inlinecode">setFontMatrix()</span>. This results in a font <i>size</i> of
 <i>size</i> user space units. (More precisely, this matrix will
 result in the font's em-square being a <i>size</i> by <i>size</i>
 square in user space.)
<p></p>
If text is drawn without a call to <span class="d_inlinecode"><a name="setFontSize"></a><span class="ddoc_psymbol">setFontSize</span>()</span>,
 (nor <span class="d_inlinecode">setFontMatrix()</span> nor <span class="d_inlinecode">setScaledFont()</span>),
 the default font <i>size</i> is 10.0.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>size</i></td>
<td valign=top>the new font <i>size</i>, in user space units</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="setFontMatrix"></a><span class="ddoc_psymbol">setFontMatrix</span>(Matrix <i>matrix</i>);
</dt>
<dd>Sets the current font <i>matrix</i> to <i>matrix</i>. The font <i>matrix</i> gives
 a transformation from the design space of the font (in this
 space, the em-square is 1 unit by 1 unit) to user space.
 Normally, a simple scale is used (see <span class="d_inlinecode">setFontSize()</span>),
 but a more complex font <i>matrix</i> can be used to shear the font
 or stretch it unequally along the two axes
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Matrix <i>matrix</i></td>
<td valign=top>a <span class="d_inlinecode">Matrix</span> describing a transform to be applied
 to the current font.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">Matrix <a name="getFontMatrix"></a><span class="ddoc_psymbol">getFontMatrix</span>();
</dt>
<dd>Returns the current font matrix. See <span class="d_inlinecode">setFontMatrix</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="setFontOptions"></a><span class="ddoc_psymbol">setFontOptions</span>(FontOptions <i>options</i>);
</dt>
<dd>Sets a set of custom font rendering <i>options</i> for the
 <span class="d_inlinecode">Context</span>. Rendering <i>options</i> are derived by merging these
 <i>options</i> with the <i>options</i> derived from underlying surface;
 if the value in <i>options</i> has a default value (like CAIRO_ANTIALIAS_DEFAULT),
 then the value from the surface is used.<p></p>

</dd>
<dt class="d_decl">FontOptions <a name="getFontOptions"></a><span class="ddoc_psymbol">getFontOptions</span>();
</dt>
<dd>Retrieves font rendering options set via <span class="d_inlinecode">setFontOptions()</span>.
 Note that the returned options do not include any options
 derived from the underlying surface; they are literally
 the options passed to <span class="d_inlinecode">setFontOptions()</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="setFontFace"></a><span class="ddoc_psymbol">setFontFace</span>(FontFace <i>font_face</i>);
</dt>
<dd>Replaces the current <span class="d_inlinecode">FontFace</span> object in the <span class="d_inlinecode">Context</span>
 with <i>font_face</i>. The replaced font face in the <span class="d_inlinecode">Context</span> will
 be destroyed if there are no other references to it.<p></p>

</dd>
<dt class="d_decl">void <a name="setFontFace"></a><span class="ddoc_psymbol">setFontFace</span>();
</dt>
<dd>Replaces the current <span class="d_inlinecode">FontFace</span> object in the <span class="d_inlinecode">Context</span>
 with the default font.<p></p>

</dd>
<dt class="d_decl">FontFace <a name="getFontFace"></a><span class="ddoc_psymbol">getFontFace</span>();
</dt>
<dd>Gets the current font face for a <span class="d_inlinecode">Context</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="setScaledFont"></a><span class="ddoc_psymbol">setScaledFont</span>(ScaledFont <i>scaled_font</i>);
</dt>
<dd>Replaces the current font face, font matrix, and font options
 in the <span class="d_inlinecode">Context</span> with those of the <span class="d_inlinecode">ScaledFont</span>. Except
 for some translation, the current CTM of the cairo_t should be
 the same as that of the <span class="d_inlinecode">ScaledFont</span>, which can be
 accessed using <span class="d_inlinecode">ScaledFont.getCTM()</span>.<p></p>

</dd>
<dt class="d_decl">ScaledFont <a name="getScaledFont"></a><span class="ddoc_psymbol">getScaledFont</span>();
</dt>
<dd>Gets the current scaled font for a <span class="d_inlinecode">Context</span>.<p></p>

</dd>
<dt class="d_decl">void <a name="showText"></a><span class="ddoc_psymbol">showText</span>(string <i>text</i>);
</dt>
<dd>A drawing operator that generates the shape from a string of
 UTF-8 characters, rendered according to the current
 fontFace, fontSize (fontMatrix), and fontOptions.
<p></p>
This function first computes a set of glyphs for the string
 of <i>text</i>. The first glyph is placed so that its origin is
 at the current point. The origin of each subsequent glyph
 is offset from that of the previous glyph by the advance
 values of the previous glyph.
<p></p>

 After this call the current point is moved to the origin
 of where the next glyph would be placed in this same
 progression. That is, the current point will be at the
 origin of the final glyph offset by its advance values.
 This allows for easy display of a single logical string
 with multiple calls to <span class="d_inlinecode"><a name="showText"></a><span class="ddoc_psymbol">showText</span>()</span>.

<p></p>
<b>Note:</b><br>
The <span class="d_inlinecode"><a name="showText"></a><span class="ddoc_psymbol">showText</span>()</span> function call is part of
 what the cairo designers call the "toy" <i>text</i> API. It
 is convenient for short demos and simple programs, but
 it is not expected to be adequate for serious <i>text</i>-using
 applications. See <span class="d_inlinecode">showGlyphs()</span> for the "real" <i>text</i>
 display API in cairo.<p></p>

</dd>
<dt class="d_decl">void <a name="showGlyphs"></a><span class="ddoc_psymbol">showGlyphs</span>(cairo_glyph_t[] <i>glyphs</i>);
</dt>
<dd>A drawing operator that generates the shape from an array of
 <i>glyphs</i>, rendered according to the current fontFace,
 fontSize (fontMatrix), and font options.<p></p>

</dd>
<dt class="d_decl">void <a name="showTextGlyphs"></a><span class="ddoc_psymbol">showTextGlyphs</span>(TextGlyph <i>glyph</i>);
</dt>
<dd>This operation has rendering effects similar to <span class="d_inlinecode">showGlyphs()</span>
 but, if the target surface supports it, uses the provided
 text and cluster mapping to embed the text for the glyphs
 shown in the output. If the target does not support the
 extended attributes, this function acts like the basic
 <span class="d_inlinecode">showGlyphs()</span>.<p></p>

</dd>
<dt class="d_decl">FontExtents <a name="fontExtents"></a><span class="ddoc_psymbol">fontExtents</span>();
</dt>
<dd>Gets the font extents for the currently selected font.<p></p>

</dd>
<dt class="d_decl">TextExtents <a name="textExtents"></a><span class="ddoc_psymbol">textExtents</span>(string <i>text</i>);
</dt>
<dd>Gets the extents for a string of <i>text</i>. The extents describe
 a user-space rectangle that encloses the "inked"
 portion of the <i>text</i>, (as it would be drawn by <span class="d_inlinecode">showText()</span>).
 Additionally, the x_advance and y_advance values indicate
 the amount by which the current point would be advanced
 by <span class="d_inlinecode">showText()</span>.
<p></p>
Note that whitespace characters do not directly contribute
 to the size of the rectangle (extents.width and extents.height).
 They do contribute indirectly by changing the position of
 non-whitespace characters. In particular, trailing whitespace
 characters are likely to not affect the size of the rectangle,
 though they will affect the x_advance and y_advance values.<p></p>

</dd>
<dt class="d_decl">TextExtents <a name="glyphExtents"></a><span class="ddoc_psymbol">glyphExtents</span>(cairo_glyph_t[] <i>glyphs</i>);
</dt>
<dd>Gets the extents for an array of <i>glyphs</i>. The extents describe
 a user-space rectangle that encloses the "inked" portion of
 the <i>glyphs</i>, (as they would be drawn by <span class="d_inlinecode">showGlyphs()</span>).
 Additionally, the x_advance and y_advance values indicate
 the amount by which the current point would be advanced by
 <span class="d_inlinecode">showGlyphs()</span>.
<p></p>
Note that whitespace <i>glyphs</i> do not contribute to the size of
 the rectangle (extents.width and extents.height).<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="FontOptions"></a><span class="ddoc_psymbol">FontOptions</span>;
</dt>
<dd><span class="d_inlinecode"><a name="FontOptions"></a><span class="ddoc_psymbol">FontOptions</span></span> - How a font should be rendered
<p></p>
The font options specify how fonts should be rendered. Most of the
 time the font options implied by a surface are just right and do
 not need any changes, but for pixel-based targets tweaking font
 options may result in superior output on a particular display.

<p></p>
<b>Warning:</b><br>
Instances must be created with opCall!
<pre class="d_code"> <span class="d_keyword">auto</span> options = <span class="d_psymbol">FontOptions</span>(); <span class="d_comment">//Correct
</span> options.toHash();
</pre>

<pre class="d_code"> <span class="d_psymbol">FontOptions</span> options; <span class="d_comment">//Wrong
</span> options.toHash();
</pre>

<pre class="d_code"> <span class="d_psymbol">FontOptions</span> options;
 options = <span class="d_psymbol">FontOptions</span>(); <span class="d_comment">//Correct
</span> options.toHash();
</pre>
<p></p>

<dl><dt class="d_decl">@property cairo_font_options_t* <a name="nativePointer"></a><span class="ddoc_psymbol">nativePointer</span>();
</dt>
<dd>The underlying <span class="d_inlinecode">cairo_font_options_t*</span> handle<p></p>

</dd>
<dt class="d_decl">@property bool <a name="debugging"></a><span class="ddoc_psymbol">debugging</span>();
<br>@property void <a name="debugging"></a><span class="ddoc_psymbol">debugging</span>(bool <i>value</i>);
</dt>
<dd>Enable / disable memory management <a name="debugging"></a><span class="ddoc_psymbol">debugging</span> for this FontOptions
 instance. Only available if both cairoD and the cairoD user
 code were compiled with "debug=RefCounted"
<p></p>
Output is written to stdout, see
 <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging">https://github.com/jpf91/cairoD/wiki/Memory-Management#debugging</a>
 for more information<p></p>

</dd>
<dt class="d_decl">static FontOptions <a name="opCall"></a><span class="ddoc_psymbol">opCall</span>();
</dt>
<dd>Allocates a new font options object with all
 options initialized to default values.<p></p>

</dd>
<dt class="d_decl">this(cairo_font_options_t* <i>ptr</i>);
</dt>
<dd>Create <span class="d_inlinecode">FontOptions</span> from a existing <span class="d_inlinecode">cairo_font_options_t*</span>.
 FontOptions is a reference counted struct. It will call
 <span class="d_inlinecode">cairo_font_options_destroy</span> when it's reference count is 0.
 See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#2.2-structs">https://github.com/jpf91/cairoD/wiki/Memory-Management#2.2-structs</a>
 for more information.
<p></p>
<b>Warning:</b><br>
<span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">FontOptions <a name="copy"></a><span class="ddoc_psymbol">copy</span>();
</dt>
<dd>Allocates a new font options object copying the option values
 from original.
<p></p>
This new object's reference counting is independent from the
 current object's.<p></p>

</dd>
<dt class="d_decl">void <a name="merge"></a><span class="ddoc_psymbol">merge</span>(FontOptions <i>other</i>);
</dt>
<dd>Merges non-default options from <i>other</i> into this object,
 replacing existing values. This operation can be thought
 of as somewhat similar to compositing <i>other</i> onto options
 with the operation of CAIRO_OPERATION_OVER.<p></p>

</dd>
<dt class="d_decl">size_t <a name="toHash"></a><span class="ddoc_psymbol">toHash</span>();
</dt>
<dd>Compute a hash for the font options object; this value
 will be useful when storing an object containing a
 FontOptions in a hash table.<p></p>

</dd>
<dt class="d_decl">const const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(ref const(FontOptions) <i>other</i>);
</dt>
<dd>Compares two font options objects for equality.
<p></p>
<b>Returns:</b><br><b>true</b> if all fields of the two font options objects match.
 Note that this function will return <b>false</b> if either object is
 in error.<p></p>

</dd>
<dt class="d_decl">void <a name="setAntiAlias"></a><span class="ddoc_psymbol">setAntiAlias</span>(AntiAlias <i>antialias</i>);
</dt>
<dd>Sets the antialiasing mode for the font options object. This
 specifies the type of antialiasing to do when rendering text.<p></p>

</dd>
<dt class="d_decl">AntiAlias <a name="getAntiAlias"></a><span class="ddoc_psymbol">getAntiAlias</span>();
</dt>
<dd>Gets the antialiasing mode for the font options object.<p></p>

</dd>
<dt class="d_decl">void <a name="setSubpixelOrder"></a><span class="ddoc_psymbol">setSubpixelOrder</span>(SubpixelOrder <i>order</i>);
</dt>
<dd>Sets the subpixel <i>order</i> for the font options object.
 The subpixel <i>order</i> specifies the <i>order</i> of color elements
 within each pixel on the display device when rendering with
 an antialiasing mode of CAIRO_ANTIALIAS_SUBPIXEL.
 See the documentation for <span class="d_inlinecode">SubpixelOrder</span> for full details.<p></p>

</dd>
<dt class="d_decl">SubpixelOrder <a name="getSubpixelOrder"></a><span class="ddoc_psymbol">getSubpixelOrder</span>();
</dt>
<dd>Gets the subpixel order for the font options object.
 See the documentation for <span class="d_inlinecode">SubpixelOrder</span> for full details.<p></p>

</dd>
<dt class="d_decl">void <a name="setHintStyle"></a><span class="ddoc_psymbol">setHintStyle</span>(HintStyle <i>style</i>);
</dt>
<dd>Sets the hint <i>style</i> for font outlines for the font options object.
 This controls whether to fit font outlines to the pixel grid,
 and if so, whether to optimize for fidelity or contrast.
 See the documentation for <span class="d_inlinecode">HintStyle</span> for full details.<p></p>

</dd>
<dt class="d_decl">HintStyle <a name="getHintStyle"></a><span class="ddoc_psymbol">getHintStyle</span>();
</dt>
<dd>Gets the hint style for font outlines for the font options object.
 See the documentation for <span class="d_inlinecode">HintStyle</span> for full details.<p></p>

</dd>
<dt class="d_decl">void <a name="setHintMetrics"></a><span class="ddoc_psymbol">setHintMetrics</span>(HintMetrics <i>metrics</i>);
</dt>
<dd>Sets the <i>metrics</i> hinting mode for the font options object.
 This controls whether <i>metrics</i> are quantized to integer
 values in device units. See the documentation for
 <span class="d_inlinecode">HintMetrics</span> for full details.<p></p>

</dd>
<dt class="d_decl">HintMetrics <a name="getHintMetrics"></a><span class="ddoc_psymbol">getHintMetrics</span>();
</dt>
<dd>Gets the metrics hinting mode for the font options object.
 See the documentation for <span class="d_inlinecode">HintMetrics</span> for full details.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="TextGlyph"></a><span class="ddoc_psymbol">TextGlyph</span>;
</dt>
<dd>The mapping between utf8 and glyphs is provided by an array
 of clusters. Each cluster covers a number of text bytes and
 glyphs, and neighboring clusters cover neighboring areas of
 utf8 and glyphs. The clusters should collectively cover
 utf8 and glyphs in entirety.
<p></p>
The first cluster always covers bytes from the beginning of
 utf8. If cluster_flags do not have the
 CAIRO_TEXT_CLUSTER_FLAG_BACKWARD set, the first cluster also
 covers the beginning of glyphs, otherwise it covers the end
 of the glyphs array and following clusters move backward.
<p></p>

 See cairo_text_cluster_t for constraints on valid clusters.<p></p>

<dl><dt class="d_decl">cairo_glyph_t[] <a name="glyphs"></a><span class="ddoc_psymbol">glyphs</span>;
</dt>
<dd>array of <a name="glyphs"></a><span class="ddoc_psymbol">glyphs</span><p></p>

</dd>
<dt class="d_decl">cairo_text_cluster_t[] <a name="cluster"></a><span class="ddoc_psymbol">cluster</span>;
</dt>
<dd>array of <a name="cluster"></a><span class="ddoc_psymbol">cluster</span> mapping information<p></p>

</dd>
<dt class="d_decl">string <a name="text"></a><span class="ddoc_psymbol">text</span>;
</dt>
<dd>a string of <a name="text"></a><span class="ddoc_psymbol">text</span> encoded in UTF-8<p></p>

</dd>
<dt class="d_decl">TextClusterFlags <a name="flags"></a><span class="ddoc_psymbol">flags</span>;
</dt>
<dd>cluster mapping <a name="flags"></a><span class="ddoc_psymbol">flags</span><p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">class <a name="ScaledFont"></a><span class="ddoc_psymbol">ScaledFont</span>;
</dt>
<dd>Font face at particular size and options
<p></p>
<span class="d_inlinecode"><a name="ScaledFont"></a><span class="ddoc_psymbol">ScaledFont</span></span> represents a realization of a font face at a particular
 size and transformation and a certain set of font options.<p></p>

<dl><dt class="d_decl">protected final void <a name="checkError"></a><span class="ddoc_psymbol">checkError</span>();
</dt>
<dd>Method for use in subclasses.
 Calls <span class="d_inlinecode">cairo_scaled_font_status(nativePointer)</span> and throws
 an exception if the status isn't CAIRO_STATUS_SUCCESS<p></p>

</dd>
<dt class="d_decl">this(cairo_scaled_font_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">ScaledFont</span> from a existing <span class="d_inlinecode">cairo_scaled_font_t*</span>.
 ScaledFont is a garbage collected class. It will call <span class="d_inlinecode">cairo_scaled_font_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">this(FontFace <i>font_face</i>, Matrix <i>font_matrix</i>, Matrix <i>ctm</i>, FontOptions <i>options</i>);
</dt>
<dd>Creates a <span class="d_inlinecode">ScaledFont</span> object from a font face and
 matrices that describe the size of the font and the
 environment in which it will be used.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Matrix <i>font_matrix</i></td>
<td valign=top>font space to user space transformation matrix
   for the font. In the simplest case of a N point font, this
   matrix is just a scale by N, but it can also be used to
   shear the font or stretch it unequally along the two axes.
   See <span class="d_inlinecode">Context.setFontMatrix()</span>.</td></tr>
<tr><td valign=top>Matrix <i>ctm</i></td>
<td valign=top>user to device transformation matrix with which
   the font will be used.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">static ScaledFont <a name="createFromNative"></a><span class="ddoc_psymbol">createFromNative</span>(cairo_scaled_font_t* <i>ptr</i>, bool <i>adjRefCount</i> = true);
</dt>
<dd>The <a name="createFromNative"></a><span class="ddoc_psymbol">createFromNative</span> method for the ScaledFont classes.
 See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative">https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative</a>
 for more information.
<p></p>
<b>Warning:</b><br>
<span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">FontExtents <a name="extents"></a><span class="ddoc_psymbol">extents</span>();
</dt>
<dd>Gets the metrics for a <span class="d_inlinecode">ScaledFont</span>.<p></p>

</dd>
<dt class="d_decl">TextExtents <a name="textExtents"></a><span class="ddoc_psymbol">textExtents</span>(string <i>text</i>);
</dt>
<dd>Gets the extents for a string of <i>text</i>. The extents describe a
 user-space rectangle that encloses the "inked" portion of the
 <i>text</i> drawn at the origin (0,0) (as it would be drawn by
 <span class="d_inlinecode">Context.showText()</span> if the cairo graphics state were set
 to the same fontFace, fontMatrix, ctm, and fontOptions
 as <span class="d_inlinecode">ScaledFont</span>). Additionally, the x_advance and y_advance
 values indicate the amount by which the current point would
 be advanced by <span class="d_inlinecode">Context.showText()</span>.
<p></p>
Note that whitespace characters do not directly contribute
 to the size of the rectangle (extents.width and extents.height).
 They do contribute indirectly by changing the position of
 non-whitespace characters. In particular, trailing whitespace
 characters are likely to not affect the size of the
 rectangle, though they will affect the x_advance
 and y_advance values.<p></p>

</dd>
<dt class="d_decl">TextExtents <a name="glyphExtents"></a><span class="ddoc_psymbol">glyphExtents</span>(cairo_glyph_t[] <i>glyphs</i>);
</dt>
<dd>Gets the extents for an array of <i>glyphs</i>. The extents describe
 a user-space rectangle that encloses the "inked" portion
 of the <i>glyphs</i>, (as they would be drawn by <span class="d_inlinecode">Context.showGlyphs()</span>
 if the cairo graphics state were set to the same fontFace,
 fontMatrix, ctm, and fontOptions as scaled_font). Additionally,
 the x_advance and y_advance values indicate the amount by
 which the current point would be advanced by <span class="d_inlinecode">Context.showGlyphs()</span>.
<p></p>
Note that whitespace <i>glyphs</i> do not contribute to the size
 of the rectangle (extents.width and extents.height).<p></p>

</dd>
<dt class="d_decl">cairo_glyph_t[] <a name="textToGlyphs"></a><span class="ddoc_psymbol">textToGlyphs</span>(double <i>x</i>, double <i>y</i>, string <i>text</i>, cairo_glyph_t[] <i>glyphBuffer</i> = []);
<br>cairo_glyph_t[] <a name="textToGlyphs"></a><span class="ddoc_psymbol">textToGlyphs</span>(Point <i>p1</i>, string <i>text</i>, cairo_glyph_t[] <i>glyphBuffer</i> = []);
<br>TextGlyph <a name="textToTextGlyph"></a><span class="ddoc_psymbol">textToTextGlyph</span>(double <i>x</i>, double <i>y</i>, string <i>text</i>, cairo_glyph_t[] <i>glyphBuffer</i> = [], cairo_text_cluster_t[] <i>clusterBuffer</i> = []);
<br>TextGlyph <a name="textToTextGlyph"></a><span class="ddoc_psymbol">textToTextGlyph</span>(Point <i>p1</i>, string <i>text</i>, cairo_glyph_t[] <i>glyphBuffer</i> = [], cairo_text_cluster_t[] <i>clusterBuffer</i> = []);
</dt>
<dd>Converts UTF-8 <i>text</i> to an array of glyphs, optionally with
 cluster mapping, that can be used to render later using ScaledFont.
<p></p>
If <i>glyphBuffer</i> initially points to a non-empty array, that array is
 used as a glyph buffer. If the provided glyph array is too
 short for the conversion, a new glyph array is allocated and returned.
<p></p>

 If clusterBuffer is not empty a cluster mapping will be computed.
 The semantics of how cluster array allocation works is similar to the glyph array.
 That is, if clusterBuffer initially points to a non-empty array,
 that array is used as a cluster buffer.
 If the provided cluster array is too short for the conversion,
 a new cluster array is allocated and returned.
<p></p>

 In the simplest case, glyphs and clusters can be omitted
 or set to an empty array and a suitable array will be allocated.
 In code
<pre class="d_code"> <span class="d_keyword">auto</span> glyphs = scaled_font.textToTextGlyph(<span class="d_param">x</span>, <span class="d_param">y</span>, <span class="d_param">text</span>);
 cr.showTextGlyphs(glyphs);
</pre>
 If no cluster mapping is needed
<pre class="d_code"> <span class="d_keyword">auto</span> glyphs = scaled_font.<span class="d_psymbol">textToGlyphs</span>(<span class="d_param">x</span>, <span class="d_param">y</span>, <span class="d_param">text</span>);
 cr.showGlyphs(glyphs);
</pre>
 If stack-based glyph and cluster arrays are to be used for small arrays
<pre class="d_code"> Glyph[40] stack_glyphs;
 TextCluster[40] stack_clusters;
 <span class="d_keyword">auto</span> glyphs = scaled_font.textToTextGlyph(<span class="d_param">x</span>, <span class="d_param">y</span>, <span class="d_param">text</span>, stack_glyphs, stack_clusters);
 cr.showTextGlyphs(glyphs);
</pre>

 The output values can be readily passed to <span class="d_inlinecode">Context.showTextGlyphs()</span>
 <span class="d_inlinecode">Context.showGlyphs()</span>, or related functions, assuming that
 the exact same ScaledFont is used for the operation.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>double <i>x</i></td>
<td valign=top>X position to place first glyph</td></tr>
<tr><td valign=top>double <i>y</i></td>
<td valign=top>Y position to place first glyph</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">FontFace <a name="getFontFace"></a><span class="ddoc_psymbol">getFontFace</span>();
</dt>
<dd>Gets the font face that this scaled font uses. This is the
 font face passed to <span class="d_inlinecode">new ScaledFont()</span>.<p></p>

</dd>
<dt class="d_decl">FontOptions <a name="getFontOptions"></a><span class="ddoc_psymbol">getFontOptions</span>();
</dt>
<dd>Returns the font options with which ScaledFont
 was created.<p></p>

</dd>
<dt class="d_decl">Matrix <a name="getFontMatrix"></a><span class="ddoc_psymbol">getFontMatrix</span>();
</dt>
<dd>Returns the font matrix with which ScaledFont
 was created.<p></p>

</dd>
<dt class="d_decl">Matrix <a name="getCTM"></a><span class="ddoc_psymbol">getCTM</span>();
</dt>
<dd>Returns the CTM with which ScaledFont was created.
 Note that the translation offsets (x0, y0) of the CTM are
 ignored by <span class="d_inlinecode">new ScaledFont()</span>. So, the matrix this function
 returns always has 0,0 as x0,y0.<p></p>

</dd>
<dt class="d_decl">Matrix <a name="getScaleMatrix"></a><span class="ddoc_psymbol">getScaleMatrix</span>();
</dt>
<dd>Returns the scale matrix of ScaledFont.
 The scale matrix is product of the font matrix and the
 ctm associated with the scaled font, and hence is the
 matrix mapping from font space to device space.<p></p>

</dd>
<dt class="d_decl">FontType <a name="getType"></a><span class="ddoc_psymbol">getType</span>();
</dt>
<dd>This function returns the C type of a ScaledFont. See <span class="d_inlinecode">FontType</span>
 for available types.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">class <a name="FontFace"></a><span class="ddoc_psymbol">FontFace</span>;
</dt>
<dd>Base class for font faces
<p></p>
<span class="d_inlinecode"><a name="FontFace"></a><span class="ddoc_psymbol">FontFace</span></span> represents a particular font at a particular weight,
 slant, and other characteristic but no size, transformation, or size.
<p></p>

 Font faces are created using font-backend-specific classes,
 typically of the form <span class="d_inlinecode">*<a name="FontFace"></a><span class="ddoc_psymbol">FontFace</span></span>, or implicitly
 using the toy text API by way of <span class="d_inlinecode">Context.selectFontFace()</span>. The
 resulting face can be accessed using <span class="d_inlinecode">Context.getFontFace()</span>.<p></p>

<dl><dt class="d_decl">protected final void <a name="checkError"></a><span class="ddoc_psymbol">checkError</span>();
</dt>
<dd>Method for use in subclasses.
 Calls <span class="d_inlinecode">cairo_font_face_status(nativePointer)</span> and throws
 an exception if the status isn't CAIRO_STATUS_SUCCESS<p></p>

</dd>
<dt class="d_decl">this(cairo_font_face_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">FontFace</span> from a existing <span class="d_inlinecode">cairo_font_face_t*</span>.
 FontFace is a garbage collected class. It will call <span class="d_inlinecode">cairo_font_face_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">static FontFace <a name="createFromNative"></a><span class="ddoc_psymbol">createFromNative</span>(cairo_font_face_t* <i>ptr</i>, bool <i>adjRefCount</i> = true);
</dt>
<dd>The <a name="createFromNative"></a><span class="ddoc_psymbol">createFromNative</span> method for the FontFace classes.
 See <a href="https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative">https://github.com/jpf91/cairoD/wiki/Memory-Management#createFromNative</a>
 for more information.
<p></p>
<b>Warning:</b><br>
<span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">FontType <a name="getType"></a><span class="ddoc_psymbol">getType</span>();
</dt>
<dd>This function returns the C type of a FontFace. See <span class="d_inlinecode">FontType</span>
 for available types.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">class <a name="ToyFontFace"></a><span class="ddoc_psymbol">ToyFontFace</span>: cairo.cairo.FontFace;
</dt>
<dd>Cairo toy font api's FontFace<p></p>

<dl><dt class="d_decl">this(cairo_font_face_t* <i>ptr</i>);
</dt>
<dd>Create a <span class="d_inlinecode">ToyFontFace</span> from a existing <span class="d_inlinecode">cairo_font_face_t*</span>.
 ToyFontFace is a garbage collected class. It will call <span class="d_inlinecode">cairo_surface_destroy</span>
 when it gets collected by the GC or when <span class="d_inlinecode">dispose()</span> is called.
<p></p>
<b>Warning:</b><br>
<span class="d_inlinecode"><i>ptr</i></span>'s reference count is not increased by this function!
 Adjust reference count before calling it if necessary
<p></p>

 <span style="color:red">Only use this if you know what your doing!
 This function should not be needed for standard cairoD usage.</span><p></p>

</dd>
<dt class="d_decl">this(string <i>family</i>, FontSlant <i>slant</i>, FontWeight <i>weight</i>);
</dt>
<dd>Creates a font face from a triplet of <i>family</i>, <i>slant</i>, and <i>weight</i>.
 These font faces are used in implementation of the the cairo "toy" font API.
<p></p>
If <i>family</i> is the zero-length string "", the platform-specific
 default <i>family</i> is assumed. The default <i>family</i> then
 can be queried using <span class="d_inlinecode">getFamily()</span>.
<p></p>

 The <span class="d_inlinecode">Context.selectFontFace()</span> function uses this to create
 font faces. See that function for limitations and
 other details of toy font faces.<p></p>

</dd>
<dt class="d_decl">string <a name="getFamily"></a><span class="ddoc_psymbol">getFamily</span>();
</dt>
<dd>Gets the familly name of a toy font.<p></p>

</dd>
<dt class="d_decl">FontSlant <a name="getSlant"></a><span class="ddoc_psymbol">getSlant</span>();
</dt>
<dd>Gets the slant a toy font.<p></p>

</dd>
<dt class="d_decl">FontWeight <a name="getWeight"></a><span class="ddoc_psymbol">getWeight</span>();
</dt>
<dd>Gets the weight of a toy font.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="Version"></a><span class="ddoc_psymbol">Version</span>;
</dt>
<dd>Cairo version information<p></p>

<dl><dt class="d_decl">uint <a name="major"></a><span class="ddoc_psymbol">major</span>;
<br>uint <a name="minor"></a><span class="ddoc_psymbol">minor</span>;
<br>uint <a name="micro"></a><span class="ddoc_psymbol">micro</span>;
</dt>
<dd>Major, Minor and Micro versions<p></p>

</dd>
<dt class="d_decl">this(ulong <i>encoded</i>);
</dt>
<dd>Construct a version object from a <i>encoded</i> version.<p></p>

</dd>
<dt class="d_decl">this(uint <i>major</i>, uint <i>minor</i>, uint <i>micro</i>);
</dt>
<dd>Construct a version object from version components.<p></p>

</dd>
<dt class="d_decl">static @property Version <a name="cairoVersion"></a><span class="ddoc_psymbol">cairoVersion</span>();
</dt>
<dd>Return the (runtime) version of the used cairo
 library.<p></p>

</dd>
<dt class="d_decl">static @property Version <a name="bindingVersion"></a><span class="ddoc_psymbol">bindingVersion</span>();
</dt>
<dd>Returns the (compile time) version of this binding / wrapper.<p></p>

</dd>
<dt class="d_decl">ulong <a name="encode"></a><span class="ddoc_psymbol">encode</span>();
</dt>
<dd>Returns the version in encoded form.<p></p>

</dd>
<dt class="d_decl">string <a name="toString"></a><span class="ddoc_psymbol">toString</span>();
</dt>
<dd><a name="toString"></a><span class="ddoc_psymbol">toString</span> implementation<p></p>

</dd>
</dl>
</dd>
</dl>

    
</div>


<div id="copyright">
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
